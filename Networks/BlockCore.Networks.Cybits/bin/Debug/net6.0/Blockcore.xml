<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Blockcore</name>
    </assembly>
    <members>
        <member name="T:Blockcore.AsyncWork.AsyncLoop">
            <summary>
            Allows running application defined in a loop with specific timing.
            <para>
            It is possible to specify a startup delay, which will cause the first execution of the task to be delayed.
            It is also possible to specify a delay between two executions of the task. And finally, it is possible
            to make the task run only once. Running the task for other than one or infinite number of times is not supported.
            </para>
            </summary>
        </member>
        <member name="F:Blockcore.AsyncWork.AsyncLoop.logger">
            <summary>Instance logger.</summary>
        </member>
        <member name="F:Blockcore.AsyncWork.AsyncLoop.loopAsync">
            <summary>
            Application defined task that will be called and awaited in the async loop.
            The task is given a cancellation token that allows it to recognize that the caller wishes to cancel it.
            </summary>
        </member>
        <member name="P:Blockcore.AsyncWork.AsyncLoop.Name">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.AsyncWork.AsyncLoop.RunningTask">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.AsyncWork.AsyncLoop.RepeatEvery">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.AsyncWork.AsyncLoop.UncaughtException">
            <summary>
            Gets the uncaught exception, if available.
            </summary>
            <value>
            The uncaught exception.
            </value>
        </member>
        <member name="M:Blockcore.AsyncWork.AsyncLoop.#ctor(System.String,Microsoft.Extensions.Logging.ILogger,System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task})">
            <summary>
            Initializes a named instance of the object.
            </summary>
            <param name="name">Name of the loop.</param>
            <param name="logger">Logger for the new instance.</param>
            <param name="loop">Application defined task that will be called and awaited in the async loop.</param>
        </member>
        <member name="M:Blockcore.AsyncWork.AsyncLoop.Run(System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan})">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.AsyncWork.AsyncLoop.Run(System.Threading.CancellationToken,System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan})">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.AsyncWork.AsyncLoop.StartAsync(System.Threading.CancellationToken,System.Nullable{System.TimeSpan})">
            <summary>
            Starts an application defined task inside the async loop.
            </summary>
            <param name="cancellation">Cancellation token that triggers when the task and the loop should be cancelled.</param>
            <param name="delayStart">Delay before the first run of the task, or null if no startup delay is required.</param>
        </member>
        <member name="M:Blockcore.AsyncWork.AsyncLoop.Dispose">
            <summary>
            Wait for the loop task to complete.
            </summary>
        </member>
        <member name="T:Blockcore.AsyncWork.AsyncProvider">
            <summary>
            Provides functionality for creating and tracking asynchronous operations that happen in the background.
            </summary>
        </member>
        <member name="F:Blockcore.AsyncWork.AsyncProvider.asyncDelegates">
            <summary>
            Holds a list of currently running async delegates or delegates that stopped because of unhandled exceptions.
            Protected by <see cref="F:Blockcore.AsyncWork.AsyncProvider.lockAsyncDelegates"/> lock
            </summary>
        </member>
        <member name="F:Blockcore.AsyncWork.AsyncProvider.registeredTasks">
            <summary>
            Holds a list of currently registered tasks with their health status.
            Protected by <see cref="F:Blockcore.AsyncWork.AsyncProvider.lockRegisteredTasks"/> lock
            </summary>
        </member>
        <member name="P:Blockcore.AsyncWork.AsyncProvider.Signals">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.AsyncWork.AsyncProvider.CreateAndRunAsyncDelegateDequeuer``1(System.String,System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task})">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.AsyncWork.AsyncProvider.CreateAndRunAsyncLoop(System.String,System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan})">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.AsyncWork.AsyncProvider.CreateAndRunAsyncLoopUntil(System.String,System.Threading.CancellationToken,System.Func{System.Boolean},System.Action,System.Action{System.Exception},System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan})">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.AsyncWork.AsyncProvider.CreateAsyncQueue``1">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.AsyncWork.AsyncProvider.RegisterTask(System.String,System.Threading.Tasks.Task)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.AsyncWork.AsyncProvider.IsAsyncDelegateDequeuerRunning(Blockcore.AsyncWork.IAsyncDelegate)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.AsyncWork.AsyncProvider.IsAsyncDelegateDequeuerRunning(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.AsyncWork.AsyncProvider.IsAsyncLoopRunning(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.AsyncWork.AsyncProvider.IsRegisteredTaskRunning(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.AsyncWork.AsyncProvider.GetStatistics(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.AsyncWork.AsyncProvider.GetAll">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.AsyncWork.AsyncProvider.OnRegisteredTaskUnhandledException(System.Threading.Tasks.Task)">
            <summary>
             This method is called when a registered Task throws an unhandled exception.
            </summary>
            <param name="task">The task causing the exception.</param>
        </member>
        <member name="M:Blockcore.AsyncWork.AsyncProvider.OnAsyncDelegateUnhandledException(System.Threading.Tasks.Task,System.Object)">
            <summary>
             This method is called when a Task running an <see cref="T:Blockcore.AsyncWork.IAsyncDelegate"/> captured an unhandled exception.
            </summary>
            <param name="task">The delegate task.</param>
            <param name="state">The <see cref="T:Blockcore.AsyncWork.IAsyncDelegate"/> that's run by the delegateTask</param>
            <remarks>state can be either of type <see cref="T:Blockcore.AsyncWork.IAsyncDelegateDequeuer`1"/> or <see cref="T:Blockcore.AsyncWork.IAsyncLoop"/></remarks>
        </member>
        <member name="M:Blockcore.AsyncWork.AsyncProvider.OnAsyncDelegateCompleted(System.Threading.Tasks.Task,System.Object)">
            <summary>
             This method is called when a Task running an <see cref="T:Blockcore.AsyncWork.IAsyncDelegate"/> completed or was canceled.
             It removes the task information from the internal dictionary.
            </summary>
            <param name="task">The delegate task.</param>
            <param name="state">The <see cref="T:Blockcore.AsyncWork.IAsyncDelegate"/> that's run by the delegateTask</param>
        </member>
        <member name="T:Blockcore.AsyncWork.AsyncProvider.IAsyncTaskInfoSetter">
            <summary>
            Interface used to allow BackgroundWorkProvider to set private properties
            </summary>
        </member>
        <member name="T:Blockcore.AsyncWork.AsyncProvider.AsyncTaskInfo">
            <summary>
            Class that holds the status of running or faulted async delegate created by the BackgroundWorkProvider
            </summary>
            <seealso cref="T:Blockcore.AsyncWork.AsyncProvider.IAsyncTaskInfoSetter" />
        </member>
        <member name="F:Blockcore.AsyncWork.AsyncProvider.AsyncTaskInfo.AsyncTaskType.Loop">
            <summary> Refers to an <see cref="T:Blockcore.AsyncWork.IAsyncLoop"/>.</summary>
        </member>
        <member name="F:Blockcore.AsyncWork.AsyncProvider.AsyncTaskInfo.AsyncTaskType.Dequeuer">
            <summary> Refers to an <see cref="T:Blockcore.AsyncWork.IAsyncDelegateDequeuer`1"/>.</summary>
        </member>
        <member name="F:Blockcore.AsyncWork.AsyncProvider.AsyncTaskInfo.AsyncTaskType.RegisteredTask">
            <summary> Refers to a registered <see cref="T:System.Threading.Tasks.Task"/>.</summary>
        </member>
        <member name="P:Blockcore.AsyncWork.AsyncProvider.AsyncTaskInfo.Status">
            <summary>
            Gets the status of the task running the delegate.
            </summary>
        </member>
        <member name="P:Blockcore.AsyncWork.AsyncProvider.AsyncTaskInfo.Type">
            <summary>
            Specifies which type of async worker this instance contains information about.
            </summary>
        </member>
        <member name="M:Blockcore.AsyncWork.AsyncProvider.AsyncTaskInfo.#ctor(System.String,Blockcore.AsyncWork.AsyncProvider.AsyncTaskInfo.AsyncTaskType)">
            <summary>
            Initializes a new instance of the <see cref="T:Blockcore.AsyncWork.AsyncProvider.AsyncTaskInfo"/> class.
            </summary>
            <param name="friendlyName">Friendly name of the async delegate.</param>
            <param name="isDelegateWorker">if set to <c>true</c> the information represents an <see cref="!:IAsyncDelegateDequeuer"/>, otherwise an <see cref="T:Blockcore.AsyncWork.IAsyncLoop"/>.</param>
        </member>
        <member name="T:Blockcore.AsyncWork.AsyncQueue`1">
            <summary>
            Async queue is a thread-safe queue that can operate in callback mode or blocking dequeue mode.
            In callback mode it asynchronously executes a user-defined callback when a new item is added to the queue.
            In blocking dequeue mode, <see cref="M:Blockcore.AsyncWork.AsyncQueue`1.DequeueAsync(System.Threading.CancellationToken)"/> is used to wait for and dequeue
            an item from the queue once it becomes available.
            <para>
            In callback mode, the queue guarantees that the user-defined callback is executed only once at the time.
            If another item is added to the queue, the callback is called again after the current execution
            is finished.
            </para>
            </summary>
            <typeparam name="T">Type of items to be inserted in the queue.</typeparam>
        </member>
        <member name="T:Blockcore.AsyncWork.AsyncQueue`1.AsyncContext">
            <summary>
            Execution context holding information about the current status of the execution
            in order to recognize if <see cref="M:Blockcore.AsyncWork.AsyncQueue`1.Dispose"/> was called within the callback method.
            </summary>
        </member>
        <member name="P:Blockcore.AsyncWork.AsyncQueue`1.AsyncContext.DisposeRequested">
            <summary>
            Set to <c>true</c> if <see cref="M:Blockcore.AsyncWork.AsyncQueue`1.Dispose"/> was called from within the callback routine,
            set to <c>false</c> otherwise.
            </summary>
        </member>
        <member name="T:Blockcore.AsyncWork.AsyncQueue`1.OnEnqueueAsync">
            <summary>
            Represents a callback method to be executed when a new item is added to the queue.
            </summary>
            <param name="item">Newly added item.</param>
            <param name="cancellationToken">Cancellation token that the callback method should use for its async operations to avoid blocking the queue during shutdown.</param>
            <remarks>It is allowed to call <see cref="M:Blockcore.AsyncWork.AsyncQueue`1.Dispose"/> from the callback method.</remarks>
        </member>
        <member name="F:Blockcore.AsyncWork.AsyncQueue`1.lockObject">
            <summary>Lock object to protect access to <see cref="F:Blockcore.AsyncWork.AsyncQueue`1.items"/>.</summary>
        </member>
        <member name="F:Blockcore.AsyncWork.AsyncQueue`1.items">
            <summary>Storage of items in the queue that are waiting to be consumed.</summary>
            <remarks>All access to this object has to be protected by <see cref="F:Blockcore.AsyncWork.AsyncQueue`1.lockObject"/>.</remarks>
        </member>
        <member name="F:Blockcore.AsyncWork.AsyncQueue`1.signal">
            <summary>Event that is triggered when at least one new item is waiting in the queue.</summary>
        </member>
        <member name="F:Blockcore.AsyncWork.AsyncQueue`1.onEnqueueAsync">
            <summary>Callback routine to be called when a new item is added to the queue.</summary>
        </member>
        <member name="P:Blockcore.AsyncWork.AsyncQueue`1.ConsumerTask">
            <summary>Consumer of the items in the queue which responsibility is to execute the user defined callback.</summary>
            <remarks>Internal for test purposes.</remarks>
        </member>
        <member name="F:Blockcore.AsyncWork.AsyncQueue`1.cancellationTokenSource">
            <summary>Cancellation that is triggered when the component is disposed.</summary>
        </member>
        <member name="F:Blockcore.AsyncWork.AsyncQueue`1.unfinishedDequeueCount">
            <summary>Number of pending dequeue operations which need to be finished before the queue can fully dispose.</summary>
        </member>
        <member name="F:Blockcore.AsyncWork.AsyncQueue`1.disposed">
            <summary><c>true</c> if <see cref="M:Blockcore.AsyncWork.AsyncQueue`1.Dispose"/> was called, <c>false</c> otherwise.</summary>
        </member>
        <member name="F:Blockcore.AsyncWork.AsyncQueue`1.callbackMode">
            <summary><c>true</c> if the queue operates in callback mode, <c>false</c> if it operates in blocking dequeue mode.</summary>
        </member>
        <member name="F:Blockcore.AsyncWork.AsyncQueue`1.asyncContext">
            <summary>
            Async context to allow to recognize whether <see cref="M:Blockcore.AsyncWork.AsyncQueue`1.Dispose"/> was called from within the callback routine.
            <para>
            Is not <c>null</c> if the queue is operating in callback mode and the current async execution context is the one that executes the callbacks,
            set to <c>null</c> otherwise.
            </para>
            </summary>
        </member>
        <member name="M:Blockcore.AsyncWork.AsyncQueue`1.#ctor(Blockcore.AsyncWork.AsyncQueue{`0}.OnEnqueueAsync)">
            <summary>
            Initializes the queue either in blocking dequeue mode or in callback mode.
            </summary>
            <param name="onEnqueueAsync">Callback routine to be called when a new item is added to the queue, or <c>null</c> to operate in blocking dequeue mode.</param>
        </member>
        <member name="M:Blockcore.AsyncWork.AsyncQueue`1.Enqueue(`0)">
            <summary>
            Add a new item to the queue and signal to the consumer task.
            </summary>
            <param name="item">Item to be added to the queue.</param>
        </member>
        <member name="P:Blockcore.AsyncWork.AsyncQueue`1.Count">
            <summary>
            The number of items in the queue.
            This property should only be used for collecting statistics.
            </summary>
        </member>
        <member name="M:Blockcore.AsyncWork.AsyncQueue`1.ConsumerAsync">
            <summary>
            Consumer of the newly added items to the queue that waits for the signal
            and then executes the user-defined callback.
            <para>
            This consumer loop is only used when the queue is operating in the callback mode.
            </para>
            </summary>
        </member>
        <member name="M:Blockcore.AsyncWork.AsyncQueue`1.DequeueAsync(System.Threading.CancellationToken)">
            <summary>
            Dequeues an item from the queue if there is one.
            If the queue is empty, the method waits until an item is available.
            </summary>
            <param name="cancellation">Cancellation token that allows aborting the wait if the queue is empty.</param>
            <returns>Dequeued item from the queue.</returns>
            <exception cref="T:System.OperationCanceledException">Thrown when the cancellation token is triggered or when the queue is disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown if this method is called on a queue that operates in callback mode.</exception>
        </member>
        <member name="M:Blockcore.AsyncWork.AsyncQueue`1.TryDequeue(`0@)">
            <summary>
            Dequeues an item from the queue if there is any.
            </summary>
            <param name="item">If the function succeeds, this is filled with the dequeued item.</param>
            <returns><c>true</c> if an item was dequeued, <c>false</c> if the queue was empty.</returns>
        </member>
        <member name="M:Blockcore.AsyncWork.AsyncQueue`1.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.AsyncWork.AsyncQueue`1.DisposeInternal(System.Boolean)">
            <summary>
            Frees resources used by the queue and only returns until all unfinished tasks of the objects are finished.
            </summary>
            <param name="calledFromConsumerTask"><c>true</c> if this method is called from <see cref="P:Blockcore.AsyncWork.AsyncQueue`1.ConsumerTask"/>, <c>false</c> otherwise.</param>
        </member>
        <member name="T:Blockcore.AsyncWork.IAsyncDelegate">
            <summary>
            Interface that represents a disposable async delegate.
            </summary>
            <seealso cref="T:System.IDisposable" />
        </member>
        <member name="T:Blockcore.AsyncWork.IAsyncDelegateDequeuer`1">
            <summary>
            Define a delegate that is called asynchronously in the background whenever a new <typeparamref name="T"/> is queued and run it.
            </summary>
            <typeparam name="T">Type of the queued items used in the delegate.</typeparam>
            <seealso cref="T:System.IDisposable" />
        </member>
        <member name="M:Blockcore.AsyncWork.IAsyncDelegateDequeuer`1.Enqueue(`0)">
            <summary>
            Add a new item to the queue and signal to the consumer task.
            </summary>
            <param name="item">Item to be added to the queue.</param>
        </member>
        <member name="P:Blockcore.AsyncWork.IAsyncDelegateDequeuer`1.Count">
            <summary>
            The number of items in the queue.
            This property should only be used for collecting statistics.
            </summary>
        </member>
        <member name="T:Blockcore.AsyncWork.IAsyncLoop">
            <summary>
            Allows running application defined in a loop with specific timing.
            </summary>
        </member>
        <member name="P:Blockcore.AsyncWork.IAsyncLoop.Name">
            <summary>Name of the loop. It is used for logging.</summary>
        </member>
        <member name="P:Blockcore.AsyncWork.IAsyncLoop.RepeatEvery">
            <summary>Interval between each execution of the task.</summary>
        </member>
        <member name="M:Blockcore.AsyncWork.IAsyncLoop.Run(System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan})">
            <summary>
            Starts an application defined task inside the async loop.
            </summary>
            <param name="repeatEvery">Interval between each execution of the task.
            If this is <see cref="!:TimeSpans.RunOnce"/>, the task is only run once and there is no loop.
            If this is null, the task is repeated every 1 second by default.</param>
            <param name="startAfter">Delay before the first run of the task, or null if no startup delay is required.</param>
        </member>
        <member name="M:Blockcore.AsyncWork.IAsyncLoop.Run(System.Threading.CancellationToken,System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan})">
            <summary>
            Starts an application defined task inside the async loop.
            </summary>
            <param name="cancellation">Cancellation token that triggers when the task and the loop should be cancelled.</param>
            <param name="repeatEvery">Interval between each execution of the task.
            If this is <see cref="!:TimeSpans.RunOnce"/>, the task is only run once and there is no loop.
            If this is null, the task is repeated every 1 second by default.</param>
            <param name="startAfter">Delay before the first run of the task, or null if no startup delay is required.</param>
        </member>
        <member name="P:Blockcore.AsyncWork.IAsyncLoop.RunningTask">
            <summary>
            The task representing the loop being executed.
            </summary>
        </member>
        <member name="M:Blockcore.AsyncWork.IAsyncProvider.CreateAsyncQueue``1">
            <summary>
            Creates a queue that can be dequeued asynchronously by multiple threads.
            </summary>
            <typeparam name="T">Type of the queued items.</typeparam>
            <returns></returns>
        </member>
        <member name="M:Blockcore.AsyncWork.IAsyncProvider.CreateAndRunAsyncDelegateDequeuer``1(System.String,System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task})">
            <summary>
            Creates a delegate that is called asynchronously in the background whenever a new <typeparamref name="T"/> is queued.
            </summary>
            <typeparam name="T">Type of the queued items used in the delegate.</typeparam>
            <param name="name">Name of the delegate.</param>
            <param name="delegate">The delegate.</param>
            <returns></returns>
        </member>
        <member name="M:Blockcore.AsyncWork.IAsyncProvider.CreateAndRunAsyncLoop(System.String,System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan})">
            <summary>
            Creates an starts an application defined task inside a newly created async loop.
            </summary>
            <param name="name">Name of the loop.</param>
            <param name="loop">The loop.</param>
            <param name="cancellation">Cancellation token that triggers when the task and the loop should be cancelled.</param>
            <param name="repeatEvery">Interval between each execution of the task.
            If this is <see cref="P:Blockcore.Utilities.TimeSpans.RunOnce"/>, the task is only run once and there is no loop.
            If this is null, the task is repeated every 1 second by default.</param>
            <param name="startAfter">Delay before the first run of the task, or null if no startup delay is required.</param>
            <returns></returns>
        </member>
        <member name="M:Blockcore.AsyncWork.IAsyncProvider.CreateAndRunAsyncLoopUntil(System.String,System.Threading.CancellationToken,System.Func{System.Boolean},System.Action,System.Action{System.Exception},System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan})">
            <summary>
            Creates an starts an application defined task inside a newly created async loop and stop it.
            </summary>
            <param name="name">Name of the loop.</param>
            <param name="cancellation">Cancellation token that triggers when the task and the loop should be cancelled.</param>
            <param name="condition">The condition that ensure the loop to continue (true) or stop it(false).</param>
            <param name="action">The action to execute in loop.</param>
            <param name="onException">Invoked when the condition or the action throws an exception.</param>
            <param name="repeatEvery">Interval between each execution of the task.
            If this is <see cref="P:Blockcore.Utilities.TimeSpans.RunOnce" />, the task is only run once and there is no loop.
            If this is null, the task is repeated every 1 second by default.</param>
            <param name="startAfter">Delay before the first run of the task, or null if no startup delay is required.</param>
            <returns></returns>
        </member>
        <member name="M:Blockcore.AsyncWork.IAsyncProvider.RegisterTask(System.String,System.Threading.Tasks.Task)">
            <summary>
            Registers the passed task to be able to monitor it's health status.
            It doesn't perform any schedule on the task, it's all up to the caller to handle the task life-cycle.
            </summary>
            <param name="name">The name assigned to the task.</param>
            <param name="taskToRegister">The task to register.</param>
            <returns>The same task passed as argument</returns>
        </member>
        <member name="M:Blockcore.AsyncWork.IAsyncProvider.IsAsyncDelegateDequeuerRunning(System.String)">
            <summary>
            Determines whether an <see cref="T:Blockcore.AsyncWork.IAsyncDelegateDequeuer`1" /> with the specified name is running.
            </summary>
            <param name="name">The name.</param>
            <returns>
              <c>true</c> if an <see cref="T:Blockcore.AsyncWork.IAsyncDelegateDequeuer`1" /> with the specified name is currently running, otherwise, <c>false</c>.
            </returns>
            <remarks>
            Names are not unique, consider adding prefixes to names when <see cref="T:Blockcore.AsyncWork.IAsyncDelegateDequeuer`1" /> are transient and does not act like singletons. This method is mostly used for tests.
            </remarks>
        </member>
        <member name="M:Blockcore.AsyncWork.IAsyncProvider.IsAsyncLoopRunning(System.String)">
            <summary>
            Determines whether an <see cref="T:Blockcore.AsyncWork.IAsyncLoop" /> with the specified name is running.
            </summary>
            <param name="name">The name.</param>
            <returns>
              <c>true</c> if an <see cref="T:Blockcore.AsyncWork.IAsyncLoop" /> with the specified name is currently running, otherwise, <c>false</c>.
            </returns>
            <remarks>
            Names are not guaranteed to be unique, consider adding prefixes to names when <see cref="T:Blockcore.AsyncWork.IAsyncLoop" /> are transient and does not act like singletons. This method is mostly used for tests.
            </remarks>
        </member>
        <member name="M:Blockcore.AsyncWork.IAsyncProvider.IsAsyncDelegateDequeuerRunning(Blockcore.AsyncWork.IAsyncDelegate)">
            <summary>
            Determines whether a specified <see cref="T:Blockcore.AsyncWork.IAsyncDelegate" /> is running.
            </summary>
            <param name="asyncDelegate">The asynchronous delegate to check.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:Blockcore.AsyncWork.IAsyncDelegate" /> is currently running, otherwise, <c>false</c>.
            </returns>
            <remarks>
            Names are not guaranteed to be unique, consider adding prefixes to names when loops are transient and does not act like singletons.
            This method is mostly used for tests.
            state can be either of type <see cref="T:Blockcore.AsyncWork.IAsyncDelegateDequeuer`1" /> or <see cref="T:Blockcore.AsyncWork.IAsyncLoop" />
            </remarks>
        </member>
        <member name="M:Blockcore.AsyncWork.IAsyncProvider.IsRegisteredTaskRunning(System.String)">
            <summary>
            Determines whether a registered <see cref="T:System.Threading.Tasks.Task" /> with the specified name is running.
            </summary>
            <param name="name">The friendly name of the task.</param>
            <returns>
              <c>true</c> if a <see cref="T:System.Threading.Tasks.Task" /> with the specified name is currently running, otherwise, <c>false</c>.
            </returns>
            <remarks>
            Names are not guaranteed to be unique, consider adding prefixes to names when <see cref="T:Blockcore.AsyncWork.IAsyncLoop" /> are transient and does not act like singletons. This method is mostly used for tests.
            </remarks>
        </member>
        <member name="M:Blockcore.AsyncWork.IAsyncProvider.GetStatistics(System.Boolean)">
            <summary>
            Returns statistics about running or faulted async loops.
            </summary>
            <param name="faultyOnly">if set to <c>true</c> dump information only for loops in faulty state.</param>
        </member>
        <member name="P:Blockcore.AsyncWork.IAsyncProvider.Signals">
            <summary>
            temporary hack to expose signals to most of the components (every component currently using asyncprovider), while we decide if we should introduce a component
            that references common services/components used almost in every other features.
            This has to be removed once the "ICoreComponents" has been created and injected everywhere or when we decide that we still have to inject single services where needed.
            In favor of ICoreComponents, everytime we need a new core service around, we spend lot of time refactoring every test and many legacy component.
            Having a single entry point for COMMON SERVICES allows us to speed up changes.
            </summary>
        </member>
        <member name="M:Blockcore.AsyncWork.IAsyncProvider.GetAll">
            <summary>
            Returns a list of friendly names of all loops, as well as their current status.
            </summary>
        </member>
        <member name="T:Blockcore.AsyncWork.IAsyncQueue`1">
            <summary>
            Defines a queue that can be dequeued asynchronously by multiple threads.
            </summary>
        </member>
        <member name="P:Blockcore.AsyncWork.IAsyncQueue`1.Count">
            <summary>
            The number of items in the queue.
            This property should only be used for collecting statistics.
            </summary>
        </member>
        <member name="M:Blockcore.AsyncWork.IAsyncQueue`1.Enqueue(`0)">
            <summary>
            Add a new item to the queue.
            </summary>
            <param name="item">Item to be added to the queue.</param>
        </member>
        <member name="M:Blockcore.AsyncWork.IAsyncQueue`1.TryDequeue(`0@)">
            <summary>
            Dequeues an item from the queue if there is any.
            </summary>
            <param name="item">If the function succeeds, this is filled with the dequeued item.</param>
            <returns><c>true</c> if an item was dequeued, <c>false</c> if the queue was empty.</returns>
        </member>
        <member name="M:Blockcore.AsyncWork.IAsyncQueue`1.DequeueAsync(System.Threading.CancellationToken)">
            <summary>
            Dequeues an item from the queue if there is one.
            If the queue is empty, the method waits until an item is available.
            </summary>
            <param name="cancellation">Cancellation token that allows aborting the wait if the queue is empty.</param>
            <returns>Dequeued item from the queue.</returns>
            <exception cref="T:System.OperationCanceledException">Thrown when the cancellation token is triggered or when the queue is disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown if this method is called on a queue that operates in callback mode.</exception>
        </member>
        <member name="T:Blockcore.Base.BaseFeature">
            <summary>
            Base node services, these are the services a node has to have.
            The ConnectionManager feature is also part of the base but may go in a feature of its own.
            The base features are the minimal components required to connect to peers and maintain the best chain.
            <para>
            The base node services for a node are:
            <list type="bullet">
            <item>the ConcurrentChain to keep track of the best chain,</item>
            <item>the ConnectionManager to connect with the network,</item>
            <item>DatetimeProvider and Cancellation,</item>
            <item>CancellationProvider and Cancellation,</item>
            <item>DataFolder,</item>
            <item>ChainState.</item>
            </list>
            </para>
            </summary>
        </member>
        <member name="F:Blockcore.Base.BaseFeature.nodeLifetime">
            <summary>Global application life cycle control - triggers when application shuts down.</summary>
        </member>
        <member name="F:Blockcore.Base.BaseFeature.chainState">
            <summary>Information about node's chain.</summary>
        </member>
        <member name="F:Blockcore.Base.BaseFeature.chainRepository">
            <summary>Access to the database of blocks.</summary>
        </member>
        <member name="F:Blockcore.Base.BaseFeature.nodeSettings">
            <summary>User defined node settings.</summary>
        </member>
        <member name="F:Blockcore.Base.BaseFeature.dataFolder">
            <summary>Locations of important folders and files on disk.</summary>
        </member>
        <member name="F:Blockcore.Base.BaseFeature.chainIndexer">
            <summary>Thread safe chain of block headers from genesis.</summary>
        </member>
        <member name="F:Blockcore.Base.BaseFeature.connectionManager">
            <summary>Manager of node's network connections.</summary>
        </member>
        <member name="F:Blockcore.Base.BaseFeature.dateTimeProvider">
            <summary>Provider of time functions.</summary>
        </member>
        <member name="F:Blockcore.Base.BaseFeature.asyncProvider">
            <summary>Provider for creating and managing background async loop tasks.</summary>
        </member>
        <member name="F:Blockcore.Base.BaseFeature.logger">
            <summary>Logger for the node.</summary>
        </member>
        <member name="F:Blockcore.Base.BaseFeature.loggerFactory">
            <summary>Factory for creating loggers.</summary>
        </member>
        <member name="F:Blockcore.Base.BaseFeature.timeSyncBehaviorState">
            <summary>State of time synchronization feature that stores collected data samples.</summary>
        </member>
        <member name="F:Blockcore.Base.BaseFeature.peerAddressManager">
            <summary>Manager of node's network peers.</summary>
        </member>
        <member name="F:Blockcore.Base.BaseFeature.flushAddressManagerLoop">
            <summary>Periodic task to save list of peers to disk.</summary>
        </member>
        <member name="F:Blockcore.Base.BaseFeature.flushChainLoop">
            <summary>Periodic task to save the chain to the database.</summary>
        </member>
        <member name="F:Blockcore.Base.BaseFeature.peerBanning">
            <summary>A handler that can manage the lifetime of network peers.</summary>
        </member>
        <member name="F:Blockcore.Base.BaseFeature.initialBlockDownloadState">
            <summary>Provider of IBD state.</summary>
        </member>
        <member name="F:Blockcore.Base.BaseFeature.network">
            <inheritdoc cref="T:Blockcore.Networks.Network"/>
        </member>
        <member name="F:Blockcore.Base.BaseFeature.finalizedBlockInfoRepository">
            <inheritdoc cref="T:Blockcore.Consensus.IFinalizedBlockInfoRepository"/>
        </member>
        <member name="F:Blockcore.Base.BaseFeature.partialValidator">
            <inheritdoc cref="T:Blockcore.Consensus.Validators.IPartialValidator"/>
        </member>
        <member name="M:Blockcore.Base.BaseFeature.InitializeAsync">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Base.BaseFeature.StartChainAsync">
            <summary>
            Initializes node's chain repository.
            Creates periodic task to persist changes to the database.
            </summary>
        </member>
        <member name="M:Blockcore.Base.BaseFeature.StartAddressManager(Blockcore.P2P.Peer.NetworkPeerConnectionParameters)">
            <summary>
            Initializes node's address manager. Loads previously known peers from the file
            or creates new peer file if it does not exist. Creates periodic task to persist changes
            in peers to disk.
            </summary>
        </member>
        <member name="M:Blockcore.Base.BaseFeature.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Base.FullNodeBuilderBaseFeatureExtension">
            <summary>
            A class providing extension methods for <see cref="T:Blockcore.Builder.IFullNodeBuilder"/>.
            </summary>
        </member>
        <member name="M:Blockcore.Base.FullNodeBuilderBaseFeatureExtension.UseBaseFeature(Blockcore.Builder.IFullNodeBuilder)">
            <summary>
            Makes the full node use all the required features - <see cref="T:Blockcore.Base.BaseFeature"/>.
            </summary>
            <param name="fullNodeBuilder">Builder responsible for creating the node.</param>
            <returns>Full node builder's interface to allow fluent code.</returns>
        </member>
        <member name="T:Blockcore.Base.IChainState">
            <summary>
            Chain state holds various information related to the status of the chain and its validation.
            </summary>
        </member>
        <member name="P:Blockcore.Base.IChainState.ConsensusTip">
            <summary>ChainBehaviors sharing this state will not broadcast headers which are above <see cref="P:Blockcore.Base.IChainState.ConsensusTip"/>.</summary>
        </member>
        <member name="P:Blockcore.Base.IChainState.BlockStoreTip">
            <summary>The highest stored block in the repository or <c>null</c> if block store feature is not enabled.</summary>
        </member>
        <member name="P:Blockcore.Base.IChainState.BestPeerTip">
            <summary>The tip of the most advanced peer our node is connected to or <c>null</c> if no peer is connected.</summary>
            <remarks>
            This BestPeerTip is a best guess and should be use for informational purposes only
            as it may not always be correct for example if a node is in a reorg state or has no peers.
            </remarks>
        </member>
        <member name="P:Blockcore.Base.IChainState.IsAtBestChainTip">
            <summary>Indicates whether consensus tip is equal to the tip of the most advanced peer node is connected to.</summary>
        </member>
        <member name="P:Blockcore.Base.IChainState.MaxReorgLength">
            <summary>Maximal length of reorganization that the node is willing to accept, or 0 to disable long reorganization protection.</summary>
            <remarks>TODO: This should be removed once consensus options are part of network.</remarks>
        </member>
        <member name="T:Blockcore.Base.ChainState">
            <summary>
            Chain state holds various information related to the status of the chain and its validation.
            The data are provided by different components and the chaine state is a mechanism that allows
            these components to share that data without creating extra dependencies.
            </summary>
            TODO this class should be removed since consensus and block store are moved or about to be moved to base feature
        </member>
        <member name="P:Blockcore.Base.ChainState.ConsensusTip">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Base.ChainState.BlockStoreTip">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Base.ChainState.BestPeerTip">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Base.ChainState.IsAtBestChainTip">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Base.ChainState.MaxReorgLength">
            <summary>Maximal length of reorganization that the node is willing to accept, or 0 to disable long reorganization protection.</summary>
            <remarks>TODO: This should be removed once consensus options are part of network.</remarks>
        </member>
        <member name="F:Blockcore.Base.Deployments.BIP9DeploymentsParameters.AlwaysActive">
            <summary>Special flag for timeout to indicate always active.</summary>
        </member>
        <member name="P:Blockcore.Base.Deployments.BIP9DeploymentsParameters.Bit">
            <summary>Determines which bit in the nVersion field of the block is to be used to signal the soft fork lock-in and activation. It is chosen from the set {0,1,2,...,28}.</summary>
        </member>
        <member name="P:Blockcore.Base.Deployments.BIP9DeploymentsParameters.StartTime">
            <summary>Specifies a minimum median time past of a block at which the bit gains its meaning.</summary>
        </member>
        <member name="P:Blockcore.Base.Deployments.BIP9DeploymentsParameters.Timeout">
            <summary>Specifies a time at which the deployment is considered failed. If the median time past of a block >= timeout and the soft fork has not yet locked in
            (including that block's bit state), the deployment is considered failed on all descendants of the block.</summary>
        </member>
        <member name="P:Blockcore.Base.Deployments.BIP9DeploymentsParameters.Threshold">
            <summary>Specifies the activation threshold for this deployment. The BIP9 specification originally set the threshold at >=1916 blocks (95% of 2016),
            or >=1512 for testnet (75% of 2016). </summary>
        </member>
        <member name="T:Blockcore.Base.Deployments.BIP9DeploymentFlags">
            <summary>
            Contains the <see cref="T:Blockcore.Consensus.ScriptInfo.ScriptVerify" /> and <see cref="T:Blockcore.Consensus.TransactionInfo.Transaction.LockTimeFlags" /> flags to set
            when the deployment goes active.
            </summary>
        </member>
        <member name="T:Blockcore.Base.Deployments.IBIP9DeploymentsArray">
            <summary>
            Interface for recording deployment parameters and returning deployment flags.
            </summary>
        </member>
        <member name="P:Blockcore.Base.Deployments.IBIP9DeploymentsArray.Length">
            <summary>The number of elements/deployments in the array.</summary>
        </member>
        <member name="M:Blockcore.Base.Deployments.IBIP9DeploymentsArray.GetFlags(System.Int32)">
            <summary>
            Gets the flags to set when the deployment goes active.
            </summary>
            <param name="deployment">The deployment number (element index in array).</param>
            <returns>The flags to set.</returns>
        </member>
        <member name="P:Blockcore.Base.Deployments.IBIP9DeploymentsArray.Item(System.Int32)">
            <summary>
            Gets or sets the deployment parameters for a deployment.
            </summary>
            <param name="deployment">The deployment number (element index in array).</param>
            <returns>The deployment parameters if this is a get.</returns>
        </member>
        <member name="T:Blockcore.Base.Deployments.BIP9DeploymentsArray">
            <summary>
            Used for recording deployment parameters and returning deployment flags.
            </summary>
        </member>
        <member name="M:Blockcore.Base.Deployments.BIP9DeploymentsArray.#ctor(System.Int32)">
            <summary>
            Constructs a deployments array of the given length.
            </summary>
            <param name="length">The length of the deployments array to construct.</param>
        </member>
        <member name="M:Blockcore.Base.Deployments.BIP9DeploymentsArray.GetFlags(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Base.Deployments.BIP9DeploymentsArray.Item(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Base.Deployments.BIP9DeploymentsArray.Length">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Base.Deployments.NoBIP9Deployments">
            <summary>
            Used by networks that don't define any deployments or deployment parameters.
            </summary>
        </member>
        <member name="M:Blockcore.Base.Deployments.NoBIP9Deployments.#ctor">
            <summary>
            Constructs a zero-length deployments array.
            </summary>
        </member>
        <member name="M:Blockcore.Base.Deployments.NoBIP9Deployments.GetFlags(System.Int32)">
            <inheritdoc />
        </member>
        <member name="F:Blockcore.Base.Deployments.BuriedDeployments.BIP34">
            <summary>
            Height in coinbase.
            </summary>
        </member>
        <member name="F:Blockcore.Base.Deployments.BuriedDeployments.BIP65">
            <summary>
            Height in OP_CLTV.
            </summary>
        </member>
        <member name="F:Blockcore.Base.Deployments.BuriedDeployments.BIP66">
            <summary>
            Strict DER signature.
            </summary>
        </member>
        <member name="M:Blockcore.Base.Deployments.DeploymentFlags.EnforceBIP30ForBlock(Blockcore.Consensus.Chain.ChainedHeader,Blockcore.Consensus.IConsensus,Blockcore.Consensus.Chain.ChainIndexer)">
            <summary>Calculates if BIP30 should be enforced for given block.</summary>
        </member>
        <member name="T:Blockcore.Base.Deployments.Models.ThresholdStateModel">
            <summary>
            Class representing information about the current activation state of a deployment.
            </summary>
        </member>
        <member name="P:Blockcore.Base.Deployments.Models.ThresholdStateModel.DeploymentName">
            <summary>
            BIP9 deployment index for this soft fork.
            </summary>
        </member>
        <member name="P:Blockcore.Base.Deployments.Models.ThresholdStateModel.DeploymentIndex">
            <summary>
            BIP9 deployment index for this soft fork.
            </summary>
        </member>
        <member name="P:Blockcore.Base.Deployments.Models.ThresholdStateModel.StateValue">
            <summary>
            Activation state of this deployment at this block height.
            </summary>
        </member>
        <member name="P:Blockcore.Base.Deployments.Models.ThresholdStateModel.ThresholdState">
            <summary>
            Readable name of threshold state.
            </summary>
        </member>
        <member name="P:Blockcore.Base.Deployments.Models.ThresholdStateModel.Height">
            <summary>
            Height of the the block with this threshold state.
            </summary>
        </member>
        <member name="P:Blockcore.Base.Deployments.Models.ThresholdStateModel.SinceHeight">
            <summary>
            Height of when the deployment started.
            </summary>
        </member>
        <member name="P:Blockcore.Base.Deployments.Models.ThresholdStateModel.ConfirmationPeriod">
            <summary>
            The number of blocks in each confirmation window.
            </summary>
        </member>
        <member name="P:Blockcore.Base.Deployments.Models.ThresholdStateModel.PeriodStartHeight">
            <summary>
            Height at start of activation window.
            </summary>
        </member>
        <member name="P:Blockcore.Base.Deployments.Models.ThresholdStateModel.PeriodEndHeight">
            <summary>
            Height at end of activation window.
            </summary>
        </member>
        <member name="P:Blockcore.Base.Deployments.Models.ThresholdStateModel.Votes">
            <summary>
            Number of blocks with flags set for this BIP9 deployment in the last confirmation window.
            </summary>
        </member>
        <member name="P:Blockcore.Base.Deployments.Models.ThresholdStateModel.Blocks">
            <summary>
            The total number of blocks in the last confirmation window.
            </summary>
        </member>
        <member name="P:Blockcore.Base.Deployments.Models.ThresholdStateModel.HexVersions">
            <summary>
            A summary of block version counts in the last confirmation window.
            </summary>
        </member>
        <member name="P:Blockcore.Base.Deployments.Models.ThresholdStateModel.Threshold">
            <summary>
            Activation vote threshold for this BIP9 deployment.
            </summary>
        </member>
        <member name="P:Blockcore.Base.Deployments.Models.ThresholdStateModel.TimeStart">
            <summary>
            Start time for vote counting for this BIP9 deployment.
            </summary>
        </member>
        <member name="P:Blockcore.Base.Deployments.Models.ThresholdStateModel.TimeTimeOut">
            <summary>
            End time for vote counting for this BIP9 deployment.
            </summary>
        </member>
        <member name="F:Blockcore.Base.Deployments.NodeDeployments.network">
            <summary>Specification of the network the node runs on - regtest/testnet/mainnet.</summary>
        </member>
        <member name="F:Blockcore.Base.Deployments.NodeDeployments.chainIndexer">
            <summary>Thread safe access to the best chain of block headers (that the node is aware of) from genesis.</summary>
        </member>
        <member name="T:Blockcore.Base.Deployments.ThresholdConditionCache">
            <summary>
            This class tracks the current activation state of each BIP9 deployment.
            </summary>
        </member>
        <member name="M:Blockcore.Base.Deployments.ThresholdConditionCache.#ctor(Blockcore.Consensus.IConsensus)">
            <summary>
            Constructs this object containing the BIP9 deployment states cache.
            </summary>
            <param name="consensus">Records the consensus object containing the activation parameters.</param>
        </member>
        <member name="M:Blockcore.Base.Deployments.ThresholdConditionCache.GetStates(Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>
            Get the states of all BIP 9 deployments listed in the <see cref="!:BIP9Deployments"/> enumeration.
            </summary>
            <param name="pindexPrev">The previous header of the block to determine the states for.</param>
            <returns>An array of <see cref="T:Blockcore.Base.Deployments.ThresholdState"/> objects.</returns>
        </member>
        <member name="M:Blockcore.Base.Deployments.ThresholdConditionCache.GetThresholdStateMetrics(Blockcore.Consensus.Chain.ChainedHeader,Blockcore.Base.Deployments.ThresholdState[])">
            <summary>
            Computes the metrics of all BIP9 deployments for a given block.
            </summary>
            <param name="indexPrev">The block at which to compute the metrics.</param>
            <param name="thresholdStates">The current state of each BIP9 deployment.</param>
            <returns>A <see cref="T:Blockcore.Base.Deployments.Models.ThresholdStateModel" /> object containg the metrics.</returns>
        </member>
        <member name="M:Blockcore.Base.Deployments.ThresholdConditionCache.GetState(Blockcore.Consensus.Chain.ChainedHeader,System.Int32)">
            <summary>
            Determines the state of a BIP from the cache and/or the chain header history and the corresponding version bits.
            </summary>
            <param name="indexPrev">The previous header of the chain header to determine the states for.</param>
            <param name="deployment">The deployment to check the state of.</param>
            <returns>The current state of the deployment.</returns>
        </member>
        <member name="M:Blockcore.Base.Deployments.ThresholdConditionCache.Get(Blockcore.NBitcoin.uint256,System.Int32)">
            <summary>
            Gets the activation state within a given block of a specific BIP9 deployment.
            </summary>
            <param name="hash">The block hash to determine the BIP9 activation state for.</param>
            <param name="deployment">The deployment for which to determine the activation state.</param>
            <returns>The activation state.</returns>
        </member>
        <member name="M:Blockcore.Base.Deployments.ThresholdConditionCache.Set(Blockcore.NBitcoin.uint256,System.Int32,Blockcore.Base.Deployments.ThresholdState)">
            <summary>
            Sets the activation state for a given block of a specific BIP9 deployment.
            </summary>
            <param name="hash">The block hash to set the BIP9 activation state for.</param>
            <param name="deployment">The deployment for which to set the activation state.</param>
            <param name="state">The activation state to set.</param>
        </member>
        <member name="M:Blockcore.Base.Deployments.ThresholdConditionCache.ContainsKey(Blockcore.NBitcoin.uint256,System.Int32)">
            <summary>
            Determines if the activation state is available for a given block hash for a specific deployment.
            </summary>
            <param name="hash">The block hash to determine the BIP9 activation state for.</param>
            <param name="deployment">The deployment for which to determine the activation state.</param>
            <returns>Returns <c>true</c> if the state is available and <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Blockcore.Base.Deployments.ThresholdConditionCache.Condition(Blockcore.Consensus.Chain.ChainedHeader,System.Int32)">
            <summary>
            Inspects the chain header to determine whether the version bit of a deployment is active.
            </summary>
        </member>
        <member name="M:Blockcore.Base.Deployments.ThresholdConditionCache.Mask(System.Int32)">
            <summary>
            Returns the bit mask of the bit representing a specific deployment within the version bits.
            </summary>
            <param name="deployment">The BIP9 deployment to return the bit mask for.</param>
            <returns>The bit mask of the bit representing the deployment within the version bits.</returns>
        </member>
        <member name="M:Blockcore.Base.Deployments.ThresholdConditionCache.Assert(System.Boolean)">
            <summary>
            Throws an 'Assertion failed' exception if the passed argument is <c>false</c>.
            </summary>
            <param name="v">The passed argument which, if false, raises a 'Assertion Failed' exception.</param>
        </member>
        <member name="T:Blockcore.Base.InitialBlockDownloadState">
            <summary>
            Provides IBD (Initial Block Download) state.
            </summary>
            <seealso cref="T:Blockcore.Interfaces.IInitialBlockDownloadState" />
        </member>
        <member name="F:Blockcore.Base.InitialBlockDownloadState.dateTimeProvider">
            <summary>A provider of the date and time.</summary>
        </member>
        <member name="F:Blockcore.Base.InitialBlockDownloadState.checkpoints">
            <summary>Provider of block header hash checkpoints.</summary>
        </member>
        <member name="F:Blockcore.Base.InitialBlockDownloadState.chainState">
            <summary>Information about node's chain.</summary>
        </member>
        <member name="F:Blockcore.Base.InitialBlockDownloadState.logger">
            <summary>Instance logger.</summary>
        </member>
        <member name="F:Blockcore.Base.InitialBlockDownloadState.network">
            <summary>Specification of the network the node runs on - regtest/testnet/mainnet.</summary>
        </member>
        <member name="F:Blockcore.Base.InitialBlockDownloadState.consensusSettings">
            <summary>User defined consensus settings.</summary>
        </member>
        <member name="M:Blockcore.Base.InitialBlockDownloadState.IsInitialBlockDownload">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Base.IInvalidBlockHashStore">
            <summary>
            Contract of a store of block header hashes that are considered invalid.
            </summary>
        </member>
        <member name="M:Blockcore.Base.IInvalidBlockHashStore.IsInvalid(Blockcore.NBitcoin.uint256)">
            <summary>
            Check if a block is marked as invalid.
            </summary>
            <param name="hashBlock">The block hash to check.</param>
            <returns><c>true</c> if the block is marked as invalid, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Blockcore.Base.IInvalidBlockHashStore.MarkInvalid(Blockcore.NBitcoin.uint256,System.Nullable{System.DateTime})">
            <summary>
            Marks a block as invalid.
            </summary>
            <param name="hashBlock">The block hash to mark as invalid.</param>
            <param name="rejectedUntil">Time in UTC after which the block is no longer considered as invalid, or <c>null</c> if the block is to be considered invalid forever.</param>
        </member>
        <member name="T:Blockcore.Base.InvalidBlockHashStore">
            <summary>
            In memory store of invalid block header hashes.
            </summary>
            <remarks>
            The store has a limited capacity. When a new block header hash is marked as invalid
            once the capacity is reached, the oldest entry is removed and no longer considered invalid.
            <para>
            Entries with specified expiration time are either removed just like other entries - i.e. during
            an add operation when a capacity is reached, or they are removed when they are touched
            and it is detected that their expiration time is no longer in the future.
            </para>
            </remarks>
        </member>
        <member name="F:Blockcore.Base.InvalidBlockHashStore.DefaultCapacity">
            <summary>Default value for the maximal number of hashes we can store.</summary>
        </member>
        <member name="F:Blockcore.Base.InvalidBlockHashStore.dateTimeProvider">
            <summary>A provider of the date and time.</summary>
        </member>
        <member name="F:Blockcore.Base.InvalidBlockHashStore.lockObject">
            <summary>Lock object to protect access to <see cref="F:Blockcore.Base.InvalidBlockHashStore.invalidBlockHashesExpirations"/> and <see cref="F:Blockcore.Base.InvalidBlockHashStore.orderedHashList"/>.</summary>
        </member>
        <member name="F:Blockcore.Base.InvalidBlockHashStore.invalidBlockHashesExpirations">
            <summary>
            Collection of block header hashes that are to be considered invalid. If the value of the entry is not <c>null</c>,
            the entry is considered invalid only for a certain amount of time.
            </summary>
            <remarks>All access to this object has to be protected by <see cref="F:Blockcore.Base.InvalidBlockHashStore.lockObject"/>.</remarks>
        </member>
        <member name="F:Blockcore.Base.InvalidBlockHashStore.orderedHashList">
            <summary>
            Circular array of block header hash entries to allow quick removal of the oldest entry once the capacity is reached.
            </summary>
            <remarks>
            All access to this object has to be protected by <see cref="F:Blockcore.Base.InvalidBlockHashStore.lockObject"/>.
            </remarks>
        </member>
        <member name="M:Blockcore.Base.InvalidBlockHashStore.#ctor(Blockcore.Utilities.IDateTimeProvider,System.Int32)">
            <summary>
            Initializes the instance of the object.
            </summary>
            <param name="capacity">Maximal number of hashes we can store.</param>
        </member>
        <member name="M:Blockcore.Base.InvalidBlockHashStore.IsInvalid(Blockcore.NBitcoin.uint256)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Base.InvalidBlockHashStore.MarkInvalid(Blockcore.NBitcoin.uint256,System.Nullable{System.DateTime})">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Base.ITimeSyncBehaviorState">
            <summary>
            Methods related to network peers time synchronization feature.
            </summary>
        </member>
        <member name="M:Blockcore.Base.ITimeSyncBehaviorState.AddTimeData(System.Net.IPAddress,System.TimeSpan,System.Boolean)">
            <summary>
            Adds a time offset sample to the internal database of samples.
            <para></para>
            </summary>
            <param name="peerAddress">IP address of the peer that the sample relates to.</param>
            <param name="offsetSample">Difference in the peer's time and our system time.</param>
            <param name="isInboundConnection"><c>true</c> if the sample comes from a peer that connected to our node,
            <c>false</c> if the sample comes from a peer that our node connected to.</param>
            <returns><c>true</c> if the sample was added to the mix, <c>false</c> otherwise.</returns>
        </member>
        <member name="P:Blockcore.Base.ITimeSyncBehaviorState.IsSystemTimeOutOfSync">
            <summary> A value indicating whether the system time is not in sync and needs adjustment. </summary>
        </member>
        <member name="T:Blockcore.Base.TimeSyncBehaviorState">
            <summary>
            State of time synchronization feature that stores collected data samples
            and calculates adjustments to system time.
            </summary>
            <remarks>
            Bitcoin introduced so called adjusted time, which is implemented as a time offset added
            to node's system time. The offset is result of time syncing feature with network peers that
            collects samples from "version" network message from anyone who connects with our node
            (in any direction). The median of the collected samples is used as the final time offset
            the node uses to calculate the adjusted time.
            <para>
            The actual source of adjusted time is <see cref="T:Blockcore.Utilities.IDateTimeProvider"/>. It is the logic
            behind its calculation and collection of samples that resides in this class. This class
            modifies the date time provider using its interface every time a new time offset sample
            that affects the final offset is collected.
            </para>
            <para>
            Bitcoin allowed up to 70 minutes of time adjustment to be made using this mechanism.
            However, Bitcoin also allowed the blocks to be mined with timestamps that are off by up
            to 2 hours. This is very unlike Stratis' POS, which uses very narrow windows for block
            timestamps. This is why we implemented our mechanism of time syncing with peers
            and adjusted time calculation slightly differently.
            </para>
            <para>
            We also collect samples from network "version" messages and calculate time difference
            for every peer. We DO distinguish between inbound and outbound connections, however.
            We consider inbound connections as less reliable sources of information and we introduce
            <see cref="F:Blockcore.Base.TimeSyncBehaviorState.OffsetWeightSecurityConstant"/> to reflect that. We keep outbound time offset
            samples separated from inbound samples. Our final offset is also a median of collected
            samples, but outbound samples have much greater weight in the median calculation
            as per the given weight, which is dynamically adjusted depending on the inbound outbound ratio
            in order to protect us from all inbound and an accepted percentage of outbound.
            </para>
            <para>
            Bitcoin's implementation only allows certain number of samples to be collected
            and once the limit is reached, no more samples are allowed. We do not replicate this
            behavior and we implement circular array to store the time offset samples.
            This means that once the limit is reached, we replace oldest samples with the new ones.
            </para>
            <para>
            Finally, as the POS chain is much more sensitive to correct time settings, our user
            alerting mechanism is triggered much earlier (for much lower time difference) than
            the one in Bitcoin.
            </para>
            </remarks>
        </member>
        <member name="T:Blockcore.Base.TimeSyncBehaviorState.TimestampOffsetSample">
            <summary>
            Description of a single timestamp offset sample from a peer.
            </summary>
        </member>
        <member name="P:Blockcore.Base.TimeSyncBehaviorState.TimestampOffsetSample.TimeOffset">
            <summary>Difference of the peer's time to our system time.</summary>
        </member>
        <member name="P:Blockcore.Base.TimeSyncBehaviorState.TimestampOffsetSample.Source">
            <summary>IP address of the peer that provided this sample.</summary>
        </member>
        <member name="F:Blockcore.Base.TimeSyncBehaviorState.MaxInboundSamples">
            <summary>Maximal number of samples to keep inside <see cref="F:Blockcore.Base.TimeSyncBehaviorState.inboundTimestampOffsets"/>.</summary>
        </member>
        <member name="F:Blockcore.Base.TimeSyncBehaviorState.MaxOutboundSamples">
            <summary>Maximal number of samples to keep inside <see cref="F:Blockcore.Base.TimeSyncBehaviorState.outboundTimestampOffsets"/>.</summary>
        </member>
        <member name="F:Blockcore.Base.TimeSyncBehaviorState.OffsetWeightSecurityConstant">
            <summary>
            The value of 3 provides enough security to be protected against up to 33.3% of outbound samples being malicious and all inbound being malicious.
            </summary>
        </member>
        <member name="F:Blockcore.Base.TimeSyncBehaviorState.TimeOffsetWarningThresholdSeconds">
            <summary>Maximal value for <see cref="F:Blockcore.Base.TimeSyncBehaviorState.timeOffset"/> in seconds that does not trigger warnings to user.</summary>
        </member>
        <member name="F:Blockcore.Base.TimeSyncBehaviorState.MaxTimeOffsetSeconds">
            <summary>
            Maximal value for <see cref="F:Blockcore.Base.TimeSyncBehaviorState.timeOffset"/>. If the newly calculated value is over this limit,
            the time syncing feature will be switched off.
            </summary>
        </member>
        <member name="F:Blockcore.Base.TimeSyncBehaviorState.MinOutboundSampleCount">
            <summary>
            Minimal amount of outbound samples that should be collected before time adjustment <see cref="F:Blockcore.Base.TimeSyncBehaviorState.timeOffset"/> is changed.
            </summary>
        </member>
        <member name="F:Blockcore.Base.TimeSyncBehaviorState.logger">
            <summary>Instance logger.</summary>
        </member>
        <member name="F:Blockcore.Base.TimeSyncBehaviorState.dateTimeProvider">
            <summary>Provider of time functions.</summary>
        </member>
        <member name="F:Blockcore.Base.TimeSyncBehaviorState.asyncProvider">
            <summary>Factory for creating background async loop tasks.</summary>
        </member>
        <member name="F:Blockcore.Base.TimeSyncBehaviorState.nodeLifetime">
            <summary>Global application life cycle control - triggers when application shuts down.</summary>
        </member>
        <member name="F:Blockcore.Base.TimeSyncBehaviorState.network">
            <summary>The network the node is running on.</summary>
        </member>
        <member name="F:Blockcore.Base.TimeSyncBehaviorState.lockObject">
            <summary>Lock object to protect access to <see cref="F:Blockcore.Base.TimeSyncBehaviorState.timeOffset"/>, <see cref="F:Blockcore.Base.TimeSyncBehaviorState.inboundTimestampOffsets"/>, <see cref="F:Blockcore.Base.TimeSyncBehaviorState.outboundTimestampOffsets"/>,
            <see cref="F:Blockcore.Base.TimeSyncBehaviorState.inboundSampleSources"/>, <see cref="F:Blockcore.Base.TimeSyncBehaviorState.outboundSampleSources"/>.</summary>
        </member>
        <member name="F:Blockcore.Base.TimeSyncBehaviorState.timeOffset">
            <summary>Time difference that the behavior adds to the system time to form adjusted time.</summary>
            <remarks>All access to this object has to be protected by <see cref="F:Blockcore.Base.TimeSyncBehaviorState.lockObject"/>.</remarks>
        </member>
        <member name="F:Blockcore.Base.TimeSyncBehaviorState.inboundTimestampOffsets">
            <summary>List of timestamp offset samples from peers that connected to our node.</summary>
            <remarks>All access to this object has to be protected by <see cref="F:Blockcore.Base.TimeSyncBehaviorState.lockObject"/>.</remarks>
        </member>
        <member name="F:Blockcore.Base.TimeSyncBehaviorState.outboundTimestampOffsets">
            <summary>List of timestamp offset samples from peers that our node connected to.</summary>
            <remarks>All access to this object has to be protected by <see cref="F:Blockcore.Base.TimeSyncBehaviorState.lockObject"/>.</remarks>
        </member>
        <member name="F:Blockcore.Base.TimeSyncBehaviorState.inboundSampleSources">
            <summary>List of IP addresses of peers that provided samples in <see cref="F:Blockcore.Base.TimeSyncBehaviorState.inboundSampleSources"/>.</summary>
            <remarks>All access to this object has to be protected by <see cref="F:Blockcore.Base.TimeSyncBehaviorState.lockObject"/>.</remarks>
        </member>
        <member name="F:Blockcore.Base.TimeSyncBehaviorState.outboundSampleSources">
            <summary>List of IP addresses of peers that provided samples in <see cref="F:Blockcore.Base.TimeSyncBehaviorState.outboundTimestampOffsets"/>.</summary>
            <remarks>All access to this object has to be protected by <see cref="F:Blockcore.Base.TimeSyncBehaviorState.lockObject"/>.</remarks>
        </member>
        <member name="P:Blockcore.Base.TimeSyncBehaviorState.SwitchedOff">
            <summary><c>true</c> if the time sync with peers has been switched off, <c>false</c> otherwise.</summary>
        </member>
        <member name="P:Blockcore.Base.TimeSyncBehaviorState.SwitchedOffLimitReached">
            <summary>
            <c>true</c> if the reason for switching the time sync feature off was that <see cref="F:Blockcore.Base.TimeSyncBehaviorState.timeOffset"/>
            went over the maximal allowed value, <c>false</c> otherwise.
            </summary>
        </member>
        <member name="F:Blockcore.Base.TimeSyncBehaviorState.warningLoop">
            <summary>Periodically shows a console warning to inform the user that the system time needs adjustment,
            otherwise the node may not perform correctly on the network.</summary>
        </member>
        <member name="P:Blockcore.Base.TimeSyncBehaviorState.IsSystemTimeOutOfSync">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.Base.TimeSyncBehaviorState.#ctor(Blockcore.Utilities.IDateTimeProvider,Blockcore.Utilities.INodeLifetime,Blockcore.AsyncWork.IAsyncProvider,Microsoft.Extensions.Logging.ILoggerFactory,Blockcore.Networks.Network)">
            <summary>
            Initializes a new instance of the object.
            </summary>
            <param name="dateTimeProvider">Provider of time functions.</param>
            <param name="nodeLifetime">Global application life cycle control - triggers when application shuts down.</param>
            <param name="asyncProvider">Factory for creating background async loop tasks.</param>
            <param name="loggerFactory">Factory for creating loggers.</param>
            <param name="network">The network the node is running on.</param>
        </member>
        <member name="M:Blockcore.Base.TimeSyncBehaviorState.AddTimeData(System.Net.IPAddress,System.TimeSpan,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Base.TimeSyncBehaviorState.RecalculateTimeOffsetLocked">
            <summary>
            Calculates a new value for <see cref="F:Blockcore.Base.TimeSyncBehaviorState.timeOffset"/> based on existing samples.
            </summary>
            <remarks>
            The caller of this method is responsible for holding <see cref="F:Blockcore.Base.TimeSyncBehaviorState.lockObject"/>.
            <para>
            The function takes a single copy of each inbound sample and combines them with a dynamic number of
            copies of the outbound samples in order to maintain the <see cref="F:Blockcore.Base.TimeSyncBehaviorState.OffsetWeightSecurityConstant"/>.
            </para>
            <para>
            When there are many more inbound samples than outbound, which could be the case
            in a malicious attack, the security is still maintained by using a dynamic inbound/outbound
            ratio multiplier ratio on the outbound samples that maintains the accepted level of security.
            </para>
            <para>
            We require to have at least <see cref="F:Blockcore.Base.TimeSyncBehaviorState.MinOutboundSampleCount"/> outbound samples to change the value of <see cref="F:Blockcore.Base.TimeSyncBehaviorState.timeOffset"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Blockcore.Base.TimeSyncBehaviorState.StartWarningLoop">
            <summary>
            Starts a loop that warns user via console message about problems with system time settings.
            </summary>
        </member>
        <member name="M:Blockcore.Base.TimeSyncBehaviorState.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Base.TimeSyncBehavior">
            <summary>
            Node behavior that collects time offset samples from network "version" messages
            from each peer.
            </summary>
        </member>
        <member name="F:Blockcore.Base.TimeSyncBehavior.loggerFactory">
            <summary>Factory for creating loggers.</summary>
        </member>
        <member name="F:Blockcore.Base.TimeSyncBehavior.logger">
            <summary>Instance logger.</summary>
        </member>
        <member name="F:Blockcore.Base.TimeSyncBehavior.state">
            <summary>Shared state among time sync behaviors that holds list of obtained samples.</summary>
        </member>
        <member name="F:Blockcore.Base.TimeSyncBehavior.dateTimeProvider">
            <summary>Provider of time functions.</summary>
        </member>
        <member name="M:Blockcore.Base.TimeSyncBehavior.#ctor(Blockcore.Base.ITimeSyncBehaviorState,Blockcore.Utilities.IDateTimeProvider,Microsoft.Extensions.Logging.ILoggerFactory)">
            <summary>
            Initializes a new instance of the object.
            </summary>
            <param name="state">Shared state among time sync behaviors.</param>
            <param name="dateTimeProvider">Provider of time functions.</param>
            <param name="loggerFactory">Factory for creating loggers.</param>
        </member>
        <member name="M:Blockcore.Base.TimeSyncBehavior.AttachCore">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Base.TimeSyncBehavior.DetachCore">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Base.TimeSyncBehavior.Clone">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Base.TimeSyncBehavior.OnMessageReceivedAsync(Blockcore.P2P.Peer.INetworkPeer,Blockcore.P2P.Protocol.IncomingMessage)">
            <summary>
            Event handler that is called when the node receives a network message from the attached peer.
            </summary>
            <param name="peer">Peer that sent us the message.</param>
            <param name="message">Received message.</param>
            <remarks>
            This handler only cares about "verack" messages, which are only sent once per node
            and at the time they are sent the time offset information is parsed by underlaying logic.
            <para>
            Note that it is not possible to use "version" message here as <see cref="T:Blockcore.P2P.Peer.INetworkPeer"/>
            does not deliver this message for inbound peers to node behaviors.
            </para>
            </remarks>
        </member>
        <member name="T:Blockcore.Base.ITipProvider">
            <summary>Interface that every tip provider that uses <see cref="T:Blockcore.Base.ITipsManager"/> should implement.</summary>
        </member>
        <member name="T:Blockcore.Base.ITipsManager">
            <summary>Component that keeps track of highest common tip between components that can have a tip.</summary>
        </member>
        <member name="M:Blockcore.Base.ITipsManager.Initialize(Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>Initializes <see cref="T:Blockcore.Base.ITipsManager"/>.</summary>
            <param name="highestHeader">Tip of chain of headers.</param>
        </member>
        <member name="M:Blockcore.Base.ITipsManager.RegisterTipProvider(Blockcore.Base.ITipProvider)">
            <summary>Registers provider of a tip.</summary>
            <remarks>Common tip is selected by finding fork point between tips provided by all registered providers.</remarks>
        </member>
        <member name="M:Blockcore.Base.ITipsManager.GetLastCommonTip">
            <summary>Provides highest tip commited between all registered components.</summary>
        </member>
        <member name="M:Blockcore.Base.ITipsManager.CommitTipPersisted(Blockcore.Base.ITipProvider,Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>
            Commits persisted tip of a component.
            </summary>
            <remarks>
            Commiting a particular tip would mean that in case node is killed immediately component that
            commited such a tip would be able to recover on startup to it or any tip that is ancestor to tip commited.
            </remarks>
        </member>
        <member name="F:Blockcore.Base.TipsManager.tipsByProvider">
            <summary>Highest commited tips mapped by their providers.</summary>
        </member>
        <member name="F:Blockcore.Base.TipsManager.lastCommonTip">
            <summary>Highest tip commited between all registered components.</summary>
        </member>
        <member name="F:Blockcore.Base.TipsManager.lockObject">
            <summary>Protects all access to <see cref="F:Blockcore.Base.TipsManager.tipsByProvider"/> and write access to <see cref="F:Blockcore.Base.TipsManager.lastCommonTip"/>.</summary>
        </member>
        <member name="F:Blockcore.Base.TipsManager.newCommonTipSetEvent">
            <summary>Triggered when <see cref="F:Blockcore.Base.TipsManager.lastCommonTip"/> is updated.</summary>
        </member>
        <member name="F:Blockcore.Base.TipsManager.logger">
            <summary>Instance logger.</summary>
        </member>
        <member name="M:Blockcore.Base.TipsManager.Initialize(Blockcore.Consensus.Chain.ChainedHeader)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Base.TipsManager.PersistCommonTipContinuouslyAsync">
            <summary>Continuously persists <see cref="F:Blockcore.Base.TipsManager.lastCommonTip"/> to hard drive.</summary>
        </member>
        <member name="M:Blockcore.Base.TipsManager.RegisterTipProvider(Blockcore.Base.ITipProvider)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Base.TipsManager.GetLastCommonTip">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Base.TipsManager.CommitTipPersisted(Blockcore.Base.ITipProvider,Blockcore.Consensus.Chain.ChainedHeader)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Base.TipsManager.FindCommonFork(System.Collections.Generic.List{Blockcore.Consensus.Chain.ChainedHeader})">
            <summary>Finds common fork between multiple chains.</summary>
        </member>
        <member name="M:Blockcore.Base.TipsManager.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.BlockPulling.AssignedDownload">
            <summary>Represents a single download assignment to a peer.</summary>
        </member>
        <member name="P:Blockcore.BlockPulling.AssignedDownload.JobId">
            <summary>Unique identifier of a job to which this assignment belongs.</summary>
        </member>
        <member name="P:Blockcore.BlockPulling.AssignedDownload.PeerId">
            <summary>Id of a peer that was assigned to deliver a block.</summary>
        </member>
        <member name="P:Blockcore.BlockPulling.AssignedDownload.AssignedTime">
            <summary>Time when download was assigned to a peer.</summary>
        </member>
        <member name="P:Blockcore.BlockPulling.AssignedDownload.Header">
            <summary>Header of a block associated with this assignment.</summary>
        </member>
        <member name="M:Blockcore.BlockPulling.AssignedDownload.ToString">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.BlockPulling.IBlockPuller">
            <summary>
            Thread-safe block puller which allows downloading blocks from all chains that the node is aware of.
            </summary>
            <remarks>
            It implements relative quality scoring for peers that are used for delivering requested blocks.
            <para>
            If peer that was assigned an important download fails to deliver in maximum allowed time, all his assignments will be reassigned.
            Reassigned downloads are processed with high priority comparing to regular requests.
            Blocks that are close to the node's consensus tip or behind it are considered to be important.
            </para>
            <para>
            Maximum amount of blocks that can be simultaneously downloaded depends on total speed of all peers that are capable of delivering blocks.
            </para>
            <para>
            We never wait for the same block to be delivered from more than 1 peer at once, so in case peer was removed from the assignment
            and delivered after that we will discard delivered block from this peer.
            </para>
            </remarks>
        </member>
        <member name="M:Blockcore.BlockPulling.IBlockPuller.RequestPeerServices(Blockcore.P2P.Protocol.Payloads.NetworkPeerServices)">
            <summary>
            Adds required services to list of services that are required from all peers.
            </summary>
            <remarks>
            In case some of the peers that we are already requesting block from don't support new
            service requirements those peers will be released from their assignments.
            </remarks>
        </member>
        <member name="M:Blockcore.BlockPulling.IBlockPuller.GetAverageBlockSizeBytes">
            <summary>Gets the average size of a block based on sizes of blocks that were previously downloaded.</summary>
        </member>
        <member name="M:Blockcore.BlockPulling.IBlockPuller.OnIbdStateChanged(System.Boolean)">
            <summary>Updates puller behaviors when IDB state is changed.</summary>
            <remarks>Should be called when IBD state was changed or first calculated.</remarks>
        </member>
        <member name="M:Blockcore.BlockPulling.IBlockPuller.NewPeerTipClaimed(Blockcore.P2P.Peer.INetworkPeer,Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>Updates puller's view of peer's tip.</summary>
            <remarks>Should be called when a peer claims a new tip.</remarks>
            <param name="peer">The peer.</param>
            <param name="newTip">New tip.</param>
        </member>
        <member name="M:Blockcore.BlockPulling.IBlockPuller.PeerDisconnected(System.Int32)">
            <summary>Removes information about the peer from the inner structures.</summary>
            <remarks>Adds download jobs that were assigned to this peer to reassign queue.</remarks>
            <param name="peerId">Unique peer identifier.</param>
        </member>
        <member name="M:Blockcore.BlockPulling.IBlockPuller.RequestBlocksDownload(System.Collections.Generic.List{Blockcore.Consensus.Chain.ChainedHeader},System.Boolean)">
            <summary>Requests the blocks for download.</summary>
            <remarks>Doesn't support asking for the same hash twice before getting a response.</remarks>
            <param name="headers">Collection of consecutive headers (but gaps are ok: a1=a2=a3=a4=a8=a9).</param>
            <param name="highPriority">If <c>true</c> headers will be assigned to peers before the headers that were asked normally.</param>
        </member>
        <member name="M:Blockcore.BlockPulling.IBlockPuller.PushBlock(Blockcore.NBitcoin.uint256,Blockcore.Consensus.BlockInfo.Block,System.Int32)">
            <summary>Removes assignments for the block which has been delivered by the peer assigned to it and calls the callback.</summary>
            <remarks>
            This method is called for all blocks that were delivered. It is possible that block that wasn't requested
            from that peer or from any peer at all is delivered, in that case the block will be ignored.
            It is possible that block was reassigned from a peer who delivered it later, in that case it will be ignored from this peer.
            </remarks>
            <param name="blockHash">The block hash.</param>
            <param name="block">The block.</param>
            <param name="peerId">ID of a peer that delivered a block.</param>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPuller.StallingLoopIntervalMs">
            <summary>Interval between checking if peers that were assigned important blocks didn't deliver the block.</summary>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPuller.MinEmptySlotsPercentageToStartProcessingTheQueue">
            <summary>The minimum empty slots percentage to start processing <see cref="F:Blockcore.BlockPulling.BlockPuller.downloadJobsQueue"/>.</summary>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPuller.ImportantHeightMargin">
            <summary>
            Defines which blocks are considered to be important.
            If requested block height is less than out consensus tip height plus this value then the block is considered to be important.
            </summary>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPuller.MaxSecondsToDeliverBlock">
            <summary>The maximum time in seconds in which peer should deliver an assigned block.</summary>
            <remarks>If peer fails to deliver in that time his assignments will be released and the peer penalized.</remarks>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPuller.PeerSpeedLimitWhenNotInIbdBytesPerSec">
            <summary>This affects quality score only. If the peer is too fast don't give him all the assignments in the world when not in IBD.</summary>
        </member>
        <member name="T:Blockcore.BlockPulling.BlockPuller.OnBlockDownloadedCallback">
            <param name="blockHash">Hash of the delivered block.</param>
            <param name="block">The block.</param>
            <param name="peerId">The ID of a peer that delivered the block.</param>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPuller.onDownloadedCallback">
            <summary>Callback which is called when puller received a block which it was asked for.</summary>
            <remarks>Provided by the component that creates the block puller.</remarks>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPuller.reassignedJobsQueue">
            <summary>Queue of download jobs which were released from the peers that failed to deliver in time or were disconnected.</summary>
            <remarks>This object has to be protected by <see cref="F:Blockcore.BlockPulling.BlockPuller.queueLock"/>.</remarks>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPuller.downloadJobsQueue">
            <summary>Queue of download jobs which should be assigned to peers.</summary>
            <remarks>This object has to be protected by <see cref="F:Blockcore.BlockPulling.BlockPuller.queueLock"/>.</remarks>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPuller.assignedDownloadsByHash">
            <summary>Collection of all download assignments to the peers sorted by block height.</summary>
            <remarks>This object has to be protected by <see cref="F:Blockcore.BlockPulling.BlockPuller.assignedLock"/>.</remarks>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPuller.assignedDownloadsSorted">
            <summary>Assigned downloads sorted by block height.</summary>
            <remarks>This object has to be protected by <see cref="F:Blockcore.BlockPulling.BlockPuller.assignedLock"/>.</remarks>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPuller.assignedHeadersByPeerId">
            <summary>Assigned headers mapped by peer ID.</summary>
            <remarks>This object has to be protected by <see cref="F:Blockcore.BlockPulling.BlockPuller.assignedLock"/>.</remarks>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPuller.pullerBehaviorsByPeerId">
            <summary>Block puller behaviors mapped by peer ID.</summary>
            <remarks>This object has to be protected by <see cref="F:Blockcore.BlockPulling.BlockPuller.peerLock"/>.</remarks>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPuller.cancellationSource">
            <summary>The cancellation source that indicates that component's shutdown was triggered.</summary>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPuller.averageBlockSizeBytes">
            <summary>The average block size in bytes calculated used up to <see cref="F:Blockcore.BlockPulling.BlockPuller.AverageBlockSizeSamplesCount"/> most recent samples.</summary>
            <remarks>Write access to this object has to be protected by <see cref="F:Blockcore.BlockPulling.BlockPuller.queueLock" />.</remarks>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPuller.AverageBlockSizeSamplesCount">
            <summary>Amount of samples that should be used for average block size calculation.</summary>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPuller.MinimalCountOfBlocksBeingDownloaded">
            <summary>The minimal count of blocks that we can ask for simultaneous download.</summary>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPuller.MaxBlocksBeingDownloadedMultiplier">
            <summary>The maximum blocks being downloaded multiplier. Value of <c>1.1</c> means that we will ask for 10% more than we estimated peers can deliver.</summary>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPuller.processQueuesSignal">
            <summary>Signaler that triggers <see cref="F:Blockcore.BlockPulling.BlockPuller.reassignedJobsQueue"/> and <see cref="F:Blockcore.BlockPulling.BlockPuller.downloadJobsQueue"/> processing when set.</summary>
            <remarks>This object has to be protected by <see cref="F:Blockcore.BlockPulling.BlockPuller.queueLock"/>.</remarks>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPuller.nextJobId">
            <summary>Unique identifier which will be set to the next created download job.</summary>
            <remarks>This object has to be protected by <see cref="F:Blockcore.BlockPulling.BlockPuller.queueLock"/>.</remarks>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPuller.peerLock">
            <summary>Locks access to <see cref="F:Blockcore.BlockPulling.BlockPuller.pullerBehaviorsByPeerId"/> and <see cref="F:Blockcore.BlockPulling.BlockPuller.networkPeerRequirement"/>.</summary>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPuller.queueLock">
            <summary>
            Locks access to <see cref="F:Blockcore.BlockPulling.BlockPuller.processQueuesSignal"/>, <see cref="F:Blockcore.BlockPulling.BlockPuller.downloadJobsQueue"/>, <see cref="F:Blockcore.BlockPulling.BlockPuller.reassignedJobsQueue"/>,
            <see cref="F:Blockcore.BlockPulling.BlockPuller.maxBlocksBeingDownloaded"/>, <see cref="F:Blockcore.BlockPulling.BlockPuller.nextJobId"/>, <see cref="F:Blockcore.BlockPulling.BlockPuller.averageBlockSizeBytes"/>.
            </summary>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPuller.assignedLock">
            <summary>Locks access to <see cref="F:Blockcore.BlockPulling.BlockPuller.assignedDownloadsByHash"/>, <see cref="F:Blockcore.BlockPulling.BlockPuller.assignedHeadersByPeerId"/>, <see cref="F:Blockcore.BlockPulling.BlockPuller.assignedDownloadsSorted"/>.</summary>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPuller.maxBlocksBeingDownloaded">
            <summary>
            The maximum blocks that can be downloaded simultaneously.
            Given that all peers are on the same chain they will deliver that amount of blocks in 1 seconds.
            </summary>
            <remarks>This object has to be protected by <see cref="F:Blockcore.BlockPulling.BlockPuller.queueLock"/>.</remarks>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPuller.isIbd">
            <summary><c>true</c> if node is in IBD.</summary>
            <remarks>This object has to be protected by <see cref="F:Blockcore.BlockPulling.BlockPuller.peerLock"/>.</remarks>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPuller.logger">
            <inheritdoc cref="T:Microsoft.Extensions.Logging.ILogger"/>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPuller.chainState">
            <inheritdoc cref="T:Blockcore.Base.IChainState"/>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPuller.networkPeerRequirement">
            <inheritdoc cref="T:Blockcore.P2P.Peer.NetworkPeerRequirement"/>
            <remarks>This object has to be protected by <see cref="F:Blockcore.BlockPulling.BlockPuller.peerLock"/>.</remarks>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPuller.dateTimeProvider">
            <inheritdoc cref="T:Blockcore.Utilities.IDateTimeProvider"/>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPuller.random">
            <inheritdoc cref="T:System.Random"/>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPuller.assignerLoop">
            <summary>Loop that assigns download jobs to the peers.</summary>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPuller.stallingLoop">
            <summary>Loop that checks if peers failed to deliver important blocks in given time and penalizes them if they did.</summary>
        </member>
        <member name="M:Blockcore.BlockPulling.BlockPuller.Initialize(Blockcore.BlockPulling.BlockPuller.OnBlockDownloadedCallback)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.BlockPulling.BlockPuller.RequestPeerServices(Blockcore.P2P.Protocol.Payloads.NetworkPeerServices)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.BlockPulling.BlockPuller.GetAverageBlockSizeBytes">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.BlockPulling.BlockPuller.OnIbdStateChanged(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.BlockPulling.BlockPuller.NewPeerTipClaimed(Blockcore.P2P.Peer.INetworkPeer,Blockcore.Consensus.Chain.ChainedHeader)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.BlockPulling.BlockPuller.PeerDisconnected(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.BlockPulling.BlockPuller.RequestBlocksDownload(System.Collections.Generic.List{Blockcore.Consensus.Chain.ChainedHeader},System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.BlockPulling.BlockPuller.AssignerLoopAsync">
            <summary>Loop that assigns download jobs to the peers.</summary>
        </member>
        <member name="M:Blockcore.BlockPulling.BlockPuller.StallingLoopAsync">
            <summary>Loop that continuously checks if peers failed to deliver important blocks in given time and penalizes them if they did.</summary>
        </member>
        <member name="M:Blockcore.BlockPulling.BlockPuller.AssignDownloadJobsAsync">
            <summary>Assigns downloads from <see cref="F:Blockcore.BlockPulling.BlockPuller.reassignedJobsQueue"/> and <see cref="F:Blockcore.BlockPulling.BlockPuller.downloadJobsQueue"/> to the peers that are capable of delivering blocks.</summary>
        </member>
        <member name="M:Blockcore.BlockPulling.BlockPuller.ProcessQueueLocked(System.Collections.Generic.Queue{Blockcore.BlockPulling.DownloadJob},System.Collections.Generic.List{Blockcore.BlockPulling.AssignedDownload},System.Collections.Generic.List{Blockcore.NBitcoin.uint256},System.Int32)">
            <summary>Processes specified queue of download jobs.</summary>
            <param name="jobsQueue">Queue of download jobs to be processed.</param>
            <param name="newAssignments">Collection of new assignments to be populated.</param>
            <param name="failedHashes">List of failed hashes to be populated if some of jobs hashes can't be assigned to any peer.</param>
            <param name="emptySlots">Max number of assignments that can be made.</param>
            <remarks>Have to be locked by <see cref="F:Blockcore.BlockPulling.BlockPuller.queueLock"/>.</remarks>
        </member>
        <member name="M:Blockcore.BlockPulling.BlockPuller.AddAssignedDownloadLocked(Blockcore.BlockPulling.AssignedDownload)">
            <summary>
            Adds assigned download to <see cref="F:Blockcore.BlockPulling.BlockPuller.assignedDownloadsByHash"/> and helper structures <see cref="F:Blockcore.BlockPulling.BlockPuller.assignedDownloadsSorted"/> and <see cref="F:Blockcore.BlockPulling.BlockPuller.assignedHeadersByPeerId"/>.
            </summary>
            <remarks>Have to be locked by <see cref="F:Blockcore.BlockPulling.BlockPuller.assignedLock"/>.</remarks>
            <param name="assignment">The assignment.</param>
        </member>
        <member name="M:Blockcore.BlockPulling.BlockPuller.RemoveAssignedDownloadLocked(Blockcore.BlockPulling.AssignedDownload)">
            <summary>
            Removes assigned download from <see cref="F:Blockcore.BlockPulling.BlockPuller.assignedDownloadsByHash"/> and helper structures <see cref="F:Blockcore.BlockPulling.BlockPuller.assignedDownloadsSorted"/> and <see cref="F:Blockcore.BlockPulling.BlockPuller.assignedHeadersByPeerId"/>.
            </summary>
            <remarks>Have to be locked by <see cref="F:Blockcore.BlockPulling.BlockPuller.assignedLock"/>.</remarks>
            <param name="assignment">Assignment that should be removed.</param>
        </member>
        <member name="M:Blockcore.BlockPulling.BlockPuller.AskPeersForBlocksAsync(System.Collections.Generic.List{Blockcore.BlockPulling.AssignedDownload})">
            <summary>Asks peer behaviors in parallel to deliver blocks.</summary>
            <param name="assignments">Assignments given to peers.</param>
        </member>
        <member name="M:Blockcore.BlockPulling.BlockPuller.DistributeHeadersLocked(Blockcore.BlockPulling.DownloadJob,System.Collections.Generic.List{Blockcore.NBitcoin.uint256},System.Int32)">
            <summary>Distributes download job's headers to peers that can provide blocks represented by those headers.</summary>
            <remarks>
            If some of the blocks from the job can't be provided by any peer those headers will be added to a <param name="failedHashes"></param>.
            <para>
            Have to be locked by <see cref="F:Blockcore.BlockPulling.BlockPuller.queueLock"/>.
            </para>
            <para>
            Node's quality score is being considered as a weight during the random distribution of the hashes to download among the nodes.
            </para>
            </remarks>
            <param name="downloadJob">Download job to be partially of fully consumed.</param>
            <param name="failedHashes">List of failed hashes which will be extended in case there is no peer to claim required hash.</param>
            <param name="emptySlots">Number of empty slots. This is the maximum number of assignments that can be created.</param>
            <returns>List of downloads that were distributed between the peers.</returns>
        </member>
        <member name="M:Blockcore.BlockPulling.BlockPuller.CheckStalling">
            <summary>Checks if peers failed to deliver important blocks and penalizes them if they did.</summary>
        </member>
        <member name="M:Blockcore.BlockPulling.BlockPuller.PushBlock(Blockcore.NBitcoin.uint256,Blockcore.Consensus.BlockInfo.Block,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.BlockPulling.BlockPuller.RecalculateQualityScoreLocked(Blockcore.BlockPulling.IBlockPullerBehavior,System.Int32)">
            <summary>Recalculates quality score of a peer or all peers if given peer has the best upload speed.</summary>
            <remarks>This method has to be protected by <see cref="F:Blockcore.BlockPulling.BlockPuller.peerLock"/>.</remarks>
            <param name="pullerBehavior">The puller behavior of a peer which quality score should be recalculated.</param>
            <param name="peerId">ID of a peer which behavior is passed.</param>
        </member>
        <member name="M:Blockcore.BlockPulling.BlockPuller.RecalculateMaxBlocksBeingDownloadedLocked">
            <summary>
            Recalculates the maximum number of blocks that can be simultaneously downloaded based
            on the average blocks size and the total speed of all peers that can deliver blocks.
            </summary>
            <remarks>This object has to be protected by <see cref="F:Blockcore.BlockPulling.BlockPuller.queueLock" />.</remarks>
        </member>
        <member name="M:Blockcore.BlockPulling.BlockPuller.ReleaseAndReassignAssignments(System.Int32)">
            <summary>
            Finds all blocks assigned to a given peer, removes assignments from <see cref="F:Blockcore.BlockPulling.BlockPuller.assignedDownloadsByHash"/>,
            adds to <see cref="F:Blockcore.BlockPulling.BlockPuller.reassignedJobsQueue"/> and signals the <see cref="F:Blockcore.BlockPulling.BlockPuller.processQueuesSignal"/>.
            </summary>
            <param name="peerId">The peer identifier.</param>
        </member>
        <member name="M:Blockcore.BlockPulling.BlockPuller.ReleaseAssignmentsLocked(System.Int32)">
            <summary>Finds all blocks assigned to a given peer, removes assignments from <see cref="F:Blockcore.BlockPulling.BlockPuller.assignedDownloadsByHash"/> and returns removed assignments.</summary>
            <remarks>Have to be locked by <see cref="F:Blockcore.BlockPulling.BlockPuller.assignedLock"/>.</remarks>
        </member>
        <member name="M:Blockcore.BlockPulling.BlockPuller.ReassignAssignmentsLocked(System.Collections.Generic.Dictionary{System.Int32,System.Collections.Generic.List{Blockcore.Consensus.Chain.ChainedHeader}})">
            <summary>Adds items from <paramref name="headersByJobId"/> to the <see cref="F:Blockcore.BlockPulling.BlockPuller.reassignedJobsQueue"/>.</summary>
            <param name="headersByJobId">Block headers mapped by job IDs.</param>
            <remarks>Have to be locked by <see cref="F:Blockcore.BlockPulling.BlockPuller.queueLock"/>.</remarks>
        </member>
        <member name="M:Blockcore.BlockPulling.BlockPuller.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.BlockPulling.IBlockPullerBehavior">
            <summary>
            Relation of the node's puller to a network peer node.
            Keeps all peer-related values that <see cref="T:Blockcore.BlockPulling.BlockPuller"/> needs to know about a peer.
            </summary>
            <remarks>The component is not thread safe and it is supposed to be protected by the caller.</remarks>
        </member>
        <member name="P:Blockcore.BlockPulling.IBlockPullerBehavior.QualityScore">
            <summary>Relative quality score of a peer.</summary>
            <remarks>It's a value from <see cref="F:Blockcore.BlockPulling.BlockPullerBehavior.MinQualityScore"/> to <see cref="F:Blockcore.BlockPulling.BlockPullerBehavior.MaxQualityScore"/>.</remarks>
        </member>
        <member name="P:Blockcore.BlockPulling.IBlockPullerBehavior.SpeedBytesPerSecond">
            <summary>Upload speed of a peer in bytes per second.</summary>
        </member>
        <member name="P:Blockcore.BlockPulling.IBlockPullerBehavior.Tip">
            <summary>Tip claimed by peer.</summary>
        </member>
        <member name="M:Blockcore.BlockPulling.IBlockPullerBehavior.AddSample(System.Int64,System.Double)">
            <summary>
            Adds peer performance sample that is used to estimate peer's qualities.
            </summary>
            <param name="blockSizeBytes">Block size in bytes.</param>
            <param name="delaySinceRequestedSeconds">Time in seconds it took peer to deliver a block since it was requested.</param>
        </member>
        <member name="M:Blockcore.BlockPulling.IBlockPullerBehavior.Penalize(System.Double,System.Int32)">
            <summary>Applies a penalty to a peer for not delivering a block.</summary>
            <param name="delaySeconds">Time in which peer didn't deliver assigned blocks.</param>
            <param name="notDeliveredBlocksCount">Number of blocks peer failed to deliver.</param>
        </member>
        <member name="M:Blockcore.BlockPulling.IBlockPullerBehavior.OnIbdStateChanged(System.Boolean)">
            <summary>Called when IBD state changed.</summary>
        </member>
        <member name="M:Blockcore.BlockPulling.IBlockPullerBehavior.RecalculateQualityScore(System.Int64)">
            <summary>Recalculates the quality score for this peer.</summary>
            <param name="bestSpeedBytesPerSecond">Speed in bytes per second that is considered to be the maximum speed.</param>
        </member>
        <member name="M:Blockcore.BlockPulling.IBlockPullerBehavior.RequestBlocksAsync(System.Collections.Generic.List{Blockcore.NBitcoin.uint256})">
            <summary>Requests blocks from this peer.</summary>
            <param name="hashes">Hashes of blocks that should be asked to be delivered.</param>
            <exception cref="T:System.OperationCanceledException">Thrown in case peer is in the wrong state or TCP connection was closed during sending a message.</exception>
        </member>
        <member name="T:Blockcore.BlockPulling.BlockPullerBehavior">
            <inheritdoc cref="T:Blockcore.BlockPulling.IBlockPullerBehavior"/>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPullerBehavior.SamplelessQualityScore">
            <summary>Default quality score used when there are no samples to calculate the quality score.</summary>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPullerBehavior.IbdSamplesCount">
            <summary>Maximum number of samples that can be used for quality score calculation when node is in IBD.</summary>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPullerBehavior.NormalSamplesCount">
            <summary>Maximum number of samples that can be used for quality score calculation when node is not in IBD.</summary>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPullerBehavior.MaxSamplesPercentageToPenalize">
            <summary>The maximum percentage of samples that can be used when peer is being penalized for not delivering blocks.</summary>
            <remarks><c>1</c> is 100%, <c>0</c> is 0%.</remarks>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPullerBehavior.MaxSpeedBytesPerSecond">
            <summary>Limitation on the peer speed estimation.</summary>
        </member>
        <member name="P:Blockcore.BlockPulling.BlockPullerBehavior.QualityScore">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.BlockPulling.BlockPullerBehavior.SpeedBytesPerSecond">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.BlockPulling.BlockPullerBehavior.Tip">
            <inheritdoc />
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPullerBehavior.averageSizeBytes">
            <summary>The average size in bytes of blocks delivered by that peer.</summary>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPullerBehavior.averageDelaySeconds">
            <summary>The average delay in seconds between asking this peer for a block and it being downloaded.</summary>
        </member>
        <member name="F:Blockcore.BlockPulling.BlockPullerBehavior.lastDeliveryTime">
            <summary>Time when the last block was delivered.</summary>
        </member>
        <member name="M:Blockcore.BlockPulling.BlockPullerBehavior.AddSample(System.Int64,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.BlockPulling.BlockPullerBehavior.Penalize(System.Double,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.BlockPulling.BlockPullerBehavior.OnIbdStateChanged(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.BlockPulling.BlockPullerBehavior.RecalculateQualityScore(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.BlockPulling.BlockPullerBehavior.RequestBlocksAsync(System.Collections.Generic.List{Blockcore.NBitcoin.uint256})">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.BlockPulling.BlockPullerBehavior.Clone">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.BlockPulling.BlockPullerBehavior.AttachCore">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.BlockPulling.BlockPullerBehavior.DetachCore">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.BlockPulling.DownloadJob">
            <summary>Represents consecutive collection of headers that are to be downloaded.</summary>
        </member>
        <member name="F:Blockcore.BlockPulling.DownloadJob.Id">
            <summary>Unique identifier of this job.</summary>
        </member>
        <member name="F:Blockcore.BlockPulling.DownloadJob.Headers">
            <summary>Headers of blocks that are to be downloaded.</summary>
        </member>
        <member name="T:Blockcore.Builder.Feature.IFeatureCollection">
            <summary>
            Defines methods for collection of features of the FullNode.
            </summary>
        </member>
        <member name="P:Blockcore.Builder.Feature.IFeatureCollection.FeatureRegistrations">
            <summary>List of features already registered in the collection.</summary>
        </member>
        <member name="M:Blockcore.Builder.Feature.IFeatureCollection.AddFeature``1">
            <summary>Adds a new feature to the collection provided that the feature of the same type has not been added already.</summary>
            <typeparam name="TImplementation">Type of the feature to be added to the collection.</typeparam>
            <returns>Representation of the registered feature.</returns>
        </member>
        <member name="T:Blockcore.Builder.Feature.FeatureCollection">
            <summary>
            Collection of features available to and/or used by the FullNode.
            </summary>
        </member>
        <member name="F:Blockcore.Builder.Feature.FeatureCollection.featureRegistrations">
            <summary>List of features already registered in the collection.</summary>
        </member>
        <member name="M:Blockcore.Builder.Feature.FeatureCollection.#ctor">
            <summary>Initializes the object instance.</summary>
        </member>
        <member name="P:Blockcore.Builder.Feature.FeatureCollection.FeatureRegistrations">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Builder.Feature.FeatureCollection.AddFeature``1">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Builder.Feature.IFeatureRegistration">
            <summary>
            Defines methods for a representation of registered features of the FullNode.
            </summary>
        </member>
        <member name="P:Blockcore.Builder.Feature.IFeatureRegistration.FeatureStartupType">
            <summary>
            Type of the feature startup class. If it implements ConfigureServices method,
            it is invoked to configure the feature's services.
            </summary>
        </member>
        <member name="P:Blockcore.Builder.Feature.IFeatureRegistration.FeatureType">
            <summary>Type of the feature class.</summary>
        </member>
        <member name="M:Blockcore.Builder.Feature.IFeatureRegistration.BuildFeature(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
            <summary>
            Initializes feature registration DI services and calls configuration delegates of each service
            and the startup type.
            </summary>
            <param name="serviceCollection">Collection of feature registration's DI services.</param>
        </member>
        <member name="M:Blockcore.Builder.Feature.IFeatureRegistration.FeatureServices(System.Action{Microsoft.Extensions.DependencyInjection.IServiceCollection})">
            <summary>
            Initializes the list of delegates to configure DI services of the feature registration.
            </summary>
            <param name="configureServices">List of delegates to configure DI services of the feature registration.</param>
            <returns>This interface to allow fluent code.</returns>
        </member>
        <member name="M:Blockcore.Builder.Feature.IFeatureRegistration.UseStartup``1">
            <summary>
            Sets the specific startup type to be used by the feature registration.
            </summary>
            <typeparam name="TStartup">Type of feature startup class to use.</typeparam>
            <returns>This interface to allow fluent code.</returns>
        </member>
        <member name="M:Blockcore.Builder.Feature.IFeatureRegistration.DependOn``1">
            <summary>
            Adds a feature type to the dependency feature list.
            </summary>
            <typeparam name="TImplementation">Type of the registered feature class.</typeparam>
            <returns>This interface to allow fluent code.</returns>
        </member>
        <member name="M:Blockcore.Builder.Feature.IFeatureRegistration.EnsureDependencies(System.Collections.Generic.List{Blockcore.Builder.Feature.IFeatureRegistration})">
            <summary>
            Ensures dependency feature types are present in the registered features list.
            </summary>
            <param name="featureRegistrations">List of registered features.</param>
            <exception cref="T:Blockcore.Builder.Feature.MissingDependencyException">Thrown if feature type is missing.</exception>
        </member>
        <member name="T:Blockcore.Builder.Feature.FeatureRegistration`1">
            <summary>
            Default implementation of a representation of a registered feature of the FullNode.
            </summary>
            <typeparam name="TImplementation">Type of the registered feature class.</typeparam>
        </member>
        <member name="P:Blockcore.Builder.Feature.FeatureRegistration`1.ConfigureServicesDelegates">
            <summary>List of delegates to configure services of the feature.</summary>
        </member>
        <member name="M:Blockcore.Builder.Feature.FeatureRegistration`1.#ctor">
            <summary>Initializes the instance of the object.</summary>
        </member>
        <member name="P:Blockcore.Builder.Feature.FeatureRegistration`1.FeatureStartupType">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Builder.Feature.FeatureRegistration`1.FeatureType">
            <inheritdoc />
        </member>
        <member name="F:Blockcore.Builder.Feature.FeatureRegistration`1.dependencies">
            <summary> List of dependency features that should be registered in order to add this feature.</summary>
        </member>
        <member name="M:Blockcore.Builder.Feature.FeatureRegistration`1.BuildFeature(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Builder.Feature.FeatureRegistration`1.FeatureServices(System.Action{Microsoft.Extensions.DependencyInjection.IServiceCollection})">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Builder.Feature.FeatureRegistration`1.UseStartup``1">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Builder.Feature.FeatureRegistration`1.DependOn``1">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Builder.Feature.FeatureRegistration`1.EnsureDependencies(System.Collections.Generic.List{Blockcore.Builder.Feature.IFeatureRegistration})">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Builder.Feature.FeatureRegistration`1.FeatureStartup(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type)">
            <summary>
            A feature can use specified method to configure its services.
            The specified method needs to have the following signature to be invoked:
            <c>void ConfigureServices(IServiceCollection serviceCollection)</c>.
            </summary>
            <param name="serviceCollection">Collection of service descriptors to be passed to the ConfigureServices method of the feature registration startup class.</param>
            <param name="startupType">Type of the feature registration startup class. If it implements ConfigureServices method, it is invoked to configure the feature's services.</param>
        </member>
        <member name="T:Blockcore.Builder.Feature.FeaturesExtensions">
            <summary>
            Extensions to features collection.
            </summary>
        </member>
        <member name="M:Blockcore.Builder.Feature.FeaturesExtensions.EnsureFeature``1(System.Collections.Generic.IEnumerable{Blockcore.Builder.Feature.IFullNodeFeature})">
            <summary>
            Ensures a dependency feature type is present in the feature list.
            </summary>
            <typeparam name="T">The dependency feature type.</typeparam>
            <param name="features">List of features.</param>
            <returns>List of features.</returns>
            <exception cref="T:Blockcore.Builder.Feature.MissingDependencyException">Thrown if feature type is missing.</exception>
        </member>
        <member name="T:Blockcore.Builder.Feature.IFullNodeFeature">
            <summary>
            Defines methods for features that are managed by the FullNode.
            </summary>
        </member>
        <member name="P:Blockcore.Builder.Feature.IFullNodeFeature.InitializeBeforeBase">
            <summary>
            Instructs the <see cref="T:Blockcore.Builder.FullNodeFeatureExecutor"/> to start this feature before the <see cref="T:Blockcore.Base.BaseFeature"/>.
            </summary>
        </member>
        <member name="P:Blockcore.Builder.Feature.IFullNodeFeature.State">
            <summary>
            The state in which the feature currently is.
            </summary>
        </member>
        <member name="M:Blockcore.Builder.Feature.IFullNodeFeature.InitializeAsync">
            <summary>
            Triggered when the FullNode host has fully started.
            </summary>
        </member>
        <member name="M:Blockcore.Builder.Feature.IFullNodeFeature.ValidateDependencies(Blockcore.Builder.IFullNodeServiceProvider)">
            <summary>
            Validates the feature's required dependencies are all present.
            </summary>
            <exception cref="T:Blockcore.Builder.Feature.MissingDependencyException">should be thrown if dependency is missing</exception>
            <param name="services">Services and features registered to node.</param>
        </member>
        <member name="T:Blockcore.Builder.Feature.FullNodeFeature">
            <summary>
            A feature is used to extend functionality into the full node.
            It can manage its life time or use the full node disposable resources.
            <para>
            If a feature adds an option of a certain functionality to be available to be used by the node
            (it may be disabled/enabled by the configuration) the naming convention is
            <c>Add[Feature]()</c>. Conversely, when a feature is inclined to be used if included,
            the naming convention should be <c>Use[Feature]()</c>.
            </para>
            </summary>
        </member>
        <member name="P:Blockcore.Builder.Feature.FullNodeFeature.InitializeBeforeBase">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Builder.Feature.FullNodeFeature.State">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Builder.Feature.FullNodeFeature.InitializeAsync">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Builder.Feature.FullNodeFeature.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Builder.Feature.FullNodeFeature.ValidateDependencies(Blockcore.Builder.IFullNodeServiceProvider)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Builder.Feature.MissingDependencyException">
            <summary>
            Exception thrown when feature dependencies are missing.
            </summary>
        </member>
        <member name="M:Blockcore.Builder.Feature.MissingDependencyException.#ctor">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Builder.Feature.MissingDependencyException.#ctor(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Builder.Feature.MissingDependencyException.#ctor(System.String,System.Exception)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Builder.Feature.MissingServiceException">
            <summary>
            Exception thrown when a required service has not been registered into <see cref="T:Blockcore.Builder.IFullNodeServiceProvider"/>.
            </summary>
        </member>
        <member name="P:Blockcore.Builder.Feature.MissingServiceException.MissingServiceType">
            <summary>
            The Type of the missing service.
            </summary>
        </member>
        <member name="M:Blockcore.Builder.Feature.MissingServiceException.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Blockcore.Builder.Feature.MissingDependencyException"/> class.
            </summary>
            <param name="missingServiceType">Type of the missing service.</param>
        </member>
        <member name="M:Blockcore.Builder.Feature.MissingServiceException.#ctor(System.Type,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Blockcore.Builder.Feature.MissingDependencyException"/> class.
            </summary>
            <param name="missingServiceType">Type of the missing service.</param>
            <param name="message">The message.</param>
        </member>
        <member name="M:Blockcore.Builder.Feature.MissingServiceException.#ctor(System.Type,System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Blockcore.Builder.Feature.MissingDependencyException"/> class.
            </summary>
            <param name="missingServiceType">Type of the missing service.</param>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="T:Blockcore.Builder.NodeBuilderException">
            <summary>
            Exception thrown by FullNodeBuilder.Build.
            </summary>
            <seealso cref="M:Blockcore.Builder.FullNodeBuilder.Build"/>
        </member>
        <member name="M:Blockcore.Builder.NodeBuilderException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the class with a specified error message.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="T:Blockcore.Builder.FullNodeBuilder">
            <summary>
            Full node builder allows constructing a full node using specific components.
            </summary>
        </member>
        <member name="F:Blockcore.Builder.FullNodeBuilder.configureDelegates">
            <summary>List of delegates that configure the service providers.</summary>
        </member>
        <member name="F:Blockcore.Builder.FullNodeBuilder.configureServicesDelegates">
            <summary>List of delegates that add services to the builder.</summary>
        </member>
        <member name="F:Blockcore.Builder.FullNodeBuilder.featuresRegistrationDelegates">
            <summary>List of delegates that add features to the collection.</summary>
        </member>
        <member name="F:Blockcore.Builder.FullNodeBuilder.fullNodeBuilt">
            <summary>true if the Build method has been called already (whether it succeeded or not), false otherwise.</summary>
        </member>
        <member name="P:Blockcore.Builder.FullNodeBuilder.Features">
            <summary>Collection of features available to and/or used by the node.</summary>
        </member>
        <member name="P:Blockcore.Builder.FullNodeBuilder.NodeSettings">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Builder.FullNodeBuilder.PersistenceProviderManager">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Builder.FullNodeBuilder.Network">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Builder.FullNodeBuilder.Services">
            <summary>Collection of DI services.</summary>
        </member>
        <member name="M:Blockcore.Builder.FullNodeBuilder.#ctor">
            <summary>
            Initializes a default instance of the object and registers required services.
            </summary>
        </member>
        <member name="M:Blockcore.Builder.FullNodeBuilder.#ctor(Blockcore.Configuration.NodeSettings,Blockcore.Persistence.IPersistenceProviderManager)">
            <summary>
            Initializes an instance of the object using specific NodeSettings instance and registers required services.
            </summary>
            <param name="nodeSettings">User defined node settings.</param>
            <param name="persistenceProviderManager">Persistence Provider Manager that will help registering needed persistence services.</param>
        </member>
        <member name="M:Blockcore.Builder.FullNodeBuilder.#ctor(Blockcore.Configuration.NodeSettings,System.Collections.Generic.List{System.Action{Microsoft.Extensions.DependencyInjection.IServiceCollection}},System.Collections.Generic.List{System.Action{System.IServiceProvider}},System.Collections.Generic.List{System.Action{Blockcore.Builder.Feature.IFeatureCollection}},Blockcore.Builder.Feature.IFeatureCollection,Blockcore.Persistence.IPersistenceProviderManager)">
            <summary>
            Initializes an instance of the object using specific NodeSettings instance and configuration delegates and registers required services.
            </summary>
            <param name="nodeSettings">User defined node settings.</param>
            <param name="configureServicesDelegates">List of delegates that add services to the builder.</param>
            <param name="configureDelegates">List of delegates that configure the service providers.</param>
            <param name="featuresRegistrationDelegates">List of delegates that add features to the collection.</param>
            <param name="features">Collection of features to be available to and/or used by the node.</param>
            <param name="persistenceProviderManager">Persistence Provider Manager that will help registering needed persistence services.</param>
        </member>
        <member name="M:Blockcore.Builder.FullNodeBuilder.#ctor(System.Collections.Generic.List{System.Action{Microsoft.Extensions.DependencyInjection.IServiceCollection}},System.Collections.Generic.List{System.Action{System.IServiceProvider}},System.Collections.Generic.List{System.Action{Blockcore.Builder.Feature.IFeatureCollection}},Blockcore.Builder.Feature.IFeatureCollection,Blockcore.Persistence.IPersistenceProviderManager)">
            <summary>
            Initializes an instance of the object using specific configuration delegates.
            </summary>
            <param name="configureServicesDelegates">List of delegates that add services to the builder.</param>
            <param name="configureDelegates">List of delegates that configure the service providers.</param>
            <param name="featuresRegistrationDelegates">List of delegates that add features to the collection.</param>
            <param name="features">Collection of features to be available to and/or used by the node.</param>
            <param name="persistenceProviderManager">Persistence Provider Manager that will help registering needed persistence services.</param>
        </member>
        <member name="M:Blockcore.Builder.FullNodeBuilder.ConfigureFeature(System.Action{Blockcore.Builder.Feature.IFeatureCollection})">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Builder.FullNodeBuilder.ConfigureServices(System.Action{Microsoft.Extensions.DependencyInjection.IServiceCollection})">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Builder.FullNodeBuilder.ConfigureServiceProvider(System.Action{System.IServiceProvider})">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Builder.FullNodeBuilder.Build">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Builder.FullNodeBuilder.BuildServices">
            <summary>
            Constructs and configures services ands features to be used by the node.
            </summary>
            <returns>Collection of registered services.</returns>
        </member>
        <member name="M:Blockcore.Builder.FullNodeBuilder.ConfigureServices(System.IServiceProvider)">
            <summary>
            Configure registered services.
            </summary>
            <param name="serviceProvider"></param>
        </member>
        <member name="T:Blockcore.Builder.FullNodeBuilderIPersistenceProviderManagerExtension">
            <summary>
            A class providing extension methods for <see cref="T:Blockcore.Builder.IFullNodeBuilder"/>.
            </summary>
        </member>
        <member name="M:Blockcore.Builder.FullNodeBuilderIPersistenceProviderManagerExtension.UsePersistenceProviderMananger(Blockcore.Builder.IFullNodeBuilder,Blockcore.Persistence.IPersistenceProviderManager)">
            <summary>
            Makes the full node builder use specific node settings.
            </summary>
            <param name="builder">Full node builder to which inject persistence provider manager.</param>
            <param name="persistenceProviderManager">The persistence provider manager to use to.</param>
            <returns>Interface to allow fluent code.</returns>
        </member>
        <member name="T:Blockcore.Builder.FullNodeBuilderNodeSettingsExtension">
            <summary>
            A class providing extension methods for <see cref="T:Blockcore.Builder.IFullNodeBuilder"/>.
            </summary>
        </member>
        <member name="M:Blockcore.Builder.FullNodeBuilderNodeSettingsExtension.UseNodeSettings(Blockcore.Builder.IFullNodeBuilder,Blockcore.Configuration.NodeSettings)">
            <summary>
            Makes the full node builder use specific node settings.
            </summary>
            <param name="builder">Full node builder to change node settings for.</param>
            <param name="nodeSettings">Node settings to be used.</param>
            <returns>Interface to allow fluent code.</returns>
        </member>
        <member name="M:Blockcore.Builder.FullNodeBuilderNodeSettingsExtension.UseDefaultNodeSettings(Blockcore.Builder.IFullNodeBuilder)">
            <summary>
            Makes the full node builder use the default node settings.
            </summary>
            <param name="builder">Full node builder to change node settings for.</param>
            <returns>Interface to allow fluent code.</returns>
        </member>
        <member name="T:Blockcore.Builder.IFullNodeFeatureExecutor">
            <summary>
            Starts and stops all features registered with a full node.
            </summary>
        </member>
        <member name="M:Blockcore.Builder.IFullNodeFeatureExecutor.Initialize">
            <summary>
            Starts all registered features of the associated full node.
            </summary>
        </member>
        <member name="T:Blockcore.Builder.FullNodeFeatureExecutor">
            <summary>
            Starts and stops all features registered with a full node.
            </summary>
            <remarks>Borrowed from ASP.NET.</remarks>
        </member>
        <member name="F:Blockcore.Builder.FullNodeFeatureExecutor.node">
            <summary>Full node which features are to be managed by this executor.</summary>
        </member>
        <member name="F:Blockcore.Builder.FullNodeFeatureExecutor.logger">
            <summary>Object logger.</summary>
        </member>
        <member name="M:Blockcore.Builder.FullNodeFeatureExecutor.#ctor(Blockcore.IFullNode,Microsoft.Extensions.Logging.ILoggerFactory)">
            <summary>
            Initializes an instance of the object with specific full node and logger factory.
            </summary>
            <param name="fullNode">Full node which features are to be managed by this executor.</param>
            <param name="loggerFactory">Factory to be used to create logger for the object.</param>
        </member>
        <member name="M:Blockcore.Builder.FullNodeFeatureExecutor.Initialize">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Builder.FullNodeFeatureExecutor.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Builder.FullNodeFeatureExecutor.Execute(System.Action{Blockcore.Builder.Feature.IFullNodeFeature},System.Boolean)">
            <summary>
            Executes start or stop method of all the features registered with the associated full node.
            </summary>
            <param name="callback">Delegate to run start or stop method of the feature.</param>
            <param name="disposing">Reverse the order of which the features are executed.</param>
            <exception cref="T:System.AggregateException">Thrown in case one or more callbacks threw an exception.</exception>
        </member>
        <member name="T:Blockcore.Builder.IFullNodeServiceProvider">
            <summary>
            Provider of access to services and features registered with the full node.
            </summary>
        </member>
        <member name="P:Blockcore.Builder.IFullNodeServiceProvider.Features">
            <summary>List of registered features.</summary>
        </member>
        <member name="P:Blockcore.Builder.IFullNodeServiceProvider.ServiceProvider">
            <summary>Provider to registered services.</summary>
        </member>
        <member name="M:Blockcore.Builder.IFullNodeServiceProvider.IsServiceRegistered``1">
            <summary>
            Determines whether the service of the specified type T is registered.
            </summary>
            <typeparam name="T">A type to query against the service provider.</typeparam>
            <returns>
              <c>true</c> if this instance is registered; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Blockcore.Builder.IFullNodeServiceProvider.EnsureServiceIsRegistered``1">
            <summary>
            Guard method that check whether the service of the specified type T is registered.
            If it doesn't exists, thrown an exception.
            </summary>
            <typeparam name="T">A type to query against the service provider.</typeparam>
        </member>
        <member name="T:Blockcore.Builder.FullNodeServiceProvider">
            <summary>
            Provider of access to services and features registered with the full node.
            </summary>
        </member>
        <member name="F:Blockcore.Builder.FullNodeServiceProvider.featureTypes">
            <summary>List of registered feature types.</summary>
        </member>
        <member name="P:Blockcore.Builder.FullNodeServiceProvider.Features">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Builder.FullNodeServiceProvider.ServiceProvider">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Builder.FullNodeServiceProvider.#ctor(System.IServiceProvider,System.Collections.Generic.List{System.Type})">
            <summary>
            Initializes a new instance of the object with service provider and list of registered feature types.
            </summary>
            <param name="serviceProvider">Provider to registered services.</param>
            <param name="featureTypes">List of registered feature types.</param>
        </member>
        <member name="M:Blockcore.Builder.FullNodeServiceProvider.IsServiceRegistered``1">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Builder.FullNodeServiceProvider.EnsureServiceIsRegistered``1">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Builder.IFullNodeBuilder">
            <summary>
            Full node builder allows constructing a full node using specific components.
            </summary>
        </member>
        <member name="P:Blockcore.Builder.IFullNodeBuilder.NodeSettings">
            <summary>User defined node settings.</summary>
        </member>
        <member name="P:Blockcore.Builder.IFullNodeBuilder.PersistenceProviderManager">
            <summary>Allows to require implementation of the persistence layer they need.</summary>
        </member>
        <member name="P:Blockcore.Builder.IFullNodeBuilder.Network">
            <summary>Specification of the network the node runs on - regtest/testnet/mainnet.</summary>
        </member>
        <member name="P:Blockcore.Builder.IFullNodeBuilder.Services">
            <summary>Collection of DI services.</summary>
        </member>
        <member name="P:Blockcore.Builder.IFullNodeBuilder.Features">
            <summary>Collection of features</summary>
        </member>
        <member name="M:Blockcore.Builder.IFullNodeBuilder.Build">
            <summary>
            Constructs the full node with the required features, services, and settings.
            </summary>
            <returns>Initialized full node.</returns>
        </member>
        <member name="M:Blockcore.Builder.IFullNodeBuilder.ConfigureFeature(System.Action{Blockcore.Builder.Feature.IFeatureCollection})">
            <summary>
            Adds features to the builder.
            </summary>
            <param name="configureFeatures">A method that adds features to the collection.</param>
            <returns>Interface to allow fluent code.</returns>
        </member>
        <member name="M:Blockcore.Builder.IFullNodeBuilder.ConfigureServices(System.Action{Microsoft.Extensions.DependencyInjection.IServiceCollection})">
            <summary>
            Adds services to the builder.
            </summary>
            <param name="configureServices">A method that adds services to the builder.</param>
            <returns>Interface to allow fluent code.</returns>
        </member>
        <member name="M:Blockcore.Builder.IFullNodeBuilder.ConfigureServiceProvider(System.Action{System.IServiceProvider})">
            <summary>
            Add configurations for the service provider.
            </summary>
            <param name="configure">A method that configures the service provider.</param>
            <returns>Interface to allow fluent code.</returns>
        </member>
        <member name="T:Blockcore.Builder.IFullNodeBuilderServiceOverride">
            <summary>
            Allow specific network implementation to override services.
            </summary>
        </member>
        <member name="M:Blockcore.Builder.IFullNodeBuilderServiceOverride.OverrideServices(Blockcore.Builder.IFullNodeBuilder)">
            <summary>
            Intercept the builder to override services.
            </summary>
        </member>
        <member name="T:Blockcore.Configuration.DataFolder">
            <summary>
            Contains path locations to folders and files on disk.
            Used by various components of the full node.
            </summary>
            <remarks>
            Location name should describe if its a file or a folder.
            File location names end with "File" (i.e AddrMan[File]).
            Folder location names end with "Path" (i.e CoinView[Path]).
            </remarks>
        </member>
        <member name="M:Blockcore.Configuration.DataFolder.#ctor(System.String)">
            <summary>
            Initializes the path locations.
            </summary>
            <param name="path">The data directory root path.</param>
        </member>
        <member name="P:Blockcore.Configuration.DataFolder.RootPath">
            <summary>
            The DataFolder's path.
            </summary>
        </member>
        <member name="P:Blockcore.Configuration.DataFolder.AddressManagerFilePath">
            <summary>Address manager's database of peers.</summary>
            <seealso cref="!:PeerAddressManager.SavePeers(string, string)"/>
        </member>
        <member name="P:Blockcore.Configuration.DataFolder.CoindbPath">
            <summary>Path to the folder with coinview database files.</summary>
        </member>
        <member name="P:Blockcore.Configuration.DataFolder.ChainPath">
            <summary>Path to the folder with node's chain repository database files.</summary>
            <seealso cref="!:Base.BaseFeature.StartChain"/>
        </member>
        <member name="P:Blockcore.Configuration.DataFolder.KeyValueRepositoryPath">
            <summary>Path to the folder with separated key-value items managed by <see cref="T:Blockcore.Utilities.Store.IKeyValueRepository"/>.</summary>
        </member>
        <member name="P:Blockcore.Configuration.DataFolder.BlockPath">
            <summary>Path to the folder with block repository database files.</summary>
            <seealso cref="!:Features.BlockStore.BlockRepository.BlockRepository"/>
        </member>
        <member name="P:Blockcore.Configuration.DataFolder.PollsPath">
            <summary>Path to the folder with polls.</summary>
        </member>
        <member name="P:Blockcore.Configuration.DataFolder.IndexPath">
            <summary>Path to the folder with block repository database files.</summary>
            <seealso cref="!:Features.IndexStore.IndexRepository.IndexRepository"/>
        </member>
        <member name="P:Blockcore.Configuration.DataFolder.RpcCookieFile">
            <summary>File to store RPC authorization cookie.</summary>
            <seealso cref="!:Features.RPC.Startup.Configure"/>
        </member>
        <member name="P:Blockcore.Configuration.DataFolder.WalletPath">
            <summary>Path to wallet files.</summary>
            <seealso cref="!:Features.Wallet.WalletManager.LoadWallet"/>
        </member>
        <member name="P:Blockcore.Configuration.DataFolder.WalletFolderPath">
            <summary>Path to wallet folder.</summary>
        </member>
        <member name="P:Blockcore.Configuration.DataFolder.LogPath">
            <summary>Path to log files.</summary>
            <seealso cref="T:Blockcore.Configuration.Logging.LoggingConfiguration"/>
        </member>
        <member name="P:Blockcore.Configuration.DataFolder.DnsMasterFilePath">
            <summary>Path to DNS masterfile.</summary>
            <seealso cref="!:Dns.IMasterFile.Save"/>
        </member>
        <member name="P:Blockcore.Configuration.DataFolder.SmartContractStatePath">
            <summary>Path to the folder with smart contract state database files.</summary>
        </member>
        <member name="P:Blockcore.Configuration.DataFolder.ProvenBlockHeaderPath">
            <summary>Path to the folder for <see cref="T:Blockcore.Consensus.BlockInfo.ProvenBlockHeader"/> items database files.</summary>
        </member>
        <member name="P:Blockcore.Configuration.DataFolder.ApplicationsPath">
            <summary>Path to applications</summary>
        </member>
        <member name="T:Blockcore.Configuration.Logging.ExtendedLoggerFactory">
            <summary>
            An extension of the <see cref="T:Microsoft.Extensions.Logging.LoggerFactory"/> that allows access to some internal components.
            </summary>
        </member>
        <member name="P:Blockcore.Configuration.Logging.ExtendedLoggerFactory.ConsoleSettings">
            <summary>Configuration of console logger.</summary>
        </member>
        <member name="P:Blockcore.Configuration.Logging.ExtendedLoggerFactory.ConsoleLoggerProvider">
            <summary>Provider of console logger.</summary>
        </member>
        <member name="M:Blockcore.Configuration.Logging.ExtendedLoggerFactory.Create(Blockcore.Configuration.Settings.LogSettings)">
            <summary>Loads the NLog.config file from the <see cref="T:Blockcore.Configuration.DataFolder"/>, if it exists.</summary>
        </member>
        <member name="T:Blockcore.Configuration.Logging.LoggingConfiguration">
            <summary>
            Integration of NLog with Microsoft.Extensions.Logging interfaces.
            </summary>
        </member>
        <member name="F:Blockcore.Configuration.Logging.LoggingConfiguration.ColumnLength">
            <summary>Width of a column for pretty console/log outputs.</summary>
        </member>
        <member name="F:Blockcore.Configuration.Logging.LoggingConfiguration.logSettings">
            <summary>Currently used node's log settings.</summary>
        </member>
        <member name="F:Blockcore.Configuration.Logging.LoggingConfiguration.folder">
            <summary>Currently used data folder to determine path to logs.</summary>
        </member>
        <member name="F:Blockcore.Configuration.Logging.LoggingConfiguration.KeyCategories">
            <summary>Mappings of keys to class name spaces to be used when filtering log categories.</summary>
        </member>
        <member name="M:Blockcore.Configuration.Logging.LoggingConfiguration.#cctor">
            <summary>
            Initializes application logging.
            </summary>
        </member>
        <member name="M:Blockcore.Configuration.Logging.LoggingConfiguration.LoadNLogConfiguration(Microsoft.Extensions.Logging.ILoggerFactory,Blockcore.Configuration.DataFolder)">
            <summary>Loads the NLog.config file from the <see cref="T:Blockcore.Configuration.DataFolder"/>, if it exists.</summary>
        </member>
        <member name="M:Blockcore.Configuration.Logging.LoggingConfiguration.NLogConfigurationReloaded(System.Object,NLog.Config.LoggingConfigurationReloadedEventArgs)">
            <summary>
            Event handler to be called when logging <see cref="P:NLog.LogManager.Configuration"/> gets reloaded.
            </summary>
            <param name="sender">Not used.</param>
            <param name="e">Not used.</param>
        </member>
        <member name="M:Blockcore.Configuration.Logging.LoggingConfiguration.AddFilters(Blockcore.Configuration.Settings.LogSettings,Blockcore.Configuration.DataFolder)">
            <summary>
            Extends the logging rules in the "NLog.config" with node log settings rules.
            </summary>
            <param name="settings">Node log settings to extend the rules from the configuration file, or null if no extension is required.</param>
            <param name="dataFolder">Data folder to determine path to log files.</param>
        </member>
        <member name="M:Blockcore.Configuration.Logging.LoggingConfiguration.AddFilters(Microsoft.Extensions.Logging.ILoggerFactory,Blockcore.Configuration.Settings.LogSettings,Blockcore.Configuration.DataFolder)">
            <summary>
            Extends the logging rules in the "NLog.config" with node log settings rules.
            </summary>
            <param name="loggerFactory">Not used.</param>
            <param name="settings">Node log settings to extend the rules from the configuration file, or null if no extension is required.</param>
            <param name="dataFolder">Data folder to determine path to log files.</param>
        </member>
        <member name="M:Blockcore.Configuration.Logging.LoggingConfiguration.ConfigureConsoleFilters(Microsoft.Extensions.Logging.ILoggingBuilder,Blockcore.Configuration.Settings.LogSettings)">
            <summary>
            Configure the console logger and set it to filter logs not related to the fullnode.
            </summary>
            <param name="builder">Logging builder.</param>
            <param name="settings">Settings that hold potential debug arguments, if null no debug arguments will be loaded."/></param>
        </member>
        <member name="T:Blockcore.Configuration.NodeServerEndpoint">
            <summary>
            Description of network interface on which the node listens.
            </summary>
        </member>
        <member name="M:Blockcore.Configuration.NodeServerEndpoint.#ctor(System.Net.IPEndPoint,System.Boolean)">
            <summary>
            Initializes an instance of the object.
            </summary>
            <param name="endpoint">IP address and port number on which the node server listens.</param>
            <param name="whitelisted">If <c>true</c>, peers that connect to this interface are whitelisted.</param>
        </member>
        <member name="P:Blockcore.Configuration.NodeServerEndpoint.Endpoint">
            <summary>IP address and port number on which the node server listens.</summary>
        </member>
        <member name="P:Blockcore.Configuration.NodeServerEndpoint.Whitelisted">
            <summary>If <c>true</c>, peers that connect to this interface are whitelisted.</summary>
        </member>
        <member name="M:Blockcore.Configuration.NormalizeDirectorySeparatorExt.NormalizeDirectorySeparator(System.String)">
            <summary>
            Fixes incorrect directory separator characters in path (if any).
            </summary>
        </member>
        <member name="T:Blockcore.Configuration.NodeSettings">
            <summary>
            ontains the configuration settings for a Full Node. These settings are taken from both the application
            command line arguments and the configuration file.
            Unlike the settings held by <see cref="P:Blockcore.Configuration.NodeSettings.Network"/>, these settings are individualized for each Full Node.
            </summary>
        </member>
        <member name="P:Blockcore.Configuration.NodeSettings.LoggerFactory">
            <summary>A factory responsible for creating a Full Node logger instance.</summary>
        </member>
        <member name="P:Blockcore.Configuration.NodeSettings.Logger">
            <summary>An instance of the Full Node logger, which reports on the Full Node's activity.</summary>
        </member>
        <member name="P:Blockcore.Configuration.NodeSettings.Log">
            <summary>The settings of the Full Node's logger.</summary>
        </member>
        <member name="P:Blockcore.Configuration.NodeSettings.DataFolder">
            <summary>A list of paths to folders which Full Node components use to store data. These folders are found
            in the <see cref="P:Blockcore.Configuration.NodeSettings.DataDir"/>.
            </summary>
        </member>
        <member name="P:Blockcore.Configuration.NodeSettings.DataDir">
            <summary>The path to the data directory, which contains, for example, the configuration file, wallet files,
            and the file containing the peers that the Node has connected to. This value is read-only and can only be
            set via the NodeSettings constructor's arguments.
            </summary>
        </member>
        <member name="P:Blockcore.Configuration.NodeSettings.DataDirRoot">
            <summary>The path to the root data directory, which holds all node data on the machine.
            This includes separate subfolders for different nodes that run on the machine: a Stratis folder for a
            Stratis node, a Bitcoin folder for a Bitcoin node, and folders for any sidechain nodes. This value is
            read-only and can only be set via the NodeSettings constructor's arguments.
            </summary>
        </member>
        <member name="P:Blockcore.Configuration.NodeSettings.ConfigurationFile">
            <summary>The path to the Full Node's configuration file.
            This value is read-only and can only be set via the NodeSettings constructor's arguments.
            </summary>
        </member>
        <member name="P:Blockcore.Configuration.NodeSettings.ConfigReader">
            <summary>A combination of the settings from the Full Node's configuration file and the command
            line arguments supplied to the Full Node when it was run. This places the settings from both sources
            into a single object, which is referenced at runtime.
            </summary>
        </member>
        <member name="P:Blockcore.Configuration.NodeSettings.MinProtocolVersion">
            <summary>The lowest version of the protocol which the Full Node supports.</summary>
        </member>
        <member name="P:Blockcore.Configuration.NodeSettings.Network">
            <summary>The network which the node is configured to run on. The network can be a "mainnet", "testnet",
            or "regtest" network. All three network configurations can be defined, and one is selected at the command
            line (via the  <see cref="T:Blockcore.Networks.NetworksSelector"/> class) to connect to. A Full Node defaults to running on the
            mainnet.
            </summary>
        </member>
        <member name="P:Blockcore.Configuration.NodeSettings.Agent">
            <summary>A string that is used to help identify the Full Node when it connects to other peers on a network.
            Defaults to "StratisNode".
            </summary>
        </member>
        <member name="P:Blockcore.Configuration.NodeSettings.MinTxFeeRate">
            <summary>The minimum fee for a kB of transactions on the node.</summary>
        </member>
        <member name="P:Blockcore.Configuration.NodeSettings.MaxTxFeeRate">
            <summary>The optional maximum fee for a kB of transactions on the node.</summary>
        </member>
        <member name="P:Blockcore.Configuration.NodeSettings.FallbackTxFeeRate">
            <summary>The default fee for a kB of transactions on the node. This value is used if no fee is specified for
            a transaction.
            </summary>
        </member>
        <member name="P:Blockcore.Configuration.NodeSettings.MinRelayTxFeeRate">
            <summary>The minimum relay transaction fee for a kB of transactions on the node. A miner may not be prepared
            to mine a transaction for a specified fee but might be prepared to forward the transaction to another miner
            who will. In this situation, the transaction is propagated to other peers if the relay fee
            is met. For this reason, the minimum relay transaction fee is usually lower than the minimum fee.
            </summary>
        </member>
        <member name="P:Blockcore.Configuration.NodeSettings.DbType">
            <summary>
            The type of database to use for the node (this includes consensus, store, chain, and the common key value store).
            </summary>
        </member>
        <member name="M:Blockcore.Configuration.NodeSettings.#ctor(Blockcore.Networks.Network,System.String,System.String[],Blockcore.Networks.NetworksSelector)">
            <summary>
            Initializes a new instance of the object.
            </summary>
            <param name="network">The network the node runs on - regtest/testnet/mainnet.</param>
            <param name="protocolVersion">Supported protocol version for which to create the configuration.</param>
            <param name="agent">The nodes user agent that will be shared with peers.</param>
            <param name="args">The command-line arguments.</param>
            <param name="networksSelector">A selector class that delayed load a network for either - regtest/testnet/mainnet.</param>
            <exception cref="T:Blockcore.Configuration.ConfigurationException">Thrown in case of any problems with the configuration file or command line arguments.</exception>
            <remarks>
            Processing depends on whether a configuration file is passed via the command line.
            There are two main scenarios here:
            - The configuration file is passed via the command line. In this case we need
              to read it earlier so that it can provide defaults for "testnet" and "regtest".
            - Alternatively, if the file name is not supplied then a network-specific file
              name would be determined. In this case we first need to determine the network.
            </remarks>
        </member>
        <member name="P:Blockcore.Configuration.NodeSettings.PrintHelpAndExit">
            <summary>Determines whether to print help and exit.</summary>
        </member>
        <member name="M:Blockcore.Configuration.NodeSettings.Default(Blockcore.Networks.Network)">
            <summary>
            Initializes default configuration.
            </summary>
            <param name="network">Specification of the network the node runs on - regtest/testnet/mainnet.</param>
            <param name="protocolVersion">Supported protocol version for which to create the configuration.</param>
            <returns>Default node configuration.</returns>
        </member>
        <member name="M:Blockcore.Configuration.NodeSettings.CreateDefaultConfigurationFile(System.Collections.Generic.List{Blockcore.Builder.Feature.IFeatureRegistration},Blockcore.Builder.IFullNodeBuilder)">
            <summary>
            Creates the configuration file if it does not exist.
            </summary>
            <param name="features">The features for which to include settings in the configuration file.</param>
            <param name="fullNodeBuilder">The full node builder.</param>
        </member>
        <member name="M:Blockcore.Configuration.NodeSettings.ReadConfigurationFile">
            <summary>
            Reads the configuration file and merges it with the command line arguments.
            </summary>
        </member>
        <member name="M:Blockcore.Configuration.NodeSettings.LoadConfiguration">
            <summary>
            Loads the node settings from the application configuration.
            </summary>
        </member>
        <member name="M:Blockcore.Configuration.NodeSettings.CreateDefaultDataDirectories(System.String,Blockcore.Networks.Network)">
            <summary>
            Creates default data directories respecting different operating system specifics.
            </summary>
            <param name="appName">Name of the node, which will be reflected in the name of the data directory.</param>
            <param name="network">Specification of the network the node runs on - regtest/testnet/mainnet.</param>
            <returns>The top-level data directory path.</returns>
        </member>
        <member name="M:Blockcore.Configuration.NodeSettings.PrintHelp(Blockcore.Networks.Network,Blockcore.Builder.IFullNodeBuilder)">
            <summary>
            Displays command-line help.
            </summary>
            <param name="network">The network to extract values from.</param>
        </member>
        <member name="M:Blockcore.Configuration.NodeSettings.BuildDefaultConfigurationFile(System.Text.StringBuilder,Blockcore.Networks.Network,Blockcore.Builder.IFullNodeBuilder)">
            <summary>
            Get the default configuration.
            </summary>
            <param name="builder">The string builder to add the settings to.</param>
            <param name="network">The network to base the defaults off.</param>
            <param name="fullNodeBuilder">The full node builder.</param>
        </member>
        <member name="M:Blockcore.Configuration.NodeSettings.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Configuration.Settings.ConnectionManagerSettings">
            <summary>
            Configuration related to incoming and outgoing connections.
            </summary>
        </member>
        <member name="F:Blockcore.Configuration.Settings.ConnectionManagerSettings.MaximumAgentPrefixLength">
            <summary>Maximum number of AgentPrefix characters to use in the Agent value.</summary>
        </member>
        <member name="F:Blockcore.Configuration.Settings.ConnectionManagerSettings.DefaultBlocksOnly">
            <summary>Default value for "blocksonly" option.</summary>
            <seealso cref="P:Blockcore.Configuration.Settings.ConnectionManagerSettings.RelayTxes"/>
        </member>
        <member name="F:Blockcore.Configuration.Settings.ConnectionManagerSettings.logger">
            <summary>Instance logger.</summary>
        </member>
        <member name="F:Blockcore.Configuration.Settings.ConnectionManagerSettings.addNode">
            <summary>List of end points that the node should try to connect to.</summary>
            <remarks>All access should be protected under <see cref="F:Blockcore.Configuration.Settings.ConnectionManagerSettings.addNodeLock"/></remarks>
        </member>
        <member name="F:Blockcore.Configuration.Settings.ConnectionManagerSettings.addNodeLock">
            <summary>
            Protects access to the list of addnode endpoints.
            </summary>
        </member>
        <member name="M:Blockcore.Configuration.Settings.ConnectionManagerSettings.#ctor(Blockcore.Configuration.NodeSettings)">
            <summary>
            Initializes an instance of the object from the node configuration.
            </summary>
            <param name="nodeSettings">The node configuration.</param>
        </member>
        <member name="M:Blockcore.Configuration.Settings.ConnectionManagerSettings.BuildDefaultConfigurationFile(System.Text.StringBuilder,Blockcore.Networks.Network)">
            <summary>
            Get the default configuration.
            </summary>
            <param name="builder">The string builder to add the settings to.</param>
            <param name="network">The network to base the defaults off.</param>
        </member>
        <member name="M:Blockcore.Configuration.Settings.ConnectionManagerSettings.PrintHelp(Blockcore.Networks.Network)">
            <summary>
            Displays command-line help.
            </summary>
            <param name="network">The network to extract values from.</param>
        </member>
        <member name="P:Blockcore.Configuration.Settings.ConnectionManagerSettings.Connect">
            <summary>List of exclusive end points that the node should be connected to.</summary>
        </member>
        <member name="P:Blockcore.Configuration.Settings.ConnectionManagerSettings.Listen">
            <summary>
            Accepts incoming connections by starting the node server.
            <para>
            Set to true if no -connect args specified or explicility set to -listen=1.
            </para>
            <para>
            E.g.
            -listen=1 -connect=127.0.0.0 -> Listen = true
            -listen -connect=127.0.0.0 -> Listen = true
            -listen=0 -connect=127.0.0.0 -> Listen = false
            -connect=127.0.0.0 -> Listen = false
            </para>
            </summary>
        </member>
        <member name="P:Blockcore.Configuration.Settings.ConnectionManagerSettings.Bind">
            <summary>List of network interfaces on which the node should listen on.</summary>
        </member>
        <member name="P:Blockcore.Configuration.Settings.ConnectionManagerSettings.ExternalEndpoint">
            <summary>External (or public) IP address of the node.</summary>
        </member>
        <member name="P:Blockcore.Configuration.Settings.ConnectionManagerSettings.Port">
            <summary>Port of the node.</summary>
        </member>
        <member name="P:Blockcore.Configuration.Settings.ConnectionManagerSettings.BanTimeSeconds">
            <summary>Number of seconds to keep misbehaving peers from reconnecting.</summary>
        </member>
        <member name="P:Blockcore.Configuration.Settings.ConnectionManagerSettings.MaxOutboundConnections">
            <summary>Maximum number of outbound connections.</summary>
        </member>
        <member name="P:Blockcore.Configuration.Settings.ConnectionManagerSettings.MaxInboundConnections">
            <summary>Maximum number of inbound connections.</summary>
        </member>
        <member name="P:Blockcore.Configuration.Settings.ConnectionManagerSettings.InitialConnectionTarget">
            <summary>
            The amount of connections to be reached before a 1 second connection interval in the <see cref="T:Blockcore.P2P.PeerConnectorDiscovery"/> is set.
            <para>
            When the <see cref="T:Blockcore.P2P.PeerConnectorDiscovery"/> starts up, a 100ms delay is set as the connection interval in order for
            the node to quickly connect to other peers.
            </para>
            </summary>
        </member>
        <member name="P:Blockcore.Configuration.Settings.ConnectionManagerSettings.SyncTimeEnabled">
            <summary><c>true</c> to sync time with other peers and calculate adjusted time, <c>false</c> to use our system clock only.</summary>
        </member>
        <member name="P:Blockcore.Configuration.Settings.ConnectionManagerSettings.Agent">
            <summary>The node's user agent.</summary>
        </member>
        <member name="P:Blockcore.Configuration.Settings.ConnectionManagerSettings.RelayTxes">
            <summary><c>true</c> to enable bandwidth saving setting to send and received confirmed blocks only.</summary>
        </member>
        <member name="P:Blockcore.Configuration.Settings.ConnectionManagerSettings.IpRangeFiltering">
            <summary>Filter peers that are within the same IP range to prevent sybil attacks.</summary>
        </member>
        <member name="P:Blockcore.Configuration.Settings.ConnectionManagerSettings.Whitelist">
            <summary>List of white listed IP endpoint. The node will flags peers that connects to the node, or that the node connects to, as whitelisted.</summary>
        </member>
        <member name="T:Blockcore.Configuration.Settings.ConsensusSettings">
            <summary>
            Configurable settings for the consensus feature.
            </summary>
        </member>
        <member name="F:Blockcore.Configuration.Settings.ConsensusSettings.logger">
            <summary>Instance logger.</summary>
        </member>
        <member name="P:Blockcore.Configuration.Settings.ConsensusSettings.UseCheckpoints">
            <summary>Whether use of checkpoints is enabled or not.</summary>
        </member>
        <member name="P:Blockcore.Configuration.Settings.ConsensusSettings.BlockAssumedValid">
            <summary>
            If this block is in the chain assume that it and its ancestors are valid and skip their script verification.
            Null to not assume valid blocks and therefore validate all blocks.
            </summary>
        </member>
        <member name="P:Blockcore.Configuration.Settings.ConsensusSettings.MaxTipAge">
            <summary>Maximum tip age in seconds to consider node in initial block download.</summary>
        </member>
        <member name="P:Blockcore.Configuration.Settings.ConsensusSettings.MaxBlockMemoryInMB">
            <summary>
            Maximum memory to use for unconsume blocks in MB.
            Used in consensus manager to set <seealso cref="!:ConsensusManager.MaxUnconsumedBlocksDataBytes"/>
            </summary>
        </member>
        <member name="P:Blockcore.Configuration.Settings.ConsensusSettings.MaxCoindbCacheInMB">
            <summary>
            Maximum memory to use for the coin db cache .
            </summary>
        </member>
        <member name="P:Blockcore.Configuration.Settings.ConsensusSettings.CoindbIbdFlushMin">
            <summary>
            How often to flush the cache to disk when in IBD, note if dbcache is bigger then <see cref="P:Blockcore.Configuration.Settings.ConsensusSettings.MaxCoindbCacheInMB"/> flush will happen anyway happen.
            </summary>
        </member>
        <member name="M:Blockcore.Configuration.Settings.ConsensusSettings.#ctor(Blockcore.Configuration.NodeSettings)">
            <summary>
            Initializes an instance of the object from the node configuration.
            </summary>
            <param name="nodeSettings">The node configuration.</param>
        </member>
        <member name="M:Blockcore.Configuration.Settings.ConsensusSettings.PrintHelp(Blockcore.Networks.Network)">
            <summary>Prints the help information on how to configure the Consensus settings to the logger.</summary>
            <param name="network">The network to use.</param>
        </member>
        <member name="M:Blockcore.Configuration.Settings.ConsensusSettings.BuildDefaultConfigurationFile(System.Text.StringBuilder,Blockcore.Networks.Network)">
            <summary>
            Get the default configuration.
            </summary>
            <param name="builder">The string builder to add the settings to.</param>
            <param name="network">The network to base the defaults off.</param>
        </member>
        <member name="T:Blockcore.Configuration.Settings.LogSettings">
            <summary>
            Configuration related to logging.
            </summary>
        </member>
        <member name="M:Blockcore.Configuration.Settings.LogSettings.#ctor">
            <summary>
            Initializes an instance of the object with default values.
            </summary>
        </member>
        <member name="P:Blockcore.Configuration.Settings.LogSettings.DebugArgs">
            <summary>List of categories to enable debugging information for.</summary>
            <remarks>A special value of "1" of the first category enables trace level debugging information for everything.</remarks>
        </member>
        <member name="P:Blockcore.Configuration.Settings.LogSettings.LogLevel">
            <summary>Level of logging details.</summary>
        </member>
        <member name="M:Blockcore.Configuration.Settings.LogSettings.Load(Blockcore.Configuration.TextFileConfiguration)">
            <summary>
            Loads the logging settings from the application configuration.
            </summary>
            <param name="config">Application configuration.</param>
        </member>
        <member name="T:Blockcore.Configuration.ConfigurationException">
            <summary>
            Exception that is used when a problem in command line or configuration file configuration is found.
            </summary>
        </member>
        <member name="T:Blockcore.Configuration.TextFileConfiguration">
            <summary>
            Handling of application configuration.
            <para>
            This class provides the primary source of configuration for the application.
            It is used to include both the arguments from the command line as well as
            settings loaded from the configuration file.
            </para>
            </summary>
        </member>
        <member name="F:Blockcore.Configuration.TextFileConfiguration.args">
            <summary>Application command line arguments as a mapping of argument name to list of its values.</summary>
        </member>
        <member name="M:Blockcore.Configuration.TextFileConfiguration.#ctor(System.String[])">
            <summary>
            Initializes the instance of the object using command line arguments.
            </summary>
            <param name="args">Application command line arguments.</param>
            <remarks>Command line arguments are expected to come in form of Name=Value, where Name can be prefixed with '-'.</remarks>
        </member>
        <member name="M:Blockcore.Configuration.TextFileConfiguration.#ctor(System.String)">
            <summary>
            Initializes the instance of the object using the configuration file contents.
            </summary>
            <param name="data">Contents of the configuration file to parse and extract arguments from.</param>
        </member>
        <member name="M:Blockcore.Configuration.TextFileConfiguration.Add(System.String,System.String)">
            <summary>
            Adds argument and its value to the argument list.
            <para>If the argument exists already in the list, the value is appended to the list of its values.</para>
            </summary>
            <param name="key">Name of the argument.</param>
            <param name="value">Argument value.</param>
        </member>
        <member name="M:Blockcore.Configuration.TextFileConfiguration.MergeInto(Blockcore.Configuration.TextFileConfiguration)">
            <summary>
            Merges current instance of the configuration to the target instance.
            </summary>
            <param name="destination">Target instance to merge current instance into.</param>
        </member>
        <member name="M:Blockcore.Configuration.TextFileConfiguration.GetAll(System.String,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Retrieves all values of a specific argument name (where the name excludes the dash prefix).
            </summary>
            <param name="key">Name of the argument (excluding the dash prefix).</param>
            <param name="logger">The settings logger used to log the value. Logs on Debug level.</param>
            <returns>Values for the specified argument.</returns>
        </member>
        <member name="M:Blockcore.Configuration.TextFileConfiguration.GetOrDefault``1(System.String,``0,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Gets typed value for a specific argument or a default value.
            </summary>
            <typeparam name="T">Type of the argument value.</typeparam>
            <param name="key">Name of the argument.</param>
            <param name="defaultValue">Default value to return if no argument value is defined.</param>
            <param name="logger">The settings logger to use to log the value. Logs on Debug level.</param>
            <returns>Value of the argument or a default value if no value was set.</returns>
        </member>
        <member name="M:Blockcore.Configuration.TextFileConfiguration.ConvertValue``1(System.String)">
            <summary>
            Converts a string to a typed value.
            </summary>
            <typeparam name="T">Type of the value to convert the string to.</typeparam>
            <param name="str">String representation of the value.</param>
            <returns>Typed value.</returns>
            <exception cref="T:System.NotSupportedException">Thrown if <typeparamref name="T"/> is not supported type.</exception>
            <exception cref="T:System.FormatException">Thrown if the string does not represent a valid value of <typeparamref name="T"/>.</exception>
        </member>
        <member name="F:Blockcore.Connection.Broadcasting.BroadcasterBehavior.logger">
            <summary>Instance logger for the memory pool component.</summary>
        </member>
        <member name="M:Blockcore.Connection.Broadcasting.BroadcasterBehavior.Clone">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Connection.Broadcasting.BroadcasterBehavior.OnMessageReceivedAsync(Blockcore.P2P.Peer.INetworkPeer,Blockcore.P2P.Protocol.IncomingMessage)">
            <summary>
            Handler for processing incoming message from the peer.
            </summary>
            <param name="peer">Peer sending the message.</param>
            <param name="message">Incoming message.</param>
            <remarks>
            TODO: Fix the exception handling of the async event.
            </remarks>
        </member>
        <member name="M:Blockcore.Connection.Broadcasting.BroadcasterBehavior.ProcessMessageAsync(Blockcore.P2P.Peer.INetworkPeer,Blockcore.P2P.Protocol.IncomingMessage)">
            <summary>
            Handler for processing peer messages.
            Handles the following message payloads: TxPayload, MempoolPayload, GetDataPayload, InvPayload.
            </summary>
            <param name="peer">Peer sending the message.</param>
            <param name="message">Incoming message.</param>
        </member>
        <member name="M:Blockcore.Connection.Broadcasting.BroadcasterBehavior.AttachCore">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Connection.Broadcasting.BroadcasterBehavior.DetachCore">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Connection.Broadcasting.BroadcasterManager.GetTransaction(Blockcore.NBitcoin.uint256)">
            <summary>Retrieves a transaction with provided hash from the collection of transactions to broadcast.</summary>
            <param name="transactionHash">Hash of the transaction to retrieve.</param>
        </member>
        <member name="M:Blockcore.Connection.Broadcasting.BroadcasterManager.AddOrUpdate(Blockcore.Consensus.TransactionInfo.Transaction,Blockcore.Connection.Broadcasting.TransactionBroadcastState,System.String)">
            <summary>Adds or updates a transaction from the collection of transactions to broadcast.</summary>
        </member>
        <member name="M:Blockcore.Connection.Broadcasting.BroadcasterManager.PropagateTransactionToPeersAsync(Blockcore.Consensus.TransactionInfo.Transaction)">
            <summary>
            Sends transaction to peers.
            </summary>
            <param name="transaction">Transaction that will be propagated.</param>
        </member>
        <member name="M:Blockcore.Connection.Broadcasting.BroadcasterManager.IsPropagated(Blockcore.Consensus.TransactionInfo.Transaction)">
            <summary>Checks if transaction was propagated to any peers on the network.</summary>
        </member>
        <member name="P:Blockcore.Connection.Broadcasting.BroadcastTransactionStateChanedEntry.TransactionId">
            <summary>
            Makes the transaction ID available for Web Socket consumers.
            </summary>
        </member>
        <member name="T:Blockcore.Connection.Broadcasting.NoCheckBroadcastCheck">
            <summary>
            Broadcast that makes not checks.
            </summary>
        </member>
        <member name="T:Blockcore.Connection.Broadcasting.TransactionBroadcastEvent">
            <summary>
            Event that is executed when a transaction is broadcasted.
            </summary>
        </member>
        <member name="F:Blockcore.Connection.ConnectionManager.dateTimeProvider">
            <summary>Provider of time functions.</summary>
        </member>
        <member name="F:Blockcore.Connection.ConnectionManager.MaxInventorySize">
            <summary>The maximum number of entries in an 'inv' protocol message.</summary>
        </member>
        <member name="F:Blockcore.Connection.ConnectionManager.loggerFactory">
            <summary>Logger factory to create loggers.</summary>
        </member>
        <member name="F:Blockcore.Connection.ConnectionManager.logger">
            <summary>Instance logger.</summary>
        </member>
        <member name="P:Blockcore.Connection.ConnectionManager.Network">
            <inheritdoc/>
        </member>
        <member name="P:Blockcore.Connection.ConnectionManager.NetworkPeerFactory">
            <inheritdoc/>
        </member>
        <member name="F:Blockcore.Connection.ConnectionManager.nodeLifetime">
            <summary>Global application life cycle control - triggers when application shuts down.</summary>
        </member>
        <member name="P:Blockcore.Connection.ConnectionManager.NodeSettings">
            <inheritdoc/>
        </member>
        <member name="P:Blockcore.Connection.ConnectionManager.ConnectionSettings">
            <inheritdoc/>
        </member>
        <member name="P:Blockcore.Connection.ConnectionManager.Parameters">
            <inheritdoc/>
        </member>
        <member name="P:Blockcore.Connection.ConnectionManager.PeerConnectors">
            <inheritdoc/>
        </member>
        <member name="F:Blockcore.Connection.ConnectionManager.peerAddressManager">
            <summary>Manager class that handles peers and their respective states.</summary>
        </member>
        <member name="F:Blockcore.Connection.ConnectionManager.peerDiscovery">
            <summary>Async loop that discovers new peers to connect to.</summary>
        </member>
        <member name="F:Blockcore.Connection.ConnectionManager.selfEndpointTracker">
            <summary>Registry of endpoints used to identify this node.</summary>
        </member>
        <member name="P:Blockcore.Connection.ConnectionManager.Servers">
            <inheritdoc/>
        </member>
        <member name="F:Blockcore.Connection.ConnectionManager.networkPeerDisposer">
            <summary>Maintains a list of connected peers and ensures their proper disposal.</summary>
        </member>
        <member name="F:Blockcore.Connection.ConnectionManager.disconnectedPerfCounter">
            <summary>Traffic statistics from peers that have been disconnected.</summary>
        </member>
        <member name="M:Blockcore.Connection.ConnectionManager.Initialize(Blockcore.Consensus.IConsensusManager)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Connection.ConnectionManager.AddExternalIpToSelfEndpoints">
            <summary>
            If -externalip was set on startup, put it in the registry of known selves so
            we can avoid connecting to our own node.
            </summary>
        </member>
        <member name="M:Blockcore.Connection.ConnectionManager.AddDiscoveredNodesRequirement(Blockcore.P2P.Protocol.Payloads.NetworkPeerServices)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Connection.ConnectionManager.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Connection.ConnectionManager.AddConnectedPeer(Blockcore.P2P.Peer.INetworkPeer)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Connection.ConnectionManager.ShouldDisconnect(Blockcore.P2P.Peer.INetworkPeer)">
            <summary>
            Determines if the peer should be disconnected.
            Peer should be disconnected in case it's IP is from the same group in which any other peer
            is and the peer wasn't added using -connect or -addNode command line arguments.
            </summary>
        </member>
        <member name="M:Blockcore.Connection.ConnectionManager.RemoveConnectedPeer(Blockcore.P2P.Peer.INetworkPeer,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Connection.ConnectionManager.PeerDisconnected(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Connection.ConnectionManager.AddNodeAddress(System.Net.IPEndPoint,System.Boolean)">
            <summary>
            Adds a node to the -addnode collection.
            <para>
            Usually called via RPC.
            </para>
            </summary>
            <param name="ipEndpoint">The endpoint of the peer to add.</param>
        </member>
        <member name="M:Blockcore.Connection.ConnectionManager.RemoveNodeAddress(System.Net.IPEndPoint)">
            <summary>
            Disconnect a peer.
            <para>
            Usually called via RPC.
            </para>
            </summary>
            <param name="ipEndpoint">The endpoint of the peer to disconnect.</param>
        </member>
        <member name="F:Blockcore.Connection.ConnectionManagerBehavior.loggerFactory">
            <summary>Logger factory to create loggers.</summary>
        </member>
        <member name="F:Blockcore.Connection.ConnectionManagerBehavior.logger">
            <summary>Instance logger.</summary>
        </member>
        <member name="F:Blockcore.Connection.ConnectionManagerBehavior.infoLogger">
            <summary>
            Instance logger that we use for logging of INFO level messages that are visible on the console.
            <para>Unlike <see cref="F:Blockcore.Connection.ConnectionManagerBehavior.logger"/>, this one is created without prefix for the nicer console output.</para>
            </summary>
        </member>
        <member name="T:Blockcore.Connection.DropNodesBehaviour">
            <summary>
            If the light wallet is only connected to nodes behind
            it cannot progress progress to the tip to get the full balance
            this behaviour will make sure place is kept for nodes higher then
            current tip.
            </summary>
        </member>
        <member name="F:Blockcore.Connection.DropNodesBehaviour.loggerFactory">
            <summary>Logger factory to create loggers.</summary>
        </member>
        <member name="F:Blockcore.Connection.DropNodesBehaviour.logger">
            <summary>Instance logger.</summary>
        </member>
        <member name="M:Blockcore.Connection.IConnectionManager.AddNodeAddress(System.Net.IPEndPoint,System.Boolean)">
            <summary>
            Adds a peer to the address manager's collection as well as
            the connection manager's add node collection.
            </summary>
        </member>
        <member name="M:Blockcore.Connection.IConnectionManager.AddConnectedPeer(Blockcore.P2P.Peer.INetworkPeer)">
            <summary>
            Adds a peer to the address manager's connected nodes collection.
            <para>
            This list is inspected by the peer connectors to determine if the peer
            isn't already connected.
            </para>
            </summary>
        </member>
        <member name="M:Blockcore.Connection.IConnectionManager.AddDiscoveredNodesRequirement(Blockcore.P2P.Protocol.Payloads.NetworkPeerServices)">
            <summary>
            Add a <see cref="T:Blockcore.P2P.Protocol.Payloads.NetworkPeerServices"/> type requirement to the <see cref="T:Blockcore.P2P.PeerConnectorDiscovery"/> connector.
            The required services are only applied to outbound nodes.
            </summary>
            <param name="services">The services to set as a requirement.</param>
        </member>
        <member name="M:Blockcore.Connection.IConnectionManager.PeerDisconnected(System.Int32)">
            <summary>Notifies other components about peer being disconnected.</summary>
        </member>
        <member name="M:Blockcore.Connection.IConnectionManager.Initialize(Blockcore.Consensus.IConsensusManager)">
            <summary>Initializes and starts each peer connection as well as peer discovery.</summary>
        </member>
        <member name="P:Blockcore.Connection.IConnectionManager.Network">
            <summary>The network the node is running on.</summary>
        </member>
        <member name="P:Blockcore.Connection.IConnectionManager.NetworkPeerFactory">
            <summary>Factory for creating P2P network peers.</summary>
        </member>
        <member name="P:Blockcore.Connection.IConnectionManager.NodeSettings">
            <summary>User defined node settings.</summary>
        </member>
        <member name="P:Blockcore.Connection.IConnectionManager.Parameters">
            <summary>The network peer parameters for the <see cref="T:Blockcore.Connection.IConnectionManager"/>.</summary>
        </member>
        <member name="P:Blockcore.Connection.IConnectionManager.PeerConnectors">
            <summary>Includes the add node, connect and discovery peer connectors.</summary>
        </member>
        <member name="P:Blockcore.Connection.IConnectionManager.ConnectionSettings">
            <summary>Connection settings.</summary>
        </member>
        <member name="M:Blockcore.Connection.IConnectionManager.RemoveNodeAddress(System.Net.IPEndPoint)">
            <summary>
            Remove a peer from the address manager's collection as well as
            the connection manager's add node collection.
            </summary>
        </member>
        <member name="P:Blockcore.Connection.IConnectionManager.Servers">
            <summary>
            The endpoints the node is listening on for inbound connections.
            </summary>
        </member>
        <member name="T:Blockcore.Connection.IPeerBanning">
            <summary>
            Contract for network peer banning provider.
            </summary>
            <remarks>
            Peers are banned for <see cref="!:ConnectionManagerSettings.DefaultMisbehavingBantimeSeconds"/> seconds (default is 24h), this value can change using configuration (-bantime=[seconds]).
            </remarks>
        </member>
        <member name="M:Blockcore.Connection.IPeerBanning.BanAndDisconnectPeer(System.Net.IPEndPoint,System.Int32,System.String)">
            <summary>
            Bans and disconnects the peer.
            </summary>
            <param name="endpoint">The endpoint to set that it was banned.</param>
            <param name="banTimeSeconds">The time in seconds this peer should be banned.</param>
            <param name="reason">An optional reason for the ban, the 'reason' is only use for tracing.</param>
        </member>
        <member name="M:Blockcore.Connection.IPeerBanning.BanAndDisconnectPeer(System.Net.IPEndPoint,System.String)">
            <summary>
            Bans and disconnects the peer using the connection manager's default ban interval.
            This allows features to depend solely on the peer banning interface and not the connection manager directly.
            </summary>
            <param name="endpoint">The endpoint to set that it was banned.</param>
            <param name="reason">An optional reason for the ban, the 'reason' is only use for tracing.</param>
        </member>
        <member name="M:Blockcore.Connection.IPeerBanning.ClearBannedPeers">
            <summary>
            Clears the node's banned peer list.
            </summary>
        </member>
        <member name="M:Blockcore.Connection.IPeerBanning.GetAllBanned">
            <summary>
            Returns a list of all the banned peers.
            </summary>
        </member>
        <member name="M:Blockcore.Connection.IPeerBanning.IsBanned(System.Net.IPEndPoint)">
            <summary>
            Check if a peer is banned.
            </summary>
            <param name="endpoint">The endpoint to check if it was banned.</param>
            <returns><c>true</c> if the peer was banned.</returns>
        </member>
        <member name="M:Blockcore.Connection.IPeerBanning.UnBanPeer(System.Net.IPEndPoint)">
            <summary>
            Un-bans a banned peer.
            </summary>
            <param name="endpoint">The endpoint of the peer to un-ban.</param>
        </member>
        <member name="T:Blockcore.Connection.PeerBanning">
            <summary>
            An implementation of<see cref="T:Blockcore.Connection.IPeerBanning"/>.
            This will manage banning of peers and checking for banned peers.
            </summary>
        </member>
        <member name="F:Blockcore.Connection.PeerBanning.connectionManager">
            <summary>A connection manager of peers.</summary>
        </member>
        <member name="F:Blockcore.Connection.PeerBanning.logger">
            <summary>Instance logger.</summary>
        </member>
        <member name="F:Blockcore.Connection.PeerBanning.dateTimeProvider">
            <summary>Functionality of date and time.</summary>
        </member>
        <member name="F:Blockcore.Connection.PeerBanning.peerAddressManager">
            <summary>Keeps a set of peers discovered on the network in cache and on disk.</summary>
        </member>
        <member name="M:Blockcore.Connection.PeerBanning.BanAndDisconnectPeer(System.Net.IPEndPoint,System.Int32,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Connection.PeerBanning.BanAndDisconnectPeer(System.Net.IPEndPoint,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Connection.PeerBanning.ClearBannedPeers">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Connection.PeerBanning.GetAllBanned">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Connection.PeerBanning.IsBanned(System.Net.IPEndPoint)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Connection.PeerBanning.UnBanPeer(System.Net.IPEndPoint)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Connection.PeerBanningBehavior">
            <summary>
            A behaviour that will manage the lifetime of peers.
            </summary>
        </member>
        <member name="F:Blockcore.Connection.PeerBanningBehavior.loggerFactory">
            <summary>Logger factory to create loggers.</summary>
        </member>
        <member name="F:Blockcore.Connection.PeerBanningBehavior.peerBanning">
            <summary>Handle the lifetime of a peer.</summary>
        </member>
        <member name="F:Blockcore.Connection.PeerBanningBehavior.nodeSettings">
            <summary>The node settings.</summary>
        </member>
        <member name="F:Blockcore.Connection.PeerBanningBehavior.logger">
            <summary>Instance logger.</summary>
        </member>
        <member name="M:Blockcore.Connection.PeerBanningBehavior.DetachCore">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Connection.PeerBanningBehavior.Clone">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Connection.PeerBanningBehavior.AttachCore">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Connection.PeerNodeModel">
            <summary>
            Data structure for connected peer node.
            </summary>
        </member>
        <member name="P:Blockcore.Connection.PeerNodeModel.Id">
            <summary>
             Peer index.
            </summary>
        </member>
        <member name="P:Blockcore.Connection.PeerNodeModel.Address">
            <summary>
            The IP address and port of the peer.
            </summary>
        </member>
        <member name="P:Blockcore.Connection.PeerNodeModel.LocalAddress">
            <summary>
            Local address as reported by the peer.
            </summary>
        </member>
        <member name="P:Blockcore.Connection.PeerNodeModel.Services">
            <summary>
            The services offered.
            </summary>
        </member>
        <member name="P:Blockcore.Connection.PeerNodeModel.IsRelayTransactions">
            <summary>
            Whether the peer has asked us to relay transactions to it.
            Currently not populated.
            </summary>
        </member>
        <member name="P:Blockcore.Connection.PeerNodeModel.LastSend">
            <summary>
            The Unix epoch time of the last send from this node.
            Currently not populated.
            </summary>
        </member>
        <member name="P:Blockcore.Connection.PeerNodeModel.LastReceive">
            <summary>
            TheUnixepochtimewhenwelastreceiveddatafromthisnode.
            Currently not populated.
            </summary>
        </member>
        <member name="P:Blockcore.Connection.PeerNodeModel.BytesSent">
            <summary>
            Thetotalnumberofbyteswevesenttothisnode.
            Currently not populated.
            </summary>
        </member>
        <member name="P:Blockcore.Connection.PeerNodeModel.BytesReceived">
            <summary>
            Thetotalnumberofbyteswevereceivedfromthisnode.
            Currently not populated.
            </summary>
        </member>
        <member name="P:Blockcore.Connection.PeerNodeModel.ConnectionTime">
            <summary>
            The connection time in seconds since epoch.
            Currently not populated.
            </summary>
        </member>
        <member name="P:Blockcore.Connection.PeerNodeModel.TimeOffset">
            <summary>
            The time offset in seconds.
            </summary>
        </member>
        <member name="P:Blockcore.Connection.PeerNodeModel.PingTime">
            <summary>
            The ping time to the node in seconds.
            Currently not populated.
            </summary>
        </member>
        <member name="P:Blockcore.Connection.PeerNodeModel.MinPing">
            <summary>
            The minimum observed ping time.
            Currently not populated.
            </summary>
        </member>
        <member name="P:Blockcore.Connection.PeerNodeModel.PingWait">
            <summary>
            The number of seconds waiting for a ping.
            Currently not populated.
            </summary>
        </member>
        <member name="P:Blockcore.Connection.PeerNodeModel.Version">
            <summary>
            The protocol version number used by this node.
            </summary>
        </member>
        <member name="P:Blockcore.Connection.PeerNodeModel.SubVersion">
            <summary>
            The user agent this node sends in its version message.
            </summary>
        </member>
        <member name="P:Blockcore.Connection.PeerNodeModel.Inbound">
            <summary>
            Whether node is inbound or outbound connection.
            Currently not populated.
            </summary>
        </member>
        <member name="P:Blockcore.Connection.PeerNodeModel.IsAddNode">
            <summary>
            Whether connection was due to addnode.
            Currently not populated.
            </summary>
        </member>
        <member name="P:Blockcore.Connection.PeerNodeModel.StartingHeight">
            <summary>
            The starting height (block) of the peer.
            </summary>
        </member>
        <member name="P:Blockcore.Connection.PeerNodeModel.BanScore">
            <summary>
            The ban score for the node.
            Currently not populated.
            </summary>
        </member>
        <member name="P:Blockcore.Connection.PeerNodeModel.SynchronizedHeaders">
            <summary>
            The last header we have in common with this peer.
            Currently not populated.
            </summary>
        </member>
        <member name="P:Blockcore.Connection.PeerNodeModel.SynchronizedBlocks">
            <summary>
            The last block we have in common with this peer.
            Currently not populated.
            </summary>
        </member>
        <member name="P:Blockcore.Connection.PeerNodeModel.IsWhiteListed">
            <summary>
            Whether the peer is whitelisted.
            </summary>
        </member>
        <member name="P:Blockcore.Connection.PeerNodeModel.Inflight">
            <summary>
            The heights of blocks we're currently asking from this peer.
            Currently not populated.
            </summary>
        </member>
        <member name="P:Blockcore.Connection.PeerNodeModel.BytesSentPerMessage">
            <summary>
            Total sent bytes aggregated by message type.
            Currently not populated.
            </summary>
        </member>
        <member name="P:Blockcore.Connection.PeerNodeModel.BytesReceivedPerMessage">
            <summary>
            Total received bytes aggregated by message type.
            Currently not populated.
            </summary>
        </member>
        <member name="T:Blockcore.Consensus.BlockDownloadRequest">
            <summary>
            A request to the block puller that holds the chained headers of the blocks that are requested for download.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.BlockDownloadRequest.BlocksToDownload">
            <summary>The list of block headers to download.</summary>
        </member>
        <member name="P:Blockcore.Consensus.BlockInfo.Block.BlockSize">
            <summary>
            The size of the block in bytes, the block must be serialized for this property to be set.
            This property will be set only once on the first serialization(or deserialization).
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.BlockInfo.Block.GetHash">
            <summary>
            A block's hash is it's header's hash.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.BlockInfo.Block.WithOptions(Blockcore.Consensus.ConsensusFactory,Blockcore.Consensus.TransactionInfo.TransactionOptions)">
            <summary>
            Create a block with the specified option only. (useful for stripping data from a block).
            </summary>
            <param name="consensusFactory">The network consensus factory.</param>
            <param name="options">Options to keep.</param>
            <returns>A new block with only the options wanted.</returns>
        </member>
        <member name="T:Blockcore.Consensus.BlockInfo.BlockHeader">
            <summary>
            Nodes collect new transactions into a block, hash them into a hash tree,
            and scan through nonce values to make the block's hash satisfy proof-of-work
            requirements.  When they solve the proof-of-work, they broadcast the block
            to everyone and the block is added to the block chain.  The first transaction
            in the block is a special one that creates a new coin owned by the creator
            of the block.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.BlockInfo.BlockHeader.CurrentVersion">
            <summary>Current header version.</summary>
        </member>
        <member name="M:Blockcore.Consensus.BlockInfo.BlockHeader.ReadWriteHashingStream(Blockcore.NBitcoin.BitcoinStream)">
            <summary>Populates stream with items that will be used during hash calculation.</summary>
        </member>
        <member name="M:Blockcore.Consensus.BlockInfo.BlockHeader.GetHash">
            <summary>
            Generates the hash of a <see cref="T:Blockcore.Consensus.BlockInfo.BlockHeader"/> or uses cached one.
            </summary>
            <returns>A hash.</returns>
        </member>
        <member name="M:Blockcore.Consensus.BlockInfo.BlockHeader.GetPoWHash">
            <summary>
            Generates a hash for a proof-of-work block header.
            </summary>
            <returns>A hash.</returns>
        </member>
        <member name="M:Blockcore.Consensus.BlockInfo.BlockHeader.PrecomputeHash(System.Boolean,System.Boolean)">
            <summary>
            Precompute the block header hash so that later calls to <see cref="M:Blockcore.Consensus.BlockInfo.BlockHeader.GetHash"/> will returns the precomputed hash.
            </summary>
            <param name="invalidateExisting">If true, the previous precomputed hash is thrown away, else it is reused.</param>
            <param name="lazily">If <c>true</c>, the hash will be calculated and cached at the first call to GetHash(), else it will be immediately.</param>
        </member>
        <member name="M:Blockcore.Consensus.BlockInfo.BlockHeader.ToString">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.BlockInfo.BlockHeader.UpdateTime(System.DateTimeOffset,Blockcore.Consensus.IConsensus,Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>
            Set time to consensus acceptable value.
            </summary>
            <param name="now">The expected date.</param>
            <param name="consensus">Consensus.</param>
            <param name="prev">Previous block.</param>
        </member>
        <member name="M:Blockcore.Consensus.BlockInfo.BlockHeader.UpdateTime(System.DateTimeOffset,Blockcore.Networks.Network,Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>
            Set time to consensus acceptable value.
            </summary>
            <param name="now">The expected date.</param>
            <param name="network">Network.</param>
            <param name="prev">Previous block.</param>
        </member>
        <member name="T:Blockcore.Consensus.BlockInfo.BlockSignature">
            <summary>
            A representation of a block signature.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.BlockInfo.BlockStake.Load(Blockcore.Consensus.BlockInfo.Block)">
            <summary>
            Constructs a stake block from a given block.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.BlockInfo.BlockStake.Load(System.Byte[],Blockcore.Consensus.ConsensusFactory)">
            <summary>
            Constructs a stake block from a set bytes and the given network.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.BlockInfo.BlockStake.Validate(Blockcore.Networks.Network,Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>
            Check PoW and that the blocks connect correctly
            </summary>
            <param name="network">The network being used</param>
            <param name="chainedHeader">Chained block header</param>
            <returns>True if PoW is correct</returns>
        </member>
        <member name="T:Blockcore.Consensus.BlockInfo.IPosTransactionWithTime">
            <summary>
             Represents a transaction with a time field, such trx are used by POS networks however
             the time field is not really needed anymore for POS consensus so in order to allow a new PoSv4 protocol
             network we make this field encapsolated by an interface, removing the time field will make POS
             transactions have the same serialization format as Bitcoin.
            </summary>
        </member>
        <member name="T:Blockcore.Consensus.BlockInfo.PosTransaction">
            <summary>
            A Proof Of Stake transaction.
            </summary>
        </member>
        <member name="T:Blockcore.Consensus.BlockInfo.PosConsensusFactory">
            <summary>
            The consensus factory for creating POS protocol types.
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.BlockInfo.PosConsensusFactory.provenBlockHeaderType">
            <summary>
            The <see cref="T:Blockcore.Consensus.BlockInfo.ProvenBlockHeader"/> type.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.BlockInfo.PosConsensusFactory.IsProvenBlockHeader``1">
            <summary>
            Check if the generic type is assignable from <see cref="T:Blockcore.Consensus.BlockInfo.BlockHeader"/>.
            </summary>
            <typeparam name="T">The type to check if it is IsAssignable from <see cref="T:Blockcore.Consensus.BlockInfo.BlockHeader"/>.</typeparam>
            <returns><c>true</c> if it is assignable.</returns>
        </member>
        <member name="M:Blockcore.Consensus.BlockInfo.PosConsensusFactory.TryCreateNew``1">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.BlockInfo.PosConsensusFactory.CreateBlock">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.BlockInfo.PosConsensusFactory.CreateBlockHeader">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.BlockInfo.PosConsensusFactory.CreateTransaction">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.BlockInfo.PosConsensusFactory.CreateTransaction(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.BlockInfo.PosConsensusFactory.CreateTransaction(System.Byte[])">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Consensus.BlockInfo.PosBlockHeader">
            <summary>
            A POS block header, this will create a work hash based on the X13 hash algos.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.BlockInfo.PosBlockHeader.CurrentVersion">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.BlockInfo.PosBlockHeader.GetHash">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.BlockInfo.PosBlockHeader.GetPoWHash">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Consensus.BlockInfo.PosBlock">
            <summary>
            A POS block that contains the additional block signature serialization.
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.BlockInfo.PosBlock.blockSignature">
            <summary>
            A block signature - signed by one of the coin base txout[N]'s owner.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.BlockInfo.PosBlock.BlockSignature">
            <summary>
            The block signature type.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.BlockInfo.PosBlock.ReadWrite(Blockcore.NBitcoin.BitcoinStream)">
            <summary>
            The additional serialization of the block POS block.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.BlockInfo.PosBlock.GetProtocolTransaction">
            <summary>
            Gets the block's coinstake transaction or returns the coinbase transaction if there is no coinstake.
            </summary>
            <returns>Coinstake transaction or coinbase transaction.</returns>
            <remarks>
            <para>In PoS blocks, coinstake transaction is the second transaction in the block.</para>
            <para>In PoW there isn't a coinstake transaction, return coinbase instead to be able to compute stake modifier for the next eventual PoS block.</para>
            </remarks>
        </member>
        <member name="T:Blockcore.Consensus.BlockInfo.ProvenBlockHeader">
            <summary>
            <para>
            Extension to an existing <see cref="T:Blockcore.Consensus.BlockInfo.BlockHeader"/> which is used in PoS to prevent attacker from constructing
            a fake chain of headers that has more work than the valid chain and attacking a node.
            </para>
            <para>
            Proven header prevents such an attack by including additional information that can be validated and confirmed whether
            the header is fake or real.
            </para>
            </summary>
            <remarks>
            <para>
            Additional information included into proven header:
            </para>
            <para>
            Block header signature (<see cref="P:Blockcore.Consensus.BlockInfo.ProvenBlockHeader.Signature"/>), which is signed with the private key which corresponds to
            coinstake's second output's public key.
            </para>
            <para>
            Coinstake transaction (<see cref="P:Blockcore.Consensus.BlockInfo.ProvenBlockHeader.Coinstake"/>).
            </para>
            <para>
            Merkle proof (<see cref="P:Blockcore.Consensus.BlockInfo.ProvenBlockHeader.MerkleProof"/>) that proves the coinstake tx is included in a block that is being represented by the provided header.
            </para>
            </remarks>
        </member>
        <member name="F:Blockcore.Consensus.BlockInfo.ProvenBlockHeader.posBlockHeader">
            <summary>
            Proof Of Stake header.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.BlockInfo.ProvenBlockHeader.PosBlockHeader">
            <summary>
            Proof Of Stake header.
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.BlockInfo.ProvenBlockHeader.coinstake">
            <summary>
            Coinstake transaction.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.BlockInfo.ProvenBlockHeader.Coinstake">
            <summary>
            Gets coinstake transaction.
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.BlockInfo.ProvenBlockHeader.merkleProof">
            <summary>
            Merkle proof that proves the coinstake tx is included in a block that is being represented by the provided header.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.BlockInfo.ProvenBlockHeader.MerkleProof">
            <summary>
            Gets merkle proof that proves the coinstake tx is included in a block that is being represented by the provided header.
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.BlockInfo.ProvenBlockHeader.signature">
            <summary>
            Block header signature which is signed with the private key which corresponds to
            coinstake's second output's public key.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.BlockInfo.ProvenBlockHeader.Signature">
            <summary>
            Gets block header signature which is signed with the private key which corresponds to
            coinstake's second output's public key.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.BlockInfo.ProvenBlockHeader.MerkleProofSize">
            <summary>Gets the size of the merkle proof in bytes, the header must be serialized or deserialized for this property to be set.</summary>
        </member>
        <member name="P:Blockcore.Consensus.BlockInfo.ProvenBlockHeader.SignatureSize">
            <summary>Gets the size of the signature in bytes, the header must be serialized or deserialized for this property to be set.</summary>
        </member>
        <member name="P:Blockcore.Consensus.BlockInfo.ProvenBlockHeader.CoinstakeSize">
            <summary>Gets the size of the coinstake in bytes, the header must be serialized or deserialized for this property to be set.</summary>
        </member>
        <member name="P:Blockcore.Consensus.BlockInfo.ProvenBlockHeader.HeaderSize">
            <summary>Gets the total header size - including the <see cref="F:Blockcore.Consensus.BlockInfo.BlockHeader.Size"/> - in bytes. <see cref="T:Blockcore.Consensus.BlockInfo.ProvenBlockHeader"/> must be serialized or deserialized for this property to be set.</summary>
        </member>
        <member name="P:Blockcore.Consensus.BlockInfo.ProvenBlockHeader.StakeModifierV2">
            <summary>
            Gets or sets the stake modifier v2.
            </summary>
            <value>
            The stake modifier v2.
            </value>
            <remarks>This property is used only in memory, it is not persisted to disk not sent over any Payloads.</remarks>
        </member>
        <member name="M:Blockcore.Consensus.BlockInfo.ProvenBlockHeader.ReadWrite(Blockcore.NBitcoin.BitcoinStream)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.BlockInfo.ProvenBlockHeader.ToString">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Consensus.Chain.BlockDataAvailabilityState">
            <summary>
            Represents the availability state of a block.
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.Chain.BlockDataAvailabilityState.HeaderOnly">
            <summary>
            A <see cref="T:Blockcore.Consensus.BlockInfo.BlockHeader"/> is present, the block data is not available.
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.Chain.BlockDataAvailabilityState.BlockRequired">
            <summary>
            We are interested in downloading the <see cref="T:Blockcore.Consensus.BlockInfo.Block"/> that is being represented by the current <see cref="T:Blockcore.Consensus.BlockInfo.BlockHeader"/>.
            This happens when we don't have block which is represented by this header and the header is a part of a chain that
            can potentially replace our consensus tip because its chain work is greater than our consensus tip's chain work.
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.Chain.BlockDataAvailabilityState.BlockAvailable">
            <summary>
            The <see cref="T:Blockcore.Consensus.BlockInfo.Block"/> was downloaded and is available, but it may not be reachable directly but via a store.
            </summary>
        </member>
        <member name="T:Blockcore.Consensus.Chain.ValidationState">
            <summary>
            Represents the validation state of a block.
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.Chain.ValidationState.HeaderValidated">
            <summary>
            We have a valid block header.
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.Chain.ValidationState.PartiallyValidated">
            <summary>
            Validated using all rules that don't require change of state.
            Some validation rules may be skipped for blocks previously marked as assumed valid.
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.Chain.ValidationState.FullyValidated">
            <summary>
            Validated using all the rules.
            Some validation rules may be skipped for blocks previously marked as assumed valid.
            </summary>
        </member>
        <member name="T:Blockcore.Consensus.Chain.ChainedHeader">
            <summary>
            A BlockHeader chained with all its ancestors.
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.Chain.ChainedHeader.pow256">
            <summary>Value of 2^256.</summary>
        </member>
        <member name="F:Blockcore.Consensus.Chain.ChainedHeader.MedianTimeSpan">
            <summary>Window length for calculating median time span.</summary>
        </member>
        <member name="P:Blockcore.Consensus.Chain.ChainedHeader.HashBlock">
            <summary>The hash of the block which is also known as the block id.</summary>
        </member>
        <member name="P:Blockcore.Consensus.Chain.ChainedHeader.Previous">
            <summary>Predecessor of this block.</summary>
        </member>
        <member name="P:Blockcore.Consensus.Chain.ChainedHeader.Skip">
            <summary>Block to navigate from this block to the next in the skip list.</summary>
        </member>
        <member name="P:Blockcore.Consensus.Chain.ChainedHeader.Height">
            <summary>Height of the entry in the chain. The genesis block has height 0.</summary>
        </member>
        <member name="P:Blockcore.Consensus.Chain.ChainedHeader.ProvenBlockHeader">
            <summary>
            Represents a proof os stake network proven block header.
            </summary>
            <remarks>
            This is used only on POS networks, an should be short lived,
            after consensus the header should be set to null and loaded from proven header store.
            </remarks>
        </member>
        <member name="P:Blockcore.Consensus.Chain.ChainedHeader.ChainWork">
            <summary>Total amount of work in the chain up to and including this block.</summary>
        </member>
        <member name="P:Blockcore.Consensus.Chain.ChainedHeader.BlockDataAvailability">
            <inheritdoc cref="T:Blockcore.Consensus.Chain.BlockDataAvailabilityState" />
        </member>
        <member name="P:Blockcore.Consensus.Chain.ChainedHeader.BlockValidationState">
            <inheritdoc cref="T:Blockcore.Consensus.Chain.ValidationState" />
        </member>
        <member name="P:Blockcore.Consensus.Chain.ChainedHeader.IsReferenceConnected">
            <summary>
            An indicator that the current instance of <see cref="T:Blockcore.Consensus.Chain.ChainedHeader"/> has been disconnected from the previous instance.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.Chain.ChainedHeader.IsAssumedValid">
            <summary>
            Block represented by this header is assumed to be valid and only subset of validation rules should be applied to it.
            This state is used for blocks before the last checkpoint or for blocks that are on the chain of assume valid block.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.Chain.ChainedHeader.Block">
            <summary>A pointer to the block data if available (this can be <c>null</c>), its availability will be represented by <see cref="P:Blockcore.Consensus.Chain.ChainedHeader.BlockDataAvailability"/>.</summary>
        </member>
        <member name="P:Blockcore.Consensus.Chain.ChainedHeader.Next">
            <summary>
            Points to the next <see cref="T:Blockcore.Consensus.Chain.ChainedHeader"/>, if a new branch of the chain is presented there can be more then one <see cref="P:Blockcore.Consensus.Chain.ChainedHeader.Next"/> header.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeader.SetChainStore(Blockcore.Consensus.Chain.IChainStore)">
            <summary>
            Set a different header store to the default <see cref="T:Blockcore.Consensus.Chain.ChainStore"/>, this can be done only on genesis header (height 0).
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeader.#ctor(Blockcore.Consensus.BlockInfo.BlockHeader,Blockcore.NBitcoin.uint256)">
            <summary>
            Constructs a chained header at the start of a chain.
            </summary>
            <param name="header">The header for the block.</param>
            <param name="headerHash">The hash of the block's header.</param>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeader.CalculateChainWork">
            <summary>
            Calculates the total amount of work in the chain up to and including this block.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeader.GetBlockTarget">
            <summary>Calculates the amount of work that this block contributes to the total chain work.</summary>
            <returns>Amount of work.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeader.GetLocator">
            <summary>Gets a <see cref="T:Blockcore.NBitcoin.BlockLocator"/> for this chain entry.</summary>
            <returns>A block locator for this chain entry.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeader.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeader.op_Equality(Blockcore.Consensus.Chain.ChainedHeader,Blockcore.Consensus.Chain.ChainedHeader)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeader.op_Inequality(Blockcore.Consensus.Chain.ChainedHeader,Blockcore.Consensus.Chain.ChainedHeader)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeader.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeader.EnumerateToGenesis">
            <summary>
            Enumerator from this entry in the chain to the genesis block.
            </summary>
            <returns>The enumeration of the chain.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeader.ToString">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeader.FindAncestorOrSelf(Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>
            Finds the ancestor of this entry in the chain that matches the chained header specified.
            </summary>
            <param name="chainedHeader">The chained header to search for.</param>
            <returns>The chained block header or <c>null</c> if can't be found.</returns>
            <remarks>This method compares the hash of the block header at the same height in the current chain
            to verify the correct chained block header has been found.</remarks>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeader.FindAncestorOrSelf(Blockcore.NBitcoin.uint256,System.Int32)">
            <summary>
            Finds the ancestor of this entry in the chain that matches the block hash.
            It will not search lower than the optional height parameter.
            </summary>
            <param name="blockHash">The block hash to search for.</param>
            <param name="height">Optional height to restrict the search to.</param>
            <returns>The ancestor of this chain that matches the block hash, or null if it was not found.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeader.GetNextWorkRequired(Blockcore.Networks.Network)">
            <summary>
            Gets the proof of work target for a potential new block after this entry on the chain.
            </summary>
            <param name="network">The network to get target for.</param>
            <returns>The target proof of work.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeader.GetNextWorkRequired(Blockcore.Consensus.IConsensus)">
            <summary>
            Gets the proof of work target for a potential new block after this entry on the chain.
            </summary>
            <param name="consensus">Consensus rules to use for this computation.</param>
            <returns>The target proof of work.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeader.GetNextWorkRequired(Blockcore.Consensus.BlockInfo.BlockHeader,Blockcore.Networks.Network)">
            <summary>
            Gets the proof of work target for the new block specified.
            </summary>
            <param name="block">The new block to get proof of work for.</param>
            <param name="network">The network to get target for.</param>
            <returns>The target proof of work.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeader.GetNextWorkRequired(Blockcore.Consensus.BlockInfo.BlockHeader,Blockcore.Consensus.IConsensus)">
            <summary>
            Gets the proof of work target for the new block specified.
            </summary>
            <param name="block">The new block to get proof of work for.</param>
            <param name="consensus">Consensus rules to use for this computation.</param>
            <returns>The target proof of work.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeader.GetWorkRequired(Blockcore.Networks.Network)">
            <summary>
            Gets the proof of work target for this entry in the chain.
            </summary>
            <param name="network">The network to get target for.</param>
            <returns>The target proof of work.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeader.GetWorkRequired(Blockcore.Consensus.IConsensus)">
            <summary>
            Gets the proof of work target for this entry in the chain.
            </summary>
            <param name="consensus">Consensus rules to use for this computation.</param>
            <returns>The target proof of work.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeader.GetDifficultyAdjustmentInterval(Blockcore.Consensus.IConsensus)">
            <summary>
            Calculate the difficulty adjustment interval in blocks based on settings defined in <see cref="T:Blockcore.Consensus.IConsensus"/>.
            </summary>
            <returns>The difficulty adjustment interval in blocks.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeader.GetMedianTimePast">
            <summary>
            Calculate the median block time over <see cref="F:Blockcore.Consensus.Chain.ChainedHeader.MedianTimeSpan"/> window from this entry in the chain.
            </summary>
            <returns>The median block time.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeader.Validate(Blockcore.Networks.Network)">
            <summary>
            Check that the header is a valid block header including the work done for PoW blocks.
            </summary>
            <param name="network">The network to verify against.</param>
            <returns><c>true</c> if the header is a valid block header, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeader.Validate(Blockcore.Consensus.IConsensus)">
            <summary>
            Check PoW against consensus and that the blocks connect correctly.
            </summary>
            <param name="consensus">The consensus rules being used.</param>
            <returns><c>true</c> if the header is a valid block header, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeader.CheckProofOfWorkAndTarget(Blockcore.Networks.Network)">
            <summary>
            Verify proof of work of the header of this chain using consensus.
            </summary>
            <param name="network">The network to verify proof of work on.</param>
            <returns>Whether proof of work is valid.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeader.CheckProofOfWorkAndTarget(Blockcore.Consensus.IConsensus)">
            <summary>
            Verify proof of work of the header of this chain using consensus.
            </summary>
            <param name="consensus">Consensus rules to use for this validation.</param>
            <returns>Whether proof of work is valid.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeader.FindFork(Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>
            Find first common block between two chains.
            </summary>
            <param name="block">The tip of the other chain.</param>
            <returns>First common block or <c>null</c>.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeader.GetAncestor(System.Int32)">
            <summary>
            Finds the ancestor of this entry in the chain that matches the block height given.
            <remarks>Note: This uses a skiplist to improve list navigation performance.</remarks>
            </summary>
            <param name="ancestorHeight">The block height to search for.</param>
            <returns>The ancestor of this chain that matches the block height.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeader.ToChainedHeaderArray(Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>
            Select all headers between current header and <paramref name="chainedHeader"/> and add them to an array
            of consecutive headers, both items are included in the array.
            </summary>
            <returns>Array of consecutive headers.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeader.GetSkipHeight(System.Int32)">
            <summary>
            Compute what height to jump back to for the skip block given this height.
            <seealso cref="!:https://github.com/bitcoin/bitcoin/blob/master/src/chain.cpp#L72-L81"/>
            </summary>
            <param name="height">Height to compute skip height for.</param>
            <returns>The height to skip to.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeader.InvertLowestOne(System.Int32)">
            <summary>
            Turn the lowest '1' bit in the binary representation of a number into a '0'.
            </summary>
            <param name="n">Number to invert lowest bit.</param>
            <returns>New number.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeader.SetHeader(Blockcore.Consensus.BlockInfo.ProvenBlockHeader)">
            <summary>
            Replace the <see cref="T:Blockcore.Consensus.BlockInfo.BlockHeader"/> with a new provided header.
            </summary>
            <param name="newHeader">The new header to set.</param>
            <remarks>Use this method very carefully because it could cause race conditions if used at the wrong moment.</remarks>
        </member>
        <member name="T:Blockcore.Consensus.Chain.ChainedHeaderBlock">
            <summary>
            Structure made of a block and its chained header.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.Chain.ChainedHeaderBlock.Block">
            <summary>The block.</summary>
        </member>
        <member name="P:Blockcore.Consensus.Chain.ChainedHeaderBlock.ChainedHeader">
            <summary>Chained header of the <see cref="P:Blockcore.Consensus.Chain.ChainedHeaderBlock.Block"/>.</summary>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderBlock.#ctor(Blockcore.Consensus.BlockInfo.Block,Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>
            Creates instance of <see cref="T:Blockcore.Consensus.Chain.ChainedHeaderBlock" />.
            </summary>
            <param name="block">The block can be <c>null</c>.</param>
            <param name="chainedHeader">Chained header of the <paramref name="block"/>.</param>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderBlock.ToString">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderBlock.SetHeader(Blockcore.Consensus.BlockInfo.ProvenBlockHeader)">
            <summary>
            Update the <see cref="P:Blockcore.Consensus.Chain.ChainedHeaderBlock.ChainedHeader" /> (if not null) with a new provided header.
            </summary>
            <param name="newHeader">The new header to set.</param>
            <remarks>Use this method very carefully because it could cause race conditions if used at the wrong moment.</remarks>
        </member>
        <member name="T:Blockcore.Consensus.Chain.IChainedHeaderTree">
            <summary>
            Tree of chained block headers that are being claimed by the connected peers and the node itself.
            It represents all chains we potentially can sync with.
            </summary>
            <remarks>
            This component is an extension of <see cref="T:Blockcore.Consensus.ConsensusManager"/> and is strongly linked to its functionality, it should never be called outside of CM.
            <para>
            View of the chains that are presented by connected peers might be incomplete because we always
            receive only a chunk of headers claimed by the peer in each message.
            </para>
            <para>
            It is a role of the <see cref="T:Blockcore.Consensus.ConsensusManager"/> to decide which of the presented chains is going to be treated as our best chain.
            <see cref="T:Blockcore.Consensus.Chain.ChainedHeaderTree"/> only advises which chains it might be interesting to download.
            </para>
            <para>
            This class is not thread safe and it the role of the component that uses this class to prevent race conditions.
            </para>
            </remarks>
        </member>
        <member name="P:Blockcore.Consensus.Chain.IChainedHeaderTree.UnconsumedBlocksDataBytes">
            <summary>
            Total size of unconsumed blocks data in bytes.
            It represents amount of memory which is occupied by block data that is waiting to be processed.
            </summary>
            <remarks>
            This value is increased every time a new block is downloaded.
            It's decreased when block header is being disconnected or when consensus tip is changed.
            </remarks>
        </member>
        <member name="P:Blockcore.Consensus.Chain.IChainedHeaderTree.UnconsumedBlocksCount">
            <summary>Total amount of unconsumed blocks.</summary>
        </member>
        <member name="M:Blockcore.Consensus.Chain.IChainedHeaderTree.Initialize(Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>
            Initialize the tree with consensus tip.
            </summary>
            <param name="consensusTip">The consensus tip.</param>
            <exception cref="T:Blockcore.Consensus.ConsensusException">Thrown in case where given <paramref name="consensusTip"/> is on a wrong network.</exception>
        </member>
        <member name="M:Blockcore.Consensus.Chain.IChainedHeaderTree.PeerDisconnected(System.Int32)">
            <summary>
            Remove a peer and the entire branch of the tree that it claims unless the
            headers are part of our consensus chain or are claimed by other peers.
            </summary>
            <param name="networkPeerId">Id of a peer that was disconnected.</param>
        </member>
        <member name="M:Blockcore.Consensus.Chain.IChainedHeaderTree.FullValidationSucceeded(Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>
            Mark a <see cref="T:Blockcore.Consensus.Chain.ChainedHeader"/> as <see cref="F:Blockcore.Consensus.Chain.ValidationState.FullyValidated"/>.
            </summary>
            <param name="chainedHeader">The fully validated header.</param>
        </member>
        <member name="M:Blockcore.Consensus.Chain.IChainedHeaderTree.PartialValidationSucceeded(Blockcore.Consensus.Chain.ChainedHeader,System.Boolean@)">
            <summary>
            Handles situation when partial validation for block data for a given <see cref="T:Blockcore.Consensus.Chain.ChainedHeader"/> was successful.
            </summary>
            <remarks>
            In case partial validation was successful we want to partially validate all the next blocks for which we have block data for.
            <para>
            If block that was just partially validated has more cumulative chainwork than our consensus tip we want to switch our consensus tip to this block.
            </para>
            </remarks>
            <param name="chainedHeader">The chained header.</param>
            <param name="fullValidationRequired"><c>true</c> in case we want to switch our consensus tip to <paramref name="chainedHeader"/>.</param>
            <returns>List of chained header blocks with block data that should be partially validated next. Or <c>null</c> if none should be validated.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.IChainedHeaderTree.PartialOrFullValidationFailed(Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>
            Handles situation when block data was considered to be invalid
            for a given header during the partial or full validation.
            </summary>
            <param name="chainedHeader">Chained header which block data failed the validation.</param>
            <returns>List of peer Ids that were claiming chain that contains an invalid block. Such peers should be banned.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.IChainedHeaderTree.ConsensusTipChanged(Blockcore.Consensus.Chain.ChainedHeader,System.Boolean)">
            <summary>
            Handles situation when consensuses tip was changed.
            </summary>
            <remarks>
            All peers are checked against max reorg violation and if they violate their chain will be reset.
            </remarks>
            <param name="newConsensusTip">The new consensus tip.</param>
            <param name="blockMined">Was the block mined or received from the network.</param>
            <returns>List of peer Ids that violate max reorg rule.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.IChainedHeaderTree.BlockDataDownloaded(Blockcore.Consensus.Chain.ChainedHeader,Blockcore.Consensus.BlockInfo.Block)">
            <summary>
            Handles situation when the block's data is downloaded for a given chained header.
            </summary>
            <param name="chainedHeader">Chained header that represents <paramref name="block"/>.</param>
            <param name="block">Block data.</param>
            <returns><c>true</c> in the case where partial validation is required for the downloaded block, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.IChainedHeaderTree.ConnectNewHeaders(System.Int32,System.Collections.Generic.List{Blockcore.Consensus.BlockInfo.BlockHeader})">
            <summary>
            A new list of headers are presented by a peer, the headers will try to be connected to the tree.
            Blocks associated with headers that are interesting (i.e. represent a chain with greater chainwork than our consensus tip)
            will be requested for download.
            </summary>
            <remarks>
            The headers are assumed to be in consecutive order.
            </remarks>
            <param name="networkPeerId">Id of a peer that presented the headers.</param>
            <param name="headers">The list of headers to connect to the tree.</param>
            <returns>
            Information about which blocks need to be downloaded together with information about which input headers were processed.
            Only headers that we can validate will be processed. The rest of the headers will be submitted later again for processing.
            </returns>
            <exception cref="T:Blockcore.Consensus.ConnectHeaderException">Thrown when first presented header can't be connected to any known chain in the tree.</exception>
            <exception cref="T:Blockcore.Consensus.CheckpointMismatchException">Thrown if checkpointed header doesn't match the checkpoint hash.</exception>
            <exception cref="T:Blockcore.Consensus.ConsensusErrorException">Thrown if header validation failed.</exception>
            <exception cref="T:Blockcore.Consensus.MaxReorgViolationException">Thrown in case maximum reorganization rule is violated.</exception>
        </member>
        <member name="M:Blockcore.Consensus.Chain.IChainedHeaderTree.CreateChainedHeaderOfMinedBlock(Blockcore.Consensus.BlockInfo.Block)">
            <summary>
            Creates the chained header for a new block.
            </summary>
            <param name="block">The block.</param>
            <returns>Newly created and connected chained header for the specified block.</returns>
            <exception cref="T:Blockcore.Consensus.ConsensusErrorException">Thrown if header validation failed.</exception>
        </member>
        <member name="M:Blockcore.Consensus.Chain.IChainedHeaderTree.GetChainedHeaderBlock(Blockcore.NBitcoin.uint256)">
            <summary>
            Get the block and its chained header if it exists.
            If the header is not in the tree <see cref="T:Blockcore.Consensus.Chain.ChainedHeaderBlock"/> will be <c>null</c>, the <see cref="P:Blockcore.Consensus.Chain.ChainedHeaderBlock.Block"/> may also be null.
            </summary>
            <remarks>
            The block can be <c>null</c> when the block data has not yet been downloaded or if the block data has been persisted to the database and removed from the memory.
            </remarks>
            <returns>The block and its chained header (the <see cref="P:Blockcore.Consensus.Chain.ChainedHeaderBlock.Block"/> can be <c>null</c> or the <see cref="T:Blockcore.Consensus.Chain.ChainedHeaderBlock"/> result can be <c>null</c>).</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.IChainedHeaderTree.GetChainedHeader(Blockcore.NBitcoin.uint256)">
            <summary>Get the chained header.</summary>
            <returns>Chained header for specified block hash if it exists, <c>null</c> otherwise.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.IChainedHeaderTree.GetBestPeerTip">
            <summary>Gets tip of the best peer.</summary>
            <returns>Tip of the best peer or <c>null</c> if there are no peers.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.IChainedHeaderTree.BlockRewinded(Blockcore.Consensus.Chain.ChainedHeaderBlock)">
            <summary>
            Whenever a block is rewinded we set that block as unconsumed.
            </summary>
            <param name="disconnectedBlock">The disconnected block to set as unconsumed.</param>
        </member>
        <member name="T:Blockcore.Consensus.Chain.ChainedHeaderTree">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Consensus.Chain.ChainedHeaderTree.UnconsumedBlocksDataBytes">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Consensus.Chain.ChainedHeaderTree.UnconsumedBlocksCount">
            <inheritdoc />
        </member>
        <member name="F:Blockcore.Consensus.Chain.ChainedHeaderTree.LocalPeerId">
            <summary>A special peer identifier that represents our local node.</summary>
        </member>
        <member name="F:Blockcore.Consensus.Chain.ChainedHeaderTree.KeepBlockDataForLastBlocks">
            <summary>Specifies for how many blocks from the consensus tip the block data should be kept in the memory.</summary>
            <remarks>
            TODO: calculate the actual value based on the max block size. Set threshold in bytes. Make it configurable.
            </remarks>
        </member>
        <member name="F:Blockcore.Consensus.Chain.ChainedHeaderTree.peerIdsByTipHash">
            <summary>Lists of peer identifiers mapped by hashes of the block headers that are considered to be their tips.</summary>
            <remarks>
            During the consensus tip changing process, which includes both the reorganization and advancement on the same chain,
            it happens that there are two entries for <see cref="F:Blockcore.Consensus.Chain.ChainedHeaderTree.LocalPeerId"/>. This means that two different blocks are being
            claimed by our node as its tip. This is necessary in order to protect the new consensus tip candidate from being
            removed in case peers that were claiming it disconnect during the consensus tip changing process.
            <para>
            All the leafs of the tree have to be tips of chains presented by peers, which means that
            hashes of the leaf block headers have to be keys with non-empty values in this dictionary.
            </para>
            </remarks>
        </member>
        <member name="F:Blockcore.Consensus.Chain.ChainedHeaderTree.peerTipsByPeerId">
            <summary>A list of peer identifiers that are mapped to their tips.</summary>
        </member>
        <member name="F:Blockcore.Consensus.Chain.ChainedHeaderTree.chainedHeadersByHash">
            <summary>
            Chained headers mapped by their hashes.
            Every chained header that is connected to the tree has to have its hash in this dictionary.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderTree.Initialize(Blockcore.Consensus.Chain.ChainedHeader)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderTree.GetChainedHeaderBlock(Blockcore.NBitcoin.uint256)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderTree.GetChainedHeader(Blockcore.NBitcoin.uint256)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderTree.GetConsensusTip">
            <summary>Gets the consensus tip.</summary>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderTree.PeerDisconnected(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderTree.FullValidationSucceeded(Blockcore.Consensus.Chain.ChainedHeader)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderTree.PartialValidationSucceeded(Blockcore.Consensus.Chain.ChainedHeader,System.Boolean@)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderTree.ClaimPeerTip(System.Int32,Blockcore.NBitcoin.uint256)">
            <summary>Sets the tip claim for a peer.</summary>
            <param name="networkPeerId">Peer Id.</param>
            <param name="tipHash">Tip's hash.</param>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderTree.PartialOrFullValidationFailed(Blockcore.Consensus.Chain.ChainedHeader)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderTree.ConsensusTipChanged(Blockcore.Consensus.Chain.ChainedHeader,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderTree.FindPeersToResync(Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>Checks each peer's tip if it violates max reorg rule.
            Peers that violate it must be resynced.</summary>
            <param name="consensusTip">Consensus tip.</param>
            <returns>List of peers which tips violate max reorg rule.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderTree.FindForkIfChainedHeadersNotOnSameChain(Blockcore.Consensus.Chain.ChainedHeader,Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>Find the fork between two headers and return the fork if the headers are not on the same chain.</summary>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderTree.CleanOldBlockDataFromMemory(Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>Cleans the block data for chained headers that are old. This data will still exist in the block store if it is enabled.</summary>
            <param name="consensusTip">Consensus tip.</param>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderTree.RemoveSubtree(Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>
            Remove all the branches in the tree that are after the given <paramref name="subtreeRoot"/>
            including it and return all the peers that where claiming next headers.
            </summary>
            <param name="subtreeRoot">The chained header to start from.</param>
            <returns>List of peer Ids that were claiming headers on removed chains. Such peers should be banned.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderTree.BlockDataDownloaded(Blockcore.Consensus.Chain.ChainedHeader,Blockcore.Consensus.BlockInfo.Block)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderTree.ConnectNewHeaders(System.Int32,System.Collections.Generic.List{Blockcore.Consensus.BlockInfo.BlockHeader})">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderTree.MarkBetterChainAsRequired(Blockcore.Consensus.Chain.ChainedHeader,Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>
            A chain with more work than our current consensus tip was found so mark all it's descendants as required.
            </summary>
            <param name="lastRequiredHeader">Last header that should be required for download.</param>
            <param name="lastNewHeader">Last new header that was created.</param>
            <returns>The new headers that need to be downloaded.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderTree.MarkTrustedChainAsAssumedValid(Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>
            Mark the chain ending with <paramref name="chainedHeader"/> as assumed to be valid.
            </summary>
            <param name="chainedHeader">Last <see cref="T:Blockcore.Consensus.Chain.ChainedHeader"/> to be marked as assumed valid.</param>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderTree.HandleAssumedValidHeader(Blockcore.Consensus.Chain.ChainedHeader,Blockcore.Consensus.Chain.ChainedHeader,System.Boolean)">
            <summary>
            The header is assumed to be valid, the header and all of its previous headers will be marked as assumed valid.
            If the header's cumulative work is better then <see cref="P:Blockcore.Base.IChainState.ConsensusTip" /> the header and all its predecessors will be marked with <see cref="F:Blockcore.Consensus.Chain.BlockDataAvailabilityState.BlockRequired" />.
            </summary>
            <param name="assumedValidHeader">The header that is assumed to be valid.</param>
            <param name="latestNewHeader">The last header in the list of presented new headers.</param>
            <param name="isBelowLastCheckpoint">Set to <c>true</c> if <paramref name="assumedValidHeader"/> is below the last checkpoint,
            <c>false</c> otherwise or if checkpoints are disabled.</param>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderTree.HandleCheckpointsHeader(Blockcore.Consensus.Chain.ChainedHeader,Blockcore.Consensus.Chain.ChainedHeader,Blockcore.Consensus.Checkpoints.CheckpointInfo,System.Int32)">
            <summary>
            When a header is checkpointed and has a correct hash, chain that ends with such a header
            will be marked as assumed valid and requested for download.
            </summary>
            <param name="chainedHeader">Checkpointed header.</param>
            <param name="latestNewHeader">The latest new header that was presented by the peer.</param>
            <param name="checkpoint">Information about the checkpoint at the height of the <paramref name="chainedHeader" />.</param>
            <param name="peerId">Peer Id that presented chain which contains checkpointed header.</param>
            <exception cref="T:Blockcore.Consensus.CheckpointMismatchException">Thrown if checkpointed header doesn't match the checkpoint hash.</exception>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderTree.HeaderWasRequested(Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>
            Check whether a header is in one of the following states
            <see cref="F:Blockcore.Consensus.Chain.BlockDataAvailabilityState.BlockAvailable"/>, <see cref="F:Blockcore.Consensus.Chain.BlockDataAvailabilityState.BlockRequired"/>.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderTree.HeaderWasMarkedAsValidated(Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>
            Check whether a header is in one of the following states: <see cref="F:Blockcore.Consensus.Chain.ValidationState.PartiallyValidated"/>, <see cref="F:Blockcore.Consensus.Chain.ValidationState.FullyValidated"/>
            or is assumed to be valid.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderTree.RemoveUnclaimedBranch(Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>
            Remove the branch of the given <see cref="!:chainedHeader"/> from the tree that is not claimed by any peer .
            </summary>
            <param name="chainedHeader">The chained header that is the top of the branch.</param>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderTree.RemovePeerClaim(System.Int32,Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>
            Remove the peer's tip and all the headers claimed by this peer unless they are also claimed by other peers.
            </summary>
            <param name="networkPeerId">The peer id that is removed.</param>
            <param name="chainedHeader">The header where we start walking back the chain from.</param>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderTree.AddOrReplacePeerTip(System.Int32,Blockcore.NBitcoin.uint256)">
            <summary>Set a new header as a tip for this peer and remove the old tip.</summary>
            <remarks>If the old tip is equal to <paramref name="newTip"/> the method does nothing.</remarks>
            <param name="networkPeerId">The peer id that sets a new tip.</param>
            <param name="newTip">The new tip to set.</param>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderTree.CreateChainedHeaderOfMinedBlock(Blockcore.Consensus.BlockInfo.Block)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderTree.CreateNewHeaders(System.Collections.Generic.List{Blockcore.Consensus.BlockInfo.BlockHeader},System.Boolean@)">
            <summary>
            Find the headers that are not part of the tree and try to connect them to an existing chain
            by creating new chained headers and linking them to their previous headers.
            </summary>
            <remarks>
            Header validation is performed on each header.
            It will check if the first header violates maximum reorganization rule.
            <para>When headers are connected the next pointers of their previous headers are updated.</para>
            </remarks>
            <param name="headers">The new headers that should be connected to a chain.</param>
            <param name="insufficientInfo"><c>true</c> if there wasn't enough data to validate even the first header of all presented.</param>
            <returns>A list of newly created chained headers or <c>null</c> if no new headers were found.</returns>
            <exception cref="T:Blockcore.Consensus.MaxReorgViolationException">Thrown in case maximum reorganization rule is violated.</exception>
            <exception cref="T:Blockcore.Consensus.ConnectHeaderException">Thrown if it wasn't possible to connect the first new header.</exception>
            <exception cref="T:Blockcore.Consensus.ConsensusErrorException">Thrown if header validation failed.</exception>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderTree.CreateAndValidateNewChainedHeader(Blockcore.Consensus.BlockInfo.BlockHeader,Blockcore.Consensus.Chain.ChainedHeader,System.Boolean@)">
            <exception cref="T:Blockcore.Consensus.ConsensusErrorException">Thrown if header validation failed.</exception>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderTree.TryFindNewHeaderIndex(System.Collections.Generic.List{Blockcore.Consensus.BlockInfo.BlockHeader},System.Int32@)">
            <summary>
            Find the first header in the given list of <see cref="!:headers"/> that does not exist in <see cref="F:Blockcore.Consensus.Chain.ChainedHeaderTree.chainedHeadersByHash"/>.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderTree.TryFindLastValidatedHeader(System.Collections.Generic.List{Blockcore.Consensus.BlockInfo.BlockHeader},Blockcore.Consensus.Chain.ChainedHeader@)">
            <summary>
            Find the last validated <see cref="T:Blockcore.Consensus.Chain.ChainedHeader"/> header in the given list of <see cref="!:headers"/>.
            </summary>
            <remarks>Headers are supposed to be consecutive and sorted by height</remarks>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderTree.CheckMaxReorgRuleViolated(Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>
            Checks if switching to specified <paramref name="chainedHeader"/> would require rewinding consensus behind the finalized block height.
            </summary>
            <param name="chainedHeader">The header that needs to be checked for reorg.</param>
            <exception cref="T:Blockcore.Consensus.MaxReorgViolationException">Thrown in case maximum reorganization rule is violated.</exception>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderTree.GetBestPeerTip">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainedHeaderTree.BlockRewinded(Blockcore.Consensus.Chain.ChainedHeaderBlock)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Consensus.Chain.ConnectNewHeadersResult">
            <summary>
            Represents the result of the <see cref="M:Blockcore.Consensus.Chain.ChainedHeaderTree.ConnectNewHeaders(System.Int32,System.Collections.Generic.List{Blockcore.Consensus.BlockInfo.BlockHeader})"/> method.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.Chain.ConnectNewHeadersResult.DownloadFrom">
            <summary>The earliest header in the chain of the list of headers we are interested in downloading.</summary>
        </member>
        <member name="P:Blockcore.Consensus.Chain.ConnectNewHeadersResult.DownloadTo">
            <summary>The latest header in the chain of the list of headers we are interested in downloading.</summary>
        </member>
        <member name="P:Blockcore.Consensus.Chain.ConnectNewHeadersResult.Consumed">
            <summary>Represents the last processed header from the headers presented by the peer.</summary>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ConnectNewHeadersResult.ToString">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.Chain.ConnectNewHeadersResult.ToArray">
            <summary>
            Convert the <see cref="P:Blockcore.Consensus.Chain.ConnectNewHeadersResult.DownloadFrom" /> and <see cref="P:Blockcore.Consensus.Chain.ConnectNewHeadersResult.DownloadTo" /> to an array
            of consecutive headers, both items are included in the array.
            </summary>
            <returns>Array of consecutive headers.</returns>
        </member>
        <member name="T:Blockcore.Consensus.Chain.ChainIndexer">
            <summary>
            An indexer that provides methods to query the best chain (the chain that is validated by the full consensus rules)
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.Chain.ChainIndexer.lockObject">
            <summary>Locks access to <see cref="F:Blockcore.Consensus.Chain.ChainIndexer.blocksByHeight"/>, <see cref="F:Blockcore.Consensus.Chain.ChainIndexer.blocksById"/>.</summary>
        </member>
        <member name="F:Blockcore.Consensus.Chain.ChainIndexer.blocksByHeight">
            <remarks>This object has to be protected by <see cref="F:Blockcore.Consensus.Chain.ChainIndexer.lockObject"/>.</remarks>
        </member>
        <member name="F:Blockcore.Consensus.Chain.ChainIndexer.blocksById">
            <remarks>This object has to be protected by <see cref="F:Blockcore.Consensus.Chain.ChainIndexer.lockObject"/>.</remarks>
        </member>
        <member name="P:Blockcore.Consensus.Chain.ChainIndexer.Tip">
            <summary>
            The tip of the best known validated chain.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.Chain.ChainIndexer.Height">
            <summary>
            The tip height of the best known validated chain.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainIndexer.FindFork(System.Collections.Generic.IEnumerable{Blockcore.NBitcoin.uint256})">
            <summary>
            Returns the first chained block header that exists in the chain from the list of block hashes.
            </summary>
            <param name="hashes">Hash to search for.</param>
            <returns>First found chained block header or <c>null</c> if not found.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainIndexer.FindFork(Blockcore.NBitcoin.BlockLocator)">
            <summary>
            Finds the first chained block header that exists in the chain from the block locator.
            </summary>
            <param name="locator">The block locator.</param>
            <returns>The first chained block header that exists in the chain from the block locator.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainIndexer.EnumerateAfter(Blockcore.NBitcoin.uint256)">
            <summary>
            Enumerate chain block headers after given block hash to genesis block.
            </summary>
            <param name="blockHash">Block hash to enumerate after.</param>
            <returns>Enumeration of chained block headers after given block hash.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainIndexer.EnumerateToTip(Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>
            Enumerates chain block headers from the given chained block header to tip.
            </summary>
            <param name="block">Chained block header to enumerate from.</param>
            <returns>Enumeration of chained block headers from given chained block header to tip.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainIndexer.EnumerateToTip(Blockcore.NBitcoin.uint256)">
            <summary>
            Enumerates chain block headers from given block hash to tip.
            </summary>
            <param name="blockHash">Block hash to enumerate from.</param>
            <returns>Enumeration of chained block headers from the given block hash to tip.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainIndexer.EnumerateAfter(Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>
            Enumerates chain block headers after the given chained block header to genesis block.
            </summary>
            <param name="block">The chained block header to enumerate after.</param>
            <returns>Enumeration of chained block headers after the given block.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainIndexer.Add(Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>
            TODO: Make this internal when the component moves to Blockcore
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainIndexer.Remove(Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>
            TODO: Make this internal when the component moves to Blockcore
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainIndexer.GetHeader(Blockcore.NBitcoin.uint256)">
            <summary>
            Get a <see cref="T:Blockcore.Consensus.Chain.ChainedHeader"/> based on it's hash.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainIndexer.GetHeader(System.Int32)">
            <summary>
            Get a <see cref="T:Blockcore.Consensus.Chain.ChainedHeader"/> based on it's height.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.Chain.ChainIndexer.Item(System.Int32)">
            <summary>
            Get a <see cref="T:Blockcore.Consensus.Chain.ChainedHeader"/> based on it's height.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.Chain.ChainIndexer.Item(Blockcore.NBitcoin.uint256)">
            <summary>
            Get a <see cref="T:Blockcore.Consensus.Chain.ChainedHeader"/> based on it's hash.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.Chain.IChainRepository.LoadAsync(Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>Loads the chain of headers from the database.</summary>
            <returns>Tip of the loaded chain.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Chain.IChainRepository.SaveAsync(Blockcore.Consensus.Chain.ChainIndexer)">
            <summary>Persists chain of headers to the database.</summary>
        </member>
        <member name="F:Blockcore.Consensus.Chain.ChainRepository.logger">
            <summary>Instance logger.</summary>
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainRepository.LoadAsync(Blockcore.Consensus.Chain.ChainedHeader)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainRepository.SaveAsync(Blockcore.Consensus.Chain.ChainIndexer)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.Chain.ChainRepository.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Consensus.Checkpoints.CheckpointInfo">
            <summary>
            Description of checkpointed block.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.Checkpoints.CheckpointInfo.Hash">
            <summary>Hash of the checkpointed block header.</summary>
        </member>
        <member name="P:Blockcore.Consensus.Checkpoints.CheckpointInfo.StakeModifierV2">
            <summary>Stake modifier V2 value of the checkpointed block.</summary>
            <remarks>Stratis only.</remarks>
        </member>
        <member name="M:Blockcore.Consensus.Checkpoints.CheckpointInfo.#ctor(Blockcore.NBitcoin.uint256,Blockcore.NBitcoin.uint256)">
            <summary>
            Initializes a new instance of the object.
            </summary>
            <param name="hash">Hash of the checkpointed block header.</param>
            <param name="stakeModifierV2">Stake modifier V2 value of the checkpointed block. Stratis network only.</param>
        </member>
        <member name="T:Blockcore.Consensus.Checkpoints.ICheckpoints">
            <summary>
            Interface of block header hash checkpoint provider.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.Checkpoints.ICheckpoints.LastCheckpointHeight">
            <summary>
            Obtains a height of the last checkpointed block.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.Checkpoints.ICheckpoints.GetLastCheckpointHeight">
            <summary>
            Obtains a height of the last checkpointed block.
            </summary>
            <returns>Height of the last checkpointed block, or 0 if no checkpoint is available.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Checkpoints.ICheckpoints.CheckHardened(System.Int32,Blockcore.NBitcoin.uint256)">
            <summary>
            Checks if a block header hash at specific height is in violation with the hardcoded checkpoints.
            </summary>
            <param name="height">Height of the block.</param>
            <param name="hash">Block header hash to check.</param>
            <returns>
            <c>true</c> if either there is no checkpoint for the given height, or if the checkpointed block header hash equals
            to the checked <paramref name="hash"/>. <c>false</c> if there is a checkpoint for the given <paramref name="height"/>,
            but the checkpointed block header hash is not the same as the checked <paramref name="hash"/>.
            </returns>
        </member>
        <member name="M:Blockcore.Consensus.Checkpoints.ICheckpoints.GetCheckpoint(System.Int32)">
            <summary>
            Retrieves checkpoint for a block at given height.
            </summary>
            <param name="height">Height of the block.</param>
            <returns>Checkpoint information or <c>null</c> if a checkpoint does not exist for given <paramref name="height"/>.</returns>
        </member>
        <member name="T:Blockcore.Consensus.Checkpoints.Checkpoints">
            <summary>
            Checkpoints is a mechanism on how to avoid validation of historic blocks for which there
            already is a consensus on the network. This allows speeding up IBD, especially on POS networks.
            </summary>
            <remarks>
            From https://github.com/bitcoin/bitcoin/blob/b1973d6181eacfaaf45effb67e0c449ea3a436b8/src/chainparams.cpp#L66 :
            What makes a good checkpoint block? It is surrounded by blocks with reasonable timestamps
            (no blocks before with a timestamp after, none after with timestamp before). It also contains
            no strange transactions.
            </remarks>
        </member>
        <member name="F:Blockcore.Consensus.Checkpoints.Checkpoints.network">
            <summary>The current network. </summary>
        </member>
        <member name="F:Blockcore.Consensus.Checkpoints.Checkpoints.consensusSettings">
            <summary>Consensus settings for the full node.</summary>
        </member>
        <member name="M:Blockcore.Consensus.Checkpoints.Checkpoints.#ctor">
            <summary>
            Initializes a new instance of the object.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.Checkpoints.Checkpoints.#ctor(Blockcore.Networks.Network,Blockcore.Configuration.Settings.ConsensusSettings)">
            <summary>
            Initializes a new instance of the object.
            </summary>
            <param name="network">Specification of the network the node runs on - regtest/testnet/mainnet/stratis test/main.</param>
            <param name="consensusSettings">Consensus settings for node - used to see if checkpoints have been disabled or not.</param>
        </member>
        <member name="M:Blockcore.Consensus.Checkpoints.Checkpoints.GetLastCheckpointHeight">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.Checkpoints.Checkpoints.GetLastCheckpoint(System.Int32@)">
            <summary>
            Gets the last checkpoint.
            </summary>
            <returns>Last <see cref="T:Blockcore.Consensus.Checkpoints.CheckpointInfo"/> or null.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Checkpoints.Checkpoints.CheckHardened(System.Int32,Blockcore.NBitcoin.uint256)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.Checkpoints.Checkpoints.GetCheckpoint(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Consensus.Consensus.CoinbaseMaturity">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Consensus.Consensus.PremineReward">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Consensus.Consensus.PremineHeight">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Consensus.Consensus.ProofOfWorkReward">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Consensus.Consensus.ProofOfStakeReward">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Consensus.Consensus.MaxReorgLength">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Consensus.Consensus.MaxMoney">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Consensus.Consensus.PosNoRetargeting">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Consensus.Consensus.PowNoRetargeting">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Consensus.Consensus.MinimumChainWork">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Consensus.Consensus.CoinType">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Consensus.Consensus.LastPOWBlock">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Consensus.Consensus.IsProofOfStake">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Consensus.Consensus.PosEmptyCoinbase">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Consensus.Consensus.PosUseTimeFieldInKernalHash">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Consensus.Consensus.ProofOfStakeTimestampMask">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Consensus.Consensus.DefaultAssumeValid">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Consensus.Consensus.ConsensusFactory">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Consensus.Consensus.ConsensusRules">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Consensus.Consensus.MempoolRules">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Consensus.ConsensusErrorException">
            <summary>
            An exception that is used when consensus breaking errors are found.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusErrorException.#ctor(Blockcore.Consensus.ConsensusError)">
            <summary>
            Initialize a new instance of <see cref="T:Blockcore.Consensus.ConsensusErrorException"/>.
            </summary>
            <param name="error">The error that triggered this exception.</param>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusErrorException.ConsensusError">
            <summary>The error that triggered this exception. </summary>
        </member>
        <member name="T:Blockcore.Consensus.ConsensusError">
            <summary>
            A consensus error that is used to specify different types of reasons a block does not confirm to the consensus rules.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusError.Code">
            <summary>
            The code representing this consensus error.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusError.Message">
            <summary>
            A user friendly message to describe this error.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusError.Throw">
            <summary>
            A method that will throw a <see cref="T:Blockcore.Consensus.ConsensusErrorException"/> with the current consensus error.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusError.#ctor(System.String,System.String)">
            <summary>
            Initialize a new instance of <see cref="T:Blockcore.Consensus.ConsensusErrorException"/>.
            </summary>
            <param name="code">The error code that represents the current consensus breaking error.</param>
            <param name="message">A user friendly message to describe this error.</param>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusError.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.ConsensusError.op_Equality(Blockcore.Consensus.ConsensusError,Blockcore.Consensus.ConsensusError)">
            <summary>
            Compare two instances of <see cref="T:Blockcore.Consensus.ConsensusError"/> are the same.
            </summary>
            <param name="a">first instance to compare.</param>
            <param name="b">Second instance to compare.</param>
            <returns><c>true</c> if bother instances are the same.</returns>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusError.op_Inequality(Blockcore.Consensus.ConsensusError,Blockcore.Consensus.ConsensusError)">
            <summary>
            Compare two instances of <see cref="T:Blockcore.Consensus.ConsensusError"/> are not the same.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusError.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.ConsensusError.ToString">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Consensus.ConsensusErrors">
            <summary>
            A class that holds consensus errors.
            </summary>
        </member>
        <member name="T:Blockcore.Consensus.HeaderInvalidException">
            <summary>
            This throws when the header of a previously block that failed
            partial or full validation and was marked as invalid is passed to the node.
            </summary>
        </member>
        <member name="T:Blockcore.Consensus.ConsensusRuleException">
            <summary>
            An exception that is contains exception coming from the <see cref="T:Blockcore.Consensus.IConsensusRuleEngine"/> execution.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.IntegrityValidationFailedException.PeerEndPoint">
            <summary>The peer this block came from.</summary>
        </member>
        <member name="P:Blockcore.Consensus.IntegrityValidationFailedException.Error">
            <summary>Consensus error.</summary>
        </member>
        <member name="P:Blockcore.Consensus.IntegrityValidationFailedException.BanDurationSeconds">
            <summary>Time for which peer should be banned.</summary>
        </member>
        <member name="T:Blockcore.Consensus.ConsensusFactory">
            <summary>
            A factory to create protocol types.
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.ConsensusFactory.blockHeaderType">
            <summary>
            The <see cref="T:Blockcore.Consensus.BlockInfo.BlockHeader"/> type.
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.ConsensusFactory.blockType">
            <summary>
            The <see cref="T:Blockcore.Consensus.BlockInfo.Block"/> type.
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.ConsensusFactory.transactionType">
            <summary>
            The <see cref="T:Blockcore.Consensus.TransactionInfo.Transaction"/> type.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusFactory.IsBlockHeader``1">
            <summary>
            Check if the generic type is assignable from <see cref="T:Blockcore.Consensus.BlockInfo.BlockHeader"/>.
            </summary>
            <typeparam name="T">The type to check if it is IsAssignable from <see cref="T:Blockcore.Consensus.BlockInfo.BlockHeader"/>.</typeparam>
            <returns><c>true</c> if it is assignable.</returns>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusFactory.IsBlock``1">
            <summary>
            Check if the generic type is assignable from <see cref="T:Blockcore.Consensus.BlockInfo.Block"/>.
            </summary>
            <typeparam name="T">The type to check if it is IsAssignable from <see cref="T:Blockcore.Consensus.BlockInfo.Block"/>.</typeparam>
            <returns><c>true</c> if it is assignable.</returns>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusFactory.IsTransaction``1">
            <summary>
            Check if the generic type is assignable from <see cref="T:Blockcore.Consensus.TransactionInfo.Transaction"/>.
            </summary>
            <typeparam name="T">The type to check if it is IsAssignable from <see cref="T:Blockcore.Consensus.TransactionInfo.Transaction"/>.</typeparam>
            <returns><c>true</c> if it is assignable.</returns>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusFactory.TryCreateNew``1">
            <summary>
            A method that will try to resolve a type and determine weather its part of the factory types.
            </summary>
            <typeparam name="T">The generic type to resolve.</typeparam>
            <param name="result">If the type is known it will be initialized.</param>
            <returns><c>true</c> if it is known.</returns>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusFactory.CreateBlock">
            <summary>
            Create a <see cref="T:Blockcore.Consensus.BlockInfo.Block"/> instance.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusFactory.CreateBlockHeader">
            <summary>
            Create a <see cref="T:Blockcore.Consensus.BlockInfo.BlockHeader"/> instance.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusFactory.CreateTransaction">
            <summary>
            Create a <see cref="T:Blockcore.Consensus.TransactionInfo.Transaction"/> instance.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusFactory.CreateTransaction(System.String)">
            <summary>
            Create a <see cref="T:Blockcore.Consensus.TransactionInfo.Transaction"/> instance from a hex string representation.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusFactory.CreateTransaction(System.Byte[])">
            <summary>
            Create a <see cref="T:Blockcore.Consensus.TransactionInfo.Transaction"/> instance from a byte array representation.
            </summary>
        </member>
        <member name="T:Blockcore.Consensus.ConsensusManager">
            <inheritdoc cref="T:Blockcore.Consensus.IConsensusManager"/>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusManager.maxUnconsumedBlocksDataBytes">
            <summary>
            Maximum memory in bytes that can be taken by the blocks that were downloaded but
            not yet validated or included to the consensus chain.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusManager.ConsumptionThresholdBytes">
            <summary>Queue consumption threshold in bytes.</summary>
            <remarks><see cref="F:Blockcore.Consensus.ConsensusManager.toDownloadQueue"/> consumption will start if only we have more than this value of free memory.</remarks>
        </member>
        <member name="F:Blockcore.Consensus.ConsensusManager.MaxBlocksToAskFromPuller">
            <summary>The maximum amount of blocks that can be assigned to <see cref="T:Blockcore.BlockPulling.IBlockPuller"/> at the same time.</summary>
        </member>
        <member name="F:Blockcore.Consensus.ConsensusManager.MaxUnconsumedBlocksCount">
            <summary>The maximum amount of blocks that the <see cref="P:Blockcore.Consensus.Chain.IChainedHeaderTree.UnconsumedBlocksCount"/> can store.</summary>
        </member>
        <member name="F:Blockcore.Consensus.ConsensusManager.ConsumptionThresholdSlots">
            <summary>The minimum amount of slots that should be available to trigger asking block puller for blocks.</summary>
        </member>
        <member name="F:Blockcore.Consensus.ConsensusManager.ConsensusIsConsideredToBeSyncedMargin">
            <summary>The amount of blocks from consensus the node is considered to be synced.</summary>
        </member>
        <member name="F:Blockcore.Consensus.ConsensusManager.chainedHeaderTree">
            <remarks>All access should be protected by <see cref="F:Blockcore.Consensus.ConsensusManager.peerLock"/>.</remarks>
        </member>
        <member name="F:Blockcore.Consensus.ConsensusManager.blockPuller">
            <remarks>All access should be protected by <see cref="F:Blockcore.Consensus.ConsensusManager.peerLock"/>.</remarks>
        </member>
        <member name="F:Blockcore.Consensus.ConsensusManager.connectionManager">
            <summary>Connection manager of all the currently connected peers.</summary>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusManager.Tip">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Consensus.ConsensusManager.ConsensusRules">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Consensus.ConsensusManager.DownloadedCallbacks">
            <summary>
            A container of call backs used by the download processes.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusManager.DownloadedCallbacks.ConsensusRequested">
            <summary>The consensus code has requested this block, invoke the method <see cref="M:Blockcore.Consensus.ConsensusManager.ProcessDownloadedBlock(Blockcore.Consensus.Chain.ChainedHeaderBlock)"/> when block is delivered.</summary>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusManager.DownloadedCallbacks.Callbacks">
            <summary>List of delegates to call when block is delivered.</summary>
        </member>
        <member name="F:Blockcore.Consensus.ConsensusManager.callbacksByBlocksRequestedHash">
            <remarks>All access should be protected by <see cref="F:Blockcore.Consensus.ConsensusManager.blockRequestedLock"/>.</remarks>
        </member>
        <member name="F:Blockcore.Consensus.ConsensusManager.peersByPeerId">
            <summary>Peers mapped by their ID.</summary>
            <remarks>This object has to be protected by <see cref="F:Blockcore.Consensus.ConsensusManager.peerLock"/>.</remarks>
        </member>
        <member name="F:Blockcore.Consensus.ConsensusManager.peerLock">
            <summary>Protects access to the <see cref="F:Blockcore.Consensus.ConsensusManager.blockPuller"/>, <see cref="F:Blockcore.Consensus.ConsensusManager.chainedHeaderTree"/>, <see cref="F:Blockcore.Consensus.ConsensusManager.expectedBlockSizes"/> and <see cref="F:Blockcore.Consensus.ConsensusManager.expectedBlockDataBytes"/>.</summary>
        </member>
        <member name="F:Blockcore.Consensus.ConsensusManager.expectedBlockDataBytes">
            <remarks>All access should be protected by <see cref="F:Blockcore.Consensus.ConsensusManager.peerLock"/>.</remarks>
        </member>
        <member name="F:Blockcore.Consensus.ConsensusManager.expectedBlockSizes">
            <remarks>All access should be protected by <see cref="F:Blockcore.Consensus.ConsensusManager.peerLock"/>.</remarks>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManager.InitializeAsync(Blockcore.Consensus.Chain.ChainedHeader)">
            <inheritdoc />
            <remarks>
            If <see cref="F:Blockcore.Consensus.ConsensusManager.blockStore"/> is not <c>null</c> (block store is available) then all block headers in
            <see cref="F:Blockcore.Consensus.ConsensusManager.chainedHeaderTree"/> will be marked as their block data is available.
            If store is not available the <see cref="T:Blockcore.Consensus.ConsensusManager"/> won't be able to serve blocks from disk,
            instead all block requests that are not in memory will be sent to the <see cref="F:Blockcore.Consensus.ConsensusManager.blockPuller"/>.
            </remarks>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManager.HeadersPresented(Blockcore.P2P.Peer.INetworkPeer,System.Collections.Generic.List{Blockcore.Consensus.BlockInfo.BlockHeader},System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManager.PeerDisconnected(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManager.BlockMinedAsync(Blockcore.Consensus.BlockInfo.Block,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManager.PeerDisconnectedLocked(System.Int32)">
            <summary>
            Called after a peer was disconnected.
            Informs underlying components about the event but only if the node is not being shut down at the moment.
            Processes any remaining blocks to download.
            </summary>
            <remarks>Have to be locked by <see cref="F:Blockcore.Consensus.ConsensusManager.peerLock"/>.</remarks>
            <param name="peerId">The peer that was disconnected.</param>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManager.ProcessDownloadedBlock(Blockcore.Consensus.Chain.ChainedHeaderBlock)">
            <summary>
            A callback that is triggered when a block that <see cref="T:Blockcore.Consensus.ConsensusManager"/> requested was downloaded.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManager.OnPartialValidationSucceededAsync(Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>
            Handles a situation when partial validation of a block was successful. Informs CHT about
            finishing partial validation process and starting a new partial validation or full validation.
            </summary>
            <param name="chainedHeader">Header of a block which validation was successful.</param>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManager.NotifyBehaviorsOnConsensusTipChangedAsync">
            <summary>
            Notifies the chained header behaviors of all connected peers when a consensus tip is changed.
            Consumes headers from their caches if there are any.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManager.FullyValidateLockedAsync(Blockcore.Consensus.Chain.ChainedHeader,System.Boolean)">
            <summary>Attempt to switch to new chain, which may require rewinding blocks from the current chain.</summary>
            <remarks>
            It is possible that during connection we find out that blocks that we tried to connect are invalid and we switch back to original chain.
            Should be locked by <see cref="F:Blockcore.Consensus.ConsensusManager.reorgLock"/>.
            </remarks>
            <param name="newTip">Tip of the chain that will become the tip of our consensus chain if full validation will succeed.</param>
            <param name="blockMined">Was the block mined or received from the network.</param>
            <returns>Validation related information.</returns>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManager.RewindToForkPointAsync(Blockcore.Consensus.Chain.ChainedHeader,Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>Rewinds to fork point.</summary>
            <param name="fork">The fork point. It can't be ahead of <paramref name="oldTip"/>.</param>
            <param name="oldTip">The old tip.</param>
            <exception cref="T:Blockcore.Consensus.ConsensusException">Thrown in case <paramref name="fork"/> is ahead of the <paramref name="oldTip"/>.</exception>
            <returns>List of blocks that were disconnected.</returns>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManager.ConnectChainAsync(System.Collections.Generic.List{Blockcore.Consensus.Chain.ChainedHeaderBlock},System.Boolean)">
            <summary>Connects new chain.</summary>
            <param name="blocksToConnect">List of blocks to connect.</param>
            <param name="blockMined">Was the block mined or received from the network.</param>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManager.ReconnectOldChainAsync(System.Collections.Generic.List{Blockcore.Consensus.Chain.ChainedHeaderBlock})">
            <summary>Reconnects the old chain.</summary>
            <param name="blocksToReconnect">List of blocks to reconnect.</param>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManager.ResyncPeersAsync(System.Collections.Generic.List{System.Int32})">
            <summary>
            Informs <see cref="T:Blockcore.Consensus.ConsensusManagerBehavior"/> of each peer
            to be resynced and simulates disconnection of the peer.
            </summary>
            <param name="peerIds">List of peer IDs to resync.</param>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManager.ConnectBlockAsync(Blockcore.Consensus.Chain.ChainedHeaderBlock)">
            <summary>
            Attempts to connect a block to a chain with specified tip.
            </summary>
            <param name="blockToConnect">Block to connect.</param>
            <exception cref="T:Blockcore.Consensus.ConsensusException">Thrown in case CHT is not in a consistent state.</exception>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManager.TryGetBlocksToConnect(Blockcore.Consensus.Chain.ChainedHeader,System.Int32)">
            <summary>Try to find all blocks between two headers.</summary>
            <returns>Collection of blocks that were loaded. In case at least one block was not present <c>null</c> will be returned.</returns>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManager.SetConsensusTip(Blockcore.Consensus.Chain.ChainedHeader,System.Boolean)">
            <summary>Sets the consensus tip.</summary>
            <param name="newTip">New consensus tip.</param>
            <param name="blockMined">Was the block mined or received from the network.</param>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManager.SetConsensusTipInternalLocked(Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>Updates all internal values with the new tip.</summary>
            <remarks>Have to be locked by <see cref="F:Blockcore.Consensus.ConsensusManager.peerLock"/>.</remarks>
            <param name="newTip">New consensus tip.</param>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManager.DownloadBlocks(Blockcore.Consensus.Chain.ChainedHeader[],Blockcore.Consensus.OnBlockDownloadedCallback)">
            <summary>
            Request a list of block headers to download their respective blocks.
            If <paramref name="chainedHeaders"/> is not an array of consecutive headers it will be split to batches of consecutive header requests.
            Callbacks of all entries are added to <see cref="F:Blockcore.Consensus.ConsensusManager.callbacksByBlocksRequestedHash"/>. If a block header was already requested
            to download and not delivered yet, it will not be requested again, instead just it's callback will be called when the block arrives.
            </summary>
            <param name="chainedHeaders">Array of chained headers to download.</param>
            <param name="onBlockDownloadedCallback">A callback to call when the block was downloaded.</param>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManager.BlockDownloaded(Blockcore.NBitcoin.uint256,Blockcore.Consensus.BlockInfo.Block,System.Int32)">
            <summary>Method that is provided as a callback to <see cref="T:Blockcore.BlockPulling.IBlockPuller"/>.</summary>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManager.GetOrDownloadBlocks(System.Collections.Generic.List{Blockcore.NBitcoin.uint256},Blockcore.Consensus.OnBlockDownloadedCallback)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManager.GetBlockData(Blockcore.NBitcoin.uint256)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManager.GetBlockData(System.Collections.Generic.List{Blockcore.NBitcoin.uint256})">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManager.ProcessDownloadQueueLocked">
            <summary>
            Processes items in the <see cref="F:Blockcore.Consensus.ConsensusManager.toDownloadQueue"/> and ask the block puller for blocks to download.
            If the tree has too many unconsumed blocks we will not ask block puller for more until some blocks are consumed.
            </summary>
            <remarks>
            Requests that have too many blocks will be split in batches.
            The amount of blocks in 1 batch to downloaded depends on the average value in <see cref="M:Blockcore.BlockPulling.IBlockPuller.GetAverageBlockSizeBytes"/>.
            Should be protected by the <see cref="F:Blockcore.Consensus.ConsensusManager.peerLock"/>.
            </remarks>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManager.IsConsensusConsideredToBeSyncedLocked(Blockcore.Consensus.Chain.ChainedHeader@)">
            <summary>
            Returns <c>true</c> if consensus' height is within <see cref="F:Blockcore.Consensus.ConsensusManager.ConsensusIsConsideredToBeSyncedMargin"/>
            blocks from the best tip's height.
            </summary>
            <remarks>Should be locked by <see cref="F:Blockcore.Consensus.ConsensusManager.peerLock"/>.</remarks>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManager.FormatBigNumber(System.Int64)">
            <summary>Formats the big number.</summary>
            <remarks><c>123456789</c> => <c>123,456,789</c>.</remarks>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManager.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Consensus.ConsensusManagerBehavior">
            <summary>Behavior that takes care of headers protocol. It also keeps the notion of peer's consensus tip.</summary>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusManagerBehavior.InitialBlockDownloadState">
            <summary>Provider of IBD state.</summary>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusManagerBehavior.ConsensusManager">
            <inheritdoc cref="!:Consensus.ConsensusManager"/>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusManagerBehavior.ChainIndexer">
            <inheritdoc cref="T:Blockcore.Consensus.Chain.ChainIndexer"/>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusManagerBehavior.PeerBanning">
            <inheritdoc cref="T:Blockcore.Connection.IPeerBanning"/>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusManagerBehavior.LoggerFactory">
            <summary>Factory for creating loggers.</summary>
        </member>
        <member name="F:Blockcore.Consensus.ConsensusManagerBehavior.logger">
            <summary>Instance logger.</summary>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusManagerBehavior.BestReceivedTip">
            <summary>
            Our view of the peer's consensus tip constructed on peer's announcement of its tip using "headers" message.
            </summary>
            <remarks>
            The announced tip is accepted if it seems to be valid. Validation is only done on headers and so the announced tip may refer to invalid block.
            </remarks>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusManagerBehavior.BestSentHeader">
            <summary>Gets the best header sent using <see cref="T:Blockcore.P2P.Protocol.Payloads.HeadersPayload"/>.</summary>
            <remarks>Write access should be protected by <see cref="F:Blockcore.Consensus.ConsensusManagerBehavior.bestSentHeaderLock"/>.</remarks>
        </member>
        <member name="F:Blockcore.Consensus.ConsensusManagerBehavior.autosyncTimer">
            <summary>Timer that periodically tries to sync.</summary>
        </member>
        <member name="F:Blockcore.Consensus.ConsensusManagerBehavior.AutosyncIntervalMinutes">
            <summary>Interval in minutes for the <see cref="F:Blockcore.Consensus.ConsensusManagerBehavior.autosyncTimer"/>.</summary>
        </member>
        <member name="F:Blockcore.Consensus.ConsensusManagerBehavior.CacheSyncHeadersThreshold">
            <summary>Amount of headers that should be cached until we stop syncing from the peer.</summary>
        </member>
        <member name="F:Blockcore.Consensus.ConsensusManagerBehavior.MaxItemsPerHeadersMessage">
            <summary>Maximum number of headers in <see cref="T:Blockcore.P2P.Protocol.Payloads.HeadersPayload"/> according to Bitcoin protocol.</summary>
            <seealso cref="!:https://en.bitcoin.it/wiki/Protocol_documentation#getheaders"/>
        </member>
        <member name="F:Blockcore.Consensus.ConsensusManagerBehavior.cachedHeaders">
            <summary>List of block headers that were not yet consumed by <see cref="!:Consensus.ConsensusManager"/>.</summary>
            <remarks>Should be protected by <see cref="F:Blockcore.Consensus.ConsensusManagerBehavior.asyncLock"/>.</remarks>
        </member>
        <member name="F:Blockcore.Consensus.ConsensusManagerBehavior.asyncLock">
            <summary>Protects access to <see cref="F:Blockcore.Consensus.ConsensusManagerBehavior.cachedHeaders"/>.</summary>
        </member>
        <member name="F:Blockcore.Consensus.ConsensusManagerBehavior.bestSentHeaderLock">
            <summary>Protects write access to the <see cref="P:Blockcore.Consensus.ConsensusManagerBehavior.BestSentHeader"/>.</summary>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManagerBehavior.ConsensusTipChangedAsync">
            <summary>Presents cached headers to <see cref="!:Consensus.ConsensusManager"/> from the cache if any and removes consumed from the cache.</summary>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManagerBehavior.CanConsumeCache">
            <summary>Determines whether cached headers (if any) should be pushed to consensus manager for consumption.</summary>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManagerBehavior.OnMessageReceivedAsync(Blockcore.P2P.Peer.INetworkPeer,Blockcore.P2P.Protocol.IncomingMessage)">
            <summary>
            Processes and incoming message from the peer.
            </summary>
            <param name="peer">Peer from which the message was received.</param>
            <param name="message">Received message to process.</param>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManagerBehavior.ProcessGetHeadersAsync(Blockcore.P2P.Peer.INetworkPeer,Blockcore.P2P.Protocol.Payloads.GetHeadersPayload)">
            <summary>
            Processes "getheaders" message received from the peer.
            </summary>
            <param name="peer">Peer from which the message was received.</param>
            <param name="getHeadersPayload">Payload of "getheaders" message to process.</param>
            <remarks>
            "getheaders" message is sent by the peer in response to "headers" message until an empty array is received.
            <para>
            This payload notifies peers of our current best validated height, which is held by consensus tip.
            </para>
            <para>
            If the peer is behind/equal to our best height an empty array is sent back.
            </para>
            </remarks>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManagerBehavior.GetLastHeaderToSend(Blockcore.Consensus.Chain.ChainedHeader,Blockcore.NBitcoin.uint256)">
            <summary>Find last header that should be included in headers payload.</summary>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManagerBehavior.ConstructHeadersPayload(Blockcore.P2P.Protocol.Payloads.GetHeadersPayload,Blockcore.Consensus.Chain.ChainedHeader@)">
            <summary>Constructs the headers from locator to consensus tip.</summary>
            <param name="getHeadersPayload">The <see cref="T:Blockcore.P2P.Protocol.Payloads.GetHeadersPayload"/> payload that triggered the creation of this payload.</param>
            <param name="lastHeader"><see cref="T:Blockcore.Consensus.Chain.ChainedHeader"/> of the last header that was added to the <see cref="T:Blockcore.P2P.Protocol.Payloads.HeadersPayload"/>.</param>
            <returns>Payload with headers from locator towards consensus tip or <c>null</c> in case locator was invalid.</returns>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManagerBehavior.ProcessHeadersAsync(Blockcore.P2P.Peer.INetworkPeer,System.Collections.Generic.List{Blockcore.Consensus.BlockInfo.BlockHeader})">
            <summary>
            Processes "headers" message received from the peer.
            </summary>
            <param name="peer">Peer from which the message was received.</param>
            <param name="headers">List of headers to process.</param>
            <remarks>
            "headers" message is sent in response to "getheaders" message or it is solicited
            by the peer when a new block is validated (unless in IBD).
            <para>
            When we receive "headers" message from the peer, we can adjust our knowledge
            of the peer's view of the chain. We update its pending tip, which represents
            the tip of the best chain we think the peer has.
            </para>
            </remarks>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManagerBehavior.ValidateHeadersFromPayload(Blockcore.P2P.Peer.INetworkPeer,System.Collections.Generic.List{Blockcore.Consensus.BlockInfo.BlockHeader},System.String@)">
            <summary>Validates the headers payload.</summary>
            <param name="peer">The peer who sent the payload.</param>
            <param name="headers">Headers to validate.</param>
            <param name="validationError">The validation error that is set in case <c>false</c> is returned.</param>
            <returns><c>true</c> if payload was valid, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManagerBehavior.PresentHeadersLockedAsync(System.Collections.Generic.List{Blockcore.Consensus.BlockInfo.BlockHeader},System.Boolean)">
            <summary>Presents the headers to <see cref="!:Consensus.ConsensusManager"/> and handles exceptions if any.</summary>
            <remarks>Have to be locked by <see cref="F:Blockcore.Consensus.ConsensusManagerBehavior.asyncLock"/>.</remarks>
            <param name="headers">List of headers that the peer presented.</param>
            <param name="triggerDownload">Specifies if the download should be scheduled for interesting blocks.</param>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManagerBehavior.OnStateChangedAsync(Blockcore.P2P.Peer.INetworkPeer,Blockcore.P2P.Peer.NetworkPeerState)">
            <summary>Sync when handshake is finished.</summary>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManagerBehavior.ResetPeerTipInformationAndSyncAsync">
            <summary>Resets the expected peer tip and last sent tip and triggers synchronization.</summary>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManagerBehavior.UpdateBestSentHeader(Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>Updates the best sent header but only if the new value is better or is on a different chain.</summary>
            <param name="header">The new value to set if it is better or on a different chain.</param>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManagerBehavior.ResyncAsync">
            <summary>Tries to sync the chain with the peer by sending it <see cref="T:Blockcore.P2P.Protocol.Payloads.GetHeadersPayload"/> in case peer's state is <see cref="F:Blockcore.P2P.Peer.NetworkPeerState.HandShaked"/>.</summary>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManagerBehavior.BuildGetHeadersPayload">
            <summary>
            Builds the GetHeadersPayload.
            </summary>
            <returns>The GetHeadersPayload instance. May return <c>null</c>; in such case the sync process wouldn't happen.</returns>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManagerBehavior.ProcessInvAsync(Blockcore.P2P.Peer.INetworkPeer,System.Collections.Generic.List{Blockcore.P2P.Protocol.InventoryVector})">
            <summary>
            Processes "inv" message received from the peer.
            </summary>
            <param name="peer">Peer from which the message was received.</param>
            <param name="inventory">List of inventory vectors to process.</param>
            <remarks>
            The "inv" message is sent unsolicited by legacy nodes to announce new blocks.
            It may contain non-block hashes which should be ignored. We then need to obtain the
            headers of the announced blocks so that the header processing can be performed as
            normal. We do not request the block directly as the peer may be attempting a DoS
            attack by spamming fake inv messages.
            </remarks>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManagerBehavior.AttachCore">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManagerBehavior.DetachCore">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManagerBehavior.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManagerBehavior.Clone">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.ConsensusManagerBehavior.GetConsumedHeadersCount(System.Collections.Generic.List{Blockcore.Consensus.BlockInfo.BlockHeader},Blockcore.Consensus.BlockInfo.BlockHeader)">
            <summary>
            Gets the count of consumed headers in a <paramref name="headers"/> list, giving a <paramref name="consumedHeader"/> reference.
            All items up to <paramref name="consumedHeader"/> are considered consumed.
            </summary>
            <param name="headers">List of headers to use to get the consumed count.</param>
            <param name="consumedHeader">The consumed header reference.</param>
            <returns>The number of consumed cached items.</returns>
        </member>
        <member name="T:Blockcore.Consensus.ConsensusOptions">
            <summary>
            An extension to <see cref="T:Blockcore.Consensus.Consensus"/> to enable additional options to the consensus data.
            TODO: Make immutable.
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.ConsensusOptions.SerializeTransactionNoWitness">
            <summary>
            Flag used to detect SegWit transactions.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusOptions.MaxBlockBaseSize">
            <summary>Maximum size for a block in bytes. </summary>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusOptions.MaxBlockWeight">
            <summary>The maximum allowed weight for a block, see BIP 141 (network rule)</summary>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusOptions.MinBlockFeeRate">
            <summary>Thee minimum fee-rate (fee per kb) a transaction is paying
            in order to be included by the miner when mining a block.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusOptions.MaxBlockSerializedSize">
            <summary>The maximum allowed size for a serialized block, in bytes (only for buffer size limits). </summary>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusOptions.WitnessScaleFactor">
            <summary>Scale of witness vs other transaction data. e.g. if set to 4,
            then witnesses have 1/4 the weight per byte of other transaction data.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusOptions.MaxStandardVersion">
            <summary>
            Changing the default transaction version requires a two step process:
            <list type="bullet">
            <item>Adapting relay policy by bumping <see cref="P:Blockcore.Consensus.ConsensusOptions.MaxStandardVersion"/>,</item>
            <item>and then later date bumping the default CURRENT_VERSION at which point both CURRENT_VERSION and
            <see cref="P:Blockcore.Consensus.ConsensusOptions.MaxStandardVersion"/> will be equal.</item>
            </list>
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusOptions.MaxStandardTxWeight">
            <summary>The maximum weight for transactions we're willing to relay/mine.</summary>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusOptions.MaxBlockSigopsCost">
            <summary>The maximum allowed number of signature check operations in a block (network rule).</summary>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusOptions.MaxStandardTxSigopsCost">
            <summary>The maximum number of sigops we're willing to relay/mine in a single tx.</summary>
            <remarks>
            This value is calculated based on <see cref="P:Blockcore.Consensus.ConsensusOptions.MaxBlockSigopsCost"/> dived by 5.
            </remarks>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusOptions.EnforceMinProtocolVersionAtBlockHeight">
            <summary>Block Height at which the node should enforce the use of <see cref="P:Blockcore.Consensus.ConsensusOptions.EnforcedMinProtocolVersion"/>.
            Can be set to zero to indicate that the minimum supported protocol version will not change depending on the block height.</summary>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusOptions.EnforcedMinProtocolVersion">
            <summary>The minimum protocol version which should be used from block height defined in <see cref="P:Blockcore.Consensus.ConsensusOptions.EnforceMinProtocolVersionAtBlockHeight"/></summary>
        </member>
        <member name="T:Blockcore.Consensus.PosConsensusOptions">
             <summary>
             Extension to ConsensusOptions for PoS-related parameters.
            
             TODO: When moving rules to be part of consensus for network, move this class to the appropriate project too.
             Doesn't make much sense for it to be in NBitcoin. Also remove the CoinstakeMinConfirmation consts and set CointakeMinConfirmation in Network building.
             </summary>
        </member>
        <member name="F:Blockcore.Consensus.PosConsensusOptions.CoinstakeMinConfirmationActivationHeightMainnet">
            <summary>Coinstake minimal confirmations softfork activation height for mainnet.</summary>
        </member>
        <member name="F:Blockcore.Consensus.PosConsensusOptions.CoinstakeMinConfirmationActivationHeightTestnet">
            <summary>Coinstake minimal confirmations softfork activation height for testnet.</summary>
        </member>
        <member name="F:Blockcore.Consensus.PosConsensusOptions.MaxCoinstakeSerializedSize">
            <summary>
            Maximum coinstake serialized size in bytes.
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.PosConsensusOptions.MaxBlockSignatureSerializedSize">
            <summary>
            Maximum signature serialized size in bytes.
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.PosConsensusOptions.MaxMerkleProofSerializedSize">
            <summary>
            Maximum merkle proof serialized size in bytes.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.PosConsensusOptions.GetStakeMinConfirmations(System.Int32,Blockcore.Networks.Network)">
            <summary>
            Gets the minimum confirmations amount required for a coin to be good enough to participate in staking.
            </summary>
            <param name="height">Block height.</param>
            <param name="network">The network.</param>
        </member>
        <member name="T:Blockcore.Consensus.ConsensusRuleEngine">
            <inheritdoc />
        </member>
        <member name="F:Blockcore.Consensus.ConsensusRuleEngine.logger">
            <summary>Instance logger.</summary>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusRuleEngine.LoggerFactory">
            <summary>A factory to creates logger instances for each rule.</summary>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusRuleEngine.Network">
            <summary>Specification of the network the node runs on - regtest/testnet/mainnet.</summary>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusRuleEngine.DateTimeProvider">
            <summary>A provider of date and time.</summary>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusRuleEngine.ChainIndexer">
            <summary>A chain of the longest block headers all the way to genesis.</summary>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusRuleEngine.NodeDeployments">
            <summary>A deployment construction that tracks activation of features on the chain.</summary>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusRuleEngine.ConsensusParams">
            <summary>A collection of consensus constants.</summary>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusRuleEngine.ConsensusSettings">
            <summary>Consensus settings for the full node.</summary>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusRuleEngine.Checkpoints">
            <summary>Provider of block header hash checkpoints.</summary>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusRuleEngine.ChainState">
            <summary>State of the current chain that hold consensus tip.</summary>
        </member>
        <member name="F:Blockcore.Consensus.ConsensusRuleEngine.invalidBlockHashStore">
            <inheritdoc cref="T:Blockcore.Base.IInvalidBlockHashStore"/>
        </member>
        <member name="F:Blockcore.Consensus.ConsensusRuleEngine.performanceCounter">
            <inheritdoc cref="T:Blockcore.Consensus.PerformanceCounters.Rules.ConsensusRulesPerformanceCounter"/>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusRuleEngine.Initialize(Blockcore.Consensus.Chain.ChainedHeader)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.ConsensusRuleEngine.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.ConsensusRuleEngine.SetupRulesEngineParent">
            TODO: this method needs to be deleted once all rules use dependency injection
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.ConsensusRuleEngine.HeaderValidation(Blockcore.Consensus.Chain.ChainedHeader)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusRuleEngine.IntegrityValidation(Blockcore.Consensus.Chain.ChainedHeader,Blockcore.Consensus.BlockInfo.Block)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusRuleEngine.FullValidationAsync(Blockcore.Consensus.Chain.ChainedHeader,Blockcore.Consensus.BlockInfo.Block)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusRuleEngine.PartialValidationAsync(Blockcore.Consensus.Chain.ChainedHeader,Blockcore.Consensus.BlockInfo.Block)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusRuleEngine.HandleConsensusError(Blockcore.Consensus.ValidationContext)">
            <summary>Adds block hash to a list of failed header unless specific consensus error was used that doesn't require block banning.</summary>
        </member>
        <member name="M:Blockcore.Consensus.ConsensusRuleEngine.CreateRuleContext(Blockcore.Consensus.ValidationContext)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.ConsensusRuleEngine.GetBlockHash">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.ConsensusRuleEngine.RewindAsync">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Consensus.RewindState">
            <summary>
            A class that is used to store transitions of state of consensus underline storage.
            </summary>
            <remarks>
            A transition state can have transition information of several consecutive block,
            The <see cref="P:Blockcore.Consensus.RewindState.BlockHash"/> parameter represents the tip of the consecutive list of blocks.
            </remarks>
        </member>
        <member name="P:Blockcore.Consensus.RewindState.BlockHash">
            <summary>
            The block hash that represents the tip of the transition.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.ConsensusRules.HeaderValidationRules">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Consensus.ConsensusRules.IntegrityValidationRules">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Consensus.ConsensusRules.PartialValidationRules">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Consensus.ConsensusRules.FullValidationRules">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.ConsensusRules.Register``1">
            <summary>
            Register a rule of type <see cref="T:Blockcore.Consensus.Rules.IConsensusRuleBase"/>.
            </summary>
        </member>
        <member name="T:Blockcore.Consensus.DefaultConsensusFactory">
            <summary>
            A default object factory to create instances that are not part of the types
            that are created by the <see cref="T:Blockcore.Consensus.ConsensusFactory"/> like block, block header or transaction.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.DefaultConsensusFactory.TryCreateNew``1">
            <inheritdoc/>
        </member>
        <member name="T:Blockcore.Consensus.IFinalizedBlockInfoRepository">
             <summary>Provider of the last finalized block's height and hash.</summary>
             <remarks>
             Finalized block height is the height of the last block that can't be reorged.
             Blocks with height greater than finalized height can be reorged.
             <para>Finalized block height value is always <c>0</c> for blockchains without max reorg property.</para>
            
             The protection finality is to not allow rewinding the node bellow a certain height, whileh MaxReorgProtection does the same
             MaxReorg does not protect from chain with different work. MaxReorg determins the chain by its height
             while rewind uses work as indicator (the chain with most work is the winner),
             this can cause the scenario where a chain with lower height but more work triggeres a reorg and consensus tip ends up in a lower height.
             Now a second rewind can heppen that will go below MaxReorg of the initial hiegher (but lower work) tip,
             for that we need finality, even if such a reorg happens finality will prevent the second reorg that will vioulate MAxReorgProtection.
            
             A - - - - - - - - - - - - - - - - - [current tip]
             B   |    L - - - - -  - - [more work then chain A]
             C   L - - - - - [more work then chain B but violate max reorg]
             </remarks>
        </member>
        <member name="M:Blockcore.Consensus.IFinalizedBlockInfoRepository.GetFinalizedBlockInfo">
            <summary>Gets the finalized block hash and height.</summary>
            <returns>Hash and height of a block that can't be reorged away from.</returns>
        </member>
        <member name="M:Blockcore.Consensus.IFinalizedBlockInfoRepository.LoadFinalizedBlockInfoAsync(Blockcore.Networks.Network)">
            <summary>Loads the finalised block hash and height from the database.</summary>
        </member>
        <member name="M:Blockcore.Consensus.IFinalizedBlockInfoRepository.SaveFinalizedBlockHashAndHeight(Blockcore.NBitcoin.uint256,System.Int32)">
            <summary>Saves the finalized block hash and height to the database if height is greater than the previous value.</summary>
            <param name="hash">Block hash.</param>
            <param name="height">Block height.</param>
            <returns><c>true</c> if new value was set, <c>false</c> if <paramref name="height"/> is lower or equal than current value.</returns>
        </member>
        <member name="F:Blockcore.Consensus.FinalizedBlockInfoRepository.logger">
            <summary>Instance logger.</summary>
        </member>
        <member name="F:Blockcore.Consensus.FinalizedBlockInfoRepository.FinalizedBlockKey">
            <summary>Database key under which the block height of the last finalized block height is stored.</summary>
        </member>
        <member name="F:Blockcore.Consensus.FinalizedBlockInfoRepository.finalizedBlockInfo">
            <summary>Height and hash of a block that can't be reorged away from.</summary>
        </member>
        <member name="F:Blockcore.Consensus.FinalizedBlockInfoRepository.finalizedBlockInfosToSave">
            <summary>Queue of finalized infos to save.</summary>
            <remarks>All access should be protected by <see cref="F:Blockcore.Consensus.FinalizedBlockInfoRepository.queueLock"/>.</remarks>
        </member>
        <member name="F:Blockcore.Consensus.FinalizedBlockInfoRepository.queueLock">
            <summary>Protects access to <see cref="F:Blockcore.Consensus.FinalizedBlockInfoRepository.finalizedBlockInfosToSave"/>.</summary>
        </member>
        <member name="F:Blockcore.Consensus.FinalizedBlockInfoRepository.finalizedBlockInfoPersistingTask">
            <summary>Task that continously persists finalized block info to the database.</summary>
        </member>
        <member name="M:Blockcore.Consensus.FinalizedBlockInfoRepository.GetFinalizedBlockInfo">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.FinalizedBlockInfoRepository.LoadFinalizedBlockInfoAsync(Blockcore.Networks.Network)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.FinalizedBlockInfoRepository.SaveFinalizedBlockHashAndHeight(Blockcore.NBitcoin.uint256,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.FinalizedBlockInfoRepository.Dispose">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Consensus.IConsensus.CoinbaseMaturity">
            <summary>
            How many blocks should be on top of a block that includes a coinbase transaction until its outputs are considered spendable.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.IConsensus.PremineReward">
            <summary>
            Amount of coins mined when a new network is bootstrapped.
            Set to <see cref="P:Blockcore.NBitcoin.Money.Zero"/> when there is no premine.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.IConsensus.PremineHeight">
            <summary>
            The height of the block in which the pre-mined coins should be.
            Set to 0 when there is no premine.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.IConsensus.ProofOfWorkReward">
            <summary>
            The reward that goes to the miner when a block is mined using proof-of-work.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.IConsensus.ProofOfStakeReward">
            <summary>
            The reward that goes to the miner when a block is mined using proof-of-stake.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.IConsensus.MaxReorgLength">
            <summary>
            Maximal length of reorganization that the node is willing to accept, or 0 to disable long reorganization protection.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.IConsensus.MaxMoney">
            <summary>
            The maximum amount of coins in any transaction.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.IConsensus.TargetSpacing">
            <summary>Expected (or target) block time in seconds.</summary>
        </member>
        <member name="P:Blockcore.Consensus.IConsensus.PosNoRetargeting">
            <summary>
            If <c>true</c> disables checking the next block's difficulty (work required) target on a Proof-Of-Stake network.
            <para>
            This can be used in tests to enable fast mining of blocks.
            </para>
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.IConsensus.PowNoRetargeting">
            <summary>
            If <c>true</c> disables checking the next block's difficulty (work required) target on a Proof-Of-Work network.
            <para>
            This can be used in tests to enable fast mining of blocks.
            </para>
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.IConsensus.MinimumChainWork">
            <summary> The minimum amount of work the best chain should have. </summary>
        </member>
        <member name="P:Blockcore.Consensus.IConsensus.CoinType">
            <summary>
            Specify the BIP44 coin type for this network.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.IConsensus.LastPOWBlock">
            <summary>PoW blocks are not accepted after block with height <see cref="P:Blockcore.Consensus.Consensus.LastPOWBlock"/>.</summary>
        </member>
        <member name="P:Blockcore.Consensus.IConsensus.PosEmptyCoinbase">
            <summary>
            This flag will restrict the coinbase in a POS network to be empty.
            For legacy POS the coinbase is required to be empty.
            </summary>
            <remarks>
            Some implementations will put extra data in the coinbase (for example the witness commitment)
            To allow such data to be in the coinbase we use this flag, a POS network that already has that limitation will use the coinbase input instead.
            </remarks>
        </member>
        <member name="P:Blockcore.Consensus.IConsensus.PosUseTimeFieldInKernalHash">
            <summary>
            POSv4 emits the time field from the pos kernal calculations.
            </summary>
            <remarks>
            POSv3 uses a few fields to create enough randomness so that the kernal cannot be guessed in advance.
            The time field of the utxo that found the stake is one of those parameters.
            However POSv4 removes the time form the kernal hash, the prevout utxo provides enough randomness.
            </remarks>
        </member>
        <member name="P:Blockcore.Consensus.IConsensus.ProofOfStakeTimestampMask">
            <summary>A mask for coinstake transaction's timestamp and header's timestamp.</summary>
            <remarks>Used to decrease granularity of timestamp. Supposed to be 2^n-1.</remarks>
        </member>
        <member name="P:Blockcore.Consensus.IConsensus.IsProofOfStake">
            <summary>
            An indicator whether this is a Proof Of Stake network.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.IConsensus.DefaultAssumeValid">
            <summary>The default hash to use for assuming valid blocks.</summary>
        </member>
        <member name="P:Blockcore.Consensus.IConsensus.ConsensusFactory">
            <summary>
            A factory that enables overloading base types.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.IConsensus.ConsensusRules">
            <summary>Group of rules that define a given network.</summary>
        </member>
        <member name="P:Blockcore.Consensus.IConsensus.MempoolRules">
            <summary>Group of mempool validation rules used by the given network.</summary>
        </member>
        <member name="T:Blockcore.Consensus.IConsensusManager">
            <summary>
            TODO add a big nice comment.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.IConsensusManager.Tip">
            <summary>The current tip of the chain that has been validated.</summary>
        </member>
        <member name="P:Blockcore.Consensus.IConsensusManager.ConsensusRules">
            <summary>The collection of rules.</summary>
        </member>
        <member name="M:Blockcore.Consensus.IConsensusManager.InitializeAsync(Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>
            Set the tip of <see cref="T:Blockcore.Consensus.ConsensusManager"/>, if the given <paramref name="chainTip"/> is not equal to <see cref="P:Blockcore.Consensus.IConsensusManager.Tip"/>
            then rewind consensus until a common header is found.
            </summary>
            <param name="chainTip">Last common header between chain repository and block store if it's available,
            if the store is not available it is the chain repository tip.</param>
        </member>
        <member name="M:Blockcore.Consensus.IConsensusManager.HeadersPresented(Blockcore.P2P.Peer.INetworkPeer,System.Collections.Generic.List{Blockcore.Consensus.BlockInfo.BlockHeader},System.Boolean)">
            <summary>
            A list of headers are presented from a given peer,
            we'll attempt to connect the headers to the tree and if new headers are found they will be queued for download.
            </summary>
            <param name="peer">The peer that providing the headers.</param>
            <param name="headers">The list of new headers.</param>
            <param name="triggerDownload">Specifies if the download should be scheduled for interesting blocks.</param>
            <returns>Information about consumed headers.</returns>
            <exception cref="T:Blockcore.Consensus.ConnectHeaderException">Thrown when first presented header can't be connected to any known chain in the tree.</exception>
            <exception cref="T:Blockcore.Consensus.CheckpointMismatchException">Thrown if checkpointed header doesn't match the checkpoint hash.</exception>
            <exception cref="T:Blockcore.Consensus.MaxReorgViolationException">Thrown in case maximum reorganization rule is violated.</exception>
            <exception cref="T:Blockcore.Consensus.ConsensusErrorException">Thrown if header validation failed.</exception>
        </member>
        <member name="M:Blockcore.Consensus.IConsensusManager.PeerDisconnected(System.Int32)">
            <summary>
            Called after a peer was disconnected.
            Informs underlying components about the even.
            Processes any remaining blocks to download.
            </summary>
            <param name="peerId">The peer that was disconnected.</param>
        </member>
        <member name="M:Blockcore.Consensus.IConsensusManager.GetOrDownloadBlocks(System.Collections.Generic.List{Blockcore.NBitcoin.uint256},Blockcore.Consensus.OnBlockDownloadedCallback)">
            <summary>
            Provides block data for the given block hashes.
            </summary>
            <remarks>
            First we check if the block exists in chained header tree, then it check the block store and if it wasn't found there the block will be scheduled for download.
            Given callback is called when the block is obtained. If obtaining the block fails the callback will be called with <c>null</c>.
            </remarks>
            <param name="blockHashes">The block hashes to download.</param>
            <param name="onBlockDownloadedCallback">The callback that will be called for each downloaded block.</param>
        </member>
        <member name="M:Blockcore.Consensus.IConsensusManager.GetBlockData(Blockcore.NBitcoin.uint256)">
            <summary>Loads the block data from <see cref="T:Blockcore.Consensus.Chain.ChainedHeaderTree"/> or block store if it's enabled.</summary>
            <param name="blockHash">The block hash.</param>
        </member>
        <member name="M:Blockcore.Consensus.IConsensusManager.GetBlockData(System.Collections.Generic.List{Blockcore.NBitcoin.uint256})">
            <summary>Loads the block data from <see cref="T:Blockcore.Consensus.Chain.ChainedHeaderTree"/> or block store if it's enabled.</summary>
            <param name="blockHashes">The block hashes.</param>
        </member>
        <member name="M:Blockcore.Consensus.IConsensusManager.BlockMinedAsync(Blockcore.Consensus.BlockInfo.Block,System.Boolean)">
            <summary>
            A new block was mined by the node and is attempted to connect to tip.
            </summary>
            <param name="block">Block that was mined.</param>
            <param name="assumeValid">Assume the block is allready valid and skp validations.</param>
            <exception cref="T:Blockcore.Consensus.ConsensusErrorException">Thrown if header validation failed.</exception>
            <exception cref="T:Blockcore.Consensus.ConsensusException">Thrown if partial or full validation failed or if full validation wasn't required.</exception>
            <returns><see cref="T:Blockcore.Consensus.Chain.ChainedHeader"/> of a block that was mined.</returns>
        </member>
        <member name="T:Blockcore.Consensus.OnBlockDownloadedCallback">
            <summary>
            A delegate that is used to send callbacks when a block is downloaded from the queued requests to downloading blocks.
            </summary>
            <param name="chainedHeaderBlock">The pair of the block and its chained header.</param>
        </member>
        <member name="T:Blockcore.Consensus.IConsensusRuleEngine">
            <summary>
            An engine that enforce the execution and validation of consensus rule.
            </summary>
            <remarks>
            In order for a block to be valid it has to successfully pass the rules checks.
            A block  that is not valid will result in the <see cref="P:Blockcore.Consensus.ValidationContext.Error"/> as not <c>null</c>.
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Blockcore.Consensus.IConsensusRuleEngine.Initialize(Blockcore.Consensus.Chain.ChainedHeader)" -->
        <member name="M:Blockcore.Consensus.IConsensusRuleEngine.SetupRulesEngineParent">
            <summary>
            Register a new rule to the engine
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.IConsensusRuleEngine.GetRule``1">
            <summary>
            Gets the consensus rule that is assignable to the supplied generic type.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.IConsensusRuleEngine.CreateRuleContext(Blockcore.Consensus.ValidationContext)">
            <summary>
            Create an instance of the <see cref="T:Blockcore.Consensus.Rules.RuleContext"/> to be used by consensus validation.
            </summary>
            <remarks>
            Each network type can specify it's own <see cref="T:Blockcore.Consensus.Rules.RuleContext"/>.
            </remarks>
        </member>
        <member name="M:Blockcore.Consensus.IConsensusRuleEngine.GetBlockHash">
            <summary>
            Retrieves the block hash of the current tip of the chain.
            </summary>
            <returns>Block hash of the current tip of the chain.</returns>
        </member>
        <member name="M:Blockcore.Consensus.IConsensusRuleEngine.RewindAsync">
            <summary>
            Rewinds the chain to the last saved state.
            <para>
            This operation includes removing the recent transactions
            and restoring the chain to an earlier state.
            </para>
            </summary>
            <returns>Hash of the block header which is now the tip of the chain.</returns>
        </member>
        <member name="M:Blockcore.Consensus.IConsensusRuleEngine.HeaderValidation(Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>Execute header validation rules.</summary>
            <param name="header">The chained header that is going to be validated.</param>
            <returns>Context that contains validation result related information.</returns>
        </member>
        <member name="M:Blockcore.Consensus.IConsensusRuleEngine.IntegrityValidation(Blockcore.Consensus.Chain.ChainedHeader,Blockcore.Consensus.BlockInfo.Block)">
            <summary>Execute integrity validation rules.</summary>
            <param name="header">The chained header that is going to be validated.</param>
            <param name="block">The block that is going to be validated.</param>
            <returns>Context that contains validation result related information.</returns>
        </member>
        <member name="M:Blockcore.Consensus.IConsensusRuleEngine.PartialValidationAsync(Blockcore.Consensus.Chain.ChainedHeader,Blockcore.Consensus.BlockInfo.Block)">
            <summary>Execute partial validation rules.</summary>
            <param name="header">The chained header that is going to be validated.</param>
            <param name="block">The block that is going to be validated.</param>
            <returns>Context that contains validation result related information.</returns>
        </member>
        <member name="M:Blockcore.Consensus.IConsensusRuleEngine.FullValidationAsync(Blockcore.Consensus.Chain.ChainedHeader,Blockcore.Consensus.BlockInfo.Block)">
            <summary>Execute full validation rules.</summary>
            <param name="header">The chained header that is going to be validated.</param>
            <param name="block">The block that is going to be validated.</param>
            <returns>Context that contains validation result related information.</returns>
        </member>
        <member name="T:Blockcore.Consensus.RateLimitingBehavior">
            <summary>
            Bans and disconnects peers that sends a <see cref="T:Blockcore.P2P.Protocol.Payloads.GetHeadersPayload"/> request, more than <see cref="F:Blockcore.Consensus.RateLimitingBehavior.GetHeaderRequestCountThresholdSeconds"/> times,
            within a certain time frame.
            </summary>
            <remarks>
            TODO:
            This behavior is a tempory work around to peers that spam the node with too many <see cref="T:Blockcore.P2P.Protocol.Payloads.GetHeadersPayload"/> requests.
            It will be changed in the future once a more in-depth and thorough implementation has been agreed upon.
            </remarks>
        </member>
        <member name="F:Blockcore.Consensus.RateLimitingBehavior.BanDurationSeconds">
            <summary>How long the offending peer will be banned for.</summary>
        </member>
        <member name="F:Blockcore.Consensus.RateLimitingBehavior.dateTimeProvider">
            <summary>Provider of time functions.</summary>
        </member>
        <member name="F:Blockcore.Consensus.RateLimitingBehavior.getHeaderLastRequestHash">
            <summary>The last header that was requested.</summary>
        </member>
        <member name="F:Blockcore.Consensus.RateLimitingBehavior.getHeaderLastRequestedTimestamp">
            <summary>The last time the header was requested.</summary>
        </member>
        <member name="F:Blockcore.Consensus.RateLimitingBehavior.getHeaderRequestCount">
            <summary>The amount of times the same request has been made.</summary>
        </member>
        <member name="F:Blockcore.Consensus.RateLimitingBehavior.GetHeaderRequestCountThresholdSeconds">
            <summary>The threshold after which the node will be banned and disconnected.</summary>
        </member>
        <member name="F:Blockcore.Consensus.RateLimitingBehavior.GetHeaderRequestTimestampThreshold">
            <summary>The threshold time span in which header requests are invalid and tracked.</summary>
        </member>
        <member name="F:Blockcore.Consensus.RateLimitingBehavior.logger">
            <summary>Instance logger.</summary>
        </member>
        <member name="F:Blockcore.Consensus.RateLimitingBehavior.loggerFactory">
            <summary>Factory for creating loggers.</summary>
        </member>
        <member name="F:Blockcore.Consensus.RateLimitingBehavior.peerBanning">
            <summary>Contract for peer banning behavior.</summary>
        </member>
        <member name="M:Blockcore.Consensus.RateLimitingBehavior.OnMessageReceived(Blockcore.P2P.Peer.INetworkPeer,Blockcore.P2P.Protocol.IncomingMessage)">
            <summary>
            Processes an incoming message from the peer.
            </summary>
            <param name="peer">Peer from which the message was received.</param>
            <param name="message">Received message to process.</param>
        </member>
        <member name="M:Blockcore.Consensus.RateLimitingBehavior.HandleGetHeaders(Blockcore.P2P.Protocol.Payloads.GetHeadersPayload)">
            <summary>
            Determines whether or not a peer asked for the same set of headers within 60 seconds.
            <para>
            If the same set of headers was requested more than <see cref="F:Blockcore.Consensus.RateLimitingBehavior.GetHeaderRequestCountThresholdSeconds"/>, it will be banned
            and disconnected.
            </para>
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.PerformanceCounters.ConsensusManager.ConsensusManagerPerformanceCounter.currentSnapshot">
            <summary>Snapshot that is currently being populated.</summary>
        </member>
        <member name="M:Blockcore.Consensus.PerformanceCounters.ConsensusManager.ConsensusManagerPerformanceCounter.MeasureTotalConnectionTime">
            <summary>
            Measures time to execute <c>OnPartialValidationSucceededAsync</c>.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.PerformanceCounters.ConsensusManager.ConsensusManagerPerformanceCounter.TakeSnapshot">
            <summary>Takes current snapshot.</summary>
            <remarks>Not thread-safe. Caller should ensure that it's not called from different threads at once.</remarks>
        </member>
        <member name="T:Blockcore.Consensus.PerformanceCounters.ConsensusManager.ConsensusManagerPerformanceSnapshot">
            <summary>Snapshot of <see cref="N:Blockcore.Consensus.PerformanceCounters.ConsensusManager"/> performance.</summary>
        </member>
        <member name="T:Blockcore.Consensus.PerformanceCounters.Rules.ConsensusRulesPerformanceCounter">
            <summary>Measures rules average execution time.</summary>
        </member>
        <member name="F:Blockcore.Consensus.PerformanceCounters.Rules.ConsensusRulesPerformanceCounter.registeredRules">
            <summary>List of rules registered for performance tracking.</summary>
        </member>
        <member name="F:Blockcore.Consensus.PerformanceCounters.Rules.ConsensusRulesPerformanceCounter.currentSnapshot">
            <summary>Snapshot that is currently being populated.</summary>
        </member>
        <member name="M:Blockcore.Consensus.PerformanceCounters.Rules.ConsensusRulesPerformanceCounter.MeasureRuleExecutionTime(Blockcore.Consensus.Rules.IConsensusRuleBase)">
            <summary>Measures the rule execution time and adds this sample to performance counter.</summary>
            <param name="rule">Rule being measured.</param>
            <returns><see cref="T:System.IDisposable"/> that should be disposed after rule has finished it's execution.</returns>
        </member>
        <member name="M:Blockcore.Consensus.PerformanceCounters.Rules.ConsensusRulesPerformanceCounter.TakeSnapshot">
            <summary>Takes current snapshot.</summary>
            <remarks>Not thread-safe. Caller should ensure that it's not called from different threads at once.</remarks>
        </member>
        <member name="T:Blockcore.Consensus.PerformanceCounters.Rules.ConsensusRulesPerformanceSnapshot">
            <summary>Snapshot of rule's performance.</summary>
        </member>
        <member name="T:Blockcore.Consensus.PerformanceCounters.Rules.RuleItem">
            <summary>Container of info related to a consensus rule.</summary>
        </member>
        <member name="T:Blockcore.Consensus.PerformanceCounters.Rules.RulePerformance">
            <summary>
            Container of general information about the consensus rule as well as
            amount of times it was executed and sum of execution times.
            </summary>
            <seealso cref="T:Blockcore.Consensus.PerformanceCounters.Rules.RuleItem" />
        </member>
        <member name="P:Blockcore.Consensus.Rules.ConsensusRulesContainer.HeaderValidationRules">
            <summary>Group of rules that are used during block header validation.</summary>
        </member>
        <member name="P:Blockcore.Consensus.Rules.ConsensusRulesContainer.IntegrityValidationRules">
            <summary>Group of rules that are used during block integrity validation.</summary>
        </member>
        <member name="P:Blockcore.Consensus.Rules.ConsensusRulesContainer.PartialValidationRules">
            <summary>Group of rules that are used during partial block validation.</summary>
        </member>
        <member name="P:Blockcore.Consensus.Rules.ConsensusRulesContainer.FullValidationRules">
            <summary>Group of rules that are used during full validation (connection of a new block).</summary>
        </member>
        <member name="P:Blockcore.Consensus.Rules.ConsensusRuleBase.Logger">
            <summary>Instance logger.</summary>
        </member>
        <member name="P:Blockcore.Consensus.Rules.ConsensusRuleBase.Parent">
            <summary>The engine this rule belongs to.</summary>
        </member>
        <member name="M:Blockcore.Consensus.Rules.ConsensusRuleBase.Initialize">
            <summary>
            Allow a rule to initialize itself.
            The rule can verify that other rules are present using the <see cref="!:IConsensusRuleEngine.Rules"/>.
            The rule can internally initialize its state.
            </summary>
        </member>
        <member name="T:Blockcore.Consensus.Rules.SyncConsensusRule">
            <summary>An abstract rule for implementing consensus rules.</summary>
        </member>
        <member name="M:Blockcore.Consensus.Rules.SyncConsensusRule.Run(Blockcore.Consensus.Rules.RuleContext)">
            <summary>
            Execute the logic in the current rule.
            If the validation of the rule fails a <see cref="T:Blockcore.Consensus.ConsensusErrorException"/> will be thrown.
            </summary>
            <param name="context">The context that has all info that needs to be validated.</param>
        </member>
        <member name="T:Blockcore.Consensus.Rules.AsyncConsensusRule">
            <summary>An abstract rule for implementing consensus rules.</summary>
        </member>
        <member name="M:Blockcore.Consensus.Rules.AsyncConsensusRule.RunAsync(Blockcore.Consensus.Rules.RuleContext)">
            <summary>
            Execute the logic in the current rule in an async approach.
            If the validation of the rule fails a <see cref="T:Blockcore.Consensus.ConsensusErrorException"/> will be thrown.
            </summary>
            <param name="context">The context that has all info that needs to be validated.</param>
            <returns>The execution task.</returns>
        </member>
        <member name="T:Blockcore.Consensus.Rules.RuleContext">
            <summary>
            Context that contains variety of information regarding blocks validation and execution.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.Rules.RuleContext.SkipValidation">
            <summary>Whether to skip block validation for this block due to either a checkpoint or assumevalid hash set.</summary>
        </member>
        <member name="T:Blockcore.Consensus.ScriptAddressReader">
            <inheritdoc cref="T:Blockcore.Interfaces.IScriptAddressReader"/>
        </member>
        <member name="M:Blockcore.Consensus.ScriptAddressReader.GetAddressFromScriptPubKey(Blockcore.Networks.Network,Blockcore.Consensus.ScriptInfo.Script)">
            <inheritdoc cref="M:Blockcore.Interfaces.IScriptAddressReader.GetAddressFromScriptPubKey(Blockcore.Networks.Network,Blockcore.Consensus.ScriptInfo.Script)"/>
        </member>
        <member name="T:Blockcore.Consensus.ScriptAddressResult">
            <summary>
            The script result address.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.ScriptAddressResult.op_Implicit(Blockcore.Consensus.ScriptAddressResult)~System.String">
            <summary>
            Will return the script public address if exists, Otherwise returns <see cref="F:System.String.Empty"/>
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.ScriptAddressResult.IsNullOrEmpty">
            <summary>
            If Address, Hot and Cold addresses are all empty, it will return true, otherwise false.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.ScriptAddressResult.Address">
            <summary>
            Will return the script public address if exists, Otherwise returns <see cref="F:System.String.Empty"/>
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.ScriptAddressResult.HotAddress">
            <summary>
            Will return the script hot public address if exists, Otherwise returns <see cref="F:System.String.Empty"/>
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.ScriptAddressResult.ColdAddress">
            <summary>
            Will return the script cold public address if exists, Otherwise returns <see cref="F:System.String.Empty"/>
            </summary>
        </member>
        <member name="T:Blockcore.Consensus.ScriptInfo.ColdStakingScriptSigParameters">
            <summary>
            The scriptSig parameters used for cold staking script.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.ScriptInfo.ColdStakingScriptSigParameters.TransactionSignature">
            <summary>The signature used with <see cref="F:Blockcore.Consensus.ScriptInfo.OpcodeType.OP_CHECKSIG"/>.</summary>
        </member>
        <member name="P:Blockcore.Consensus.ScriptInfo.ColdStakingScriptSigParameters.IsColdPublicKey">
            <summary>A flag indicating whether this is coldPubKey.</summary>
        </member>
        <member name="P:Blockcore.Consensus.ScriptInfo.ColdStakingScriptSigParameters.PublicKey">
            <summary>This is either the coldPubKey or the hotPubKey.</summary>
        </member>
        <member name="T:Blockcore.Consensus.ScriptInfo.ColdStakingScriptTemplate">
            <summary>
            Script template for the cold staking script.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.ScriptInfo.ColdStakingScriptTemplate.Instance">
            <summary>Returns a static instance of this class.</summary>
        </member>
        <member name="P:Blockcore.Consensus.ScriptInfo.ColdStakingScriptTemplate.Type">
            <summary>
            Returns the transaction type of the cold staking script.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.ColdStakingScriptTemplate.ExtractScriptSigParameters(Blockcore.Networks.Network,Blockcore.Consensus.ScriptInfo.Script)">
            <summary>
            Extracts the scriptSig parameters from the supplied scriptSig.
            </summary>
            <param name="network">The network that the scriptSig is for.</param>
            <param name="scriptSig">The scriptSig to extract parameters from.</param>
            <returns>The extracted scriptSig paramers as a <see cref="T:Blockcore.Consensus.ScriptInfo.ColdStakingScriptSigParameters"/> object.</returns>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.ColdStakingScriptTemplate.GenerateScriptSig(Blockcore.Consensus.ScriptInfo.ColdStakingScriptSigParameters)">
            <summary>
            Generates the scriptSig.
            </summary>
            <param name="parameters">The scriptSig parameters.</param>
            <returns>The scriptSig.</returns>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.ColdStakingScriptTemplate.GenerateScriptSig(Blockcore.Consensus.TransactionInfo.TransactionSignature,System.Boolean,Blockcore.NBitcoin.PubKey)">
            <summary>
            Generates the scriptSig.
            </summary>
            <param name="signature">The transaction signature. For unsigned inputs this can be <c>null</c> in which case it is encoded as an <c>OP_0</c>.</param>
            <param name="coldPubKey">A flag indicating whether the cold wallet versus the hot wallet is signing.</param>
            <param name="publicKey">The cold or hot wallet public key.</param>
            <returns>The scriptSig.</returns>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.ColdStakingScriptTemplate.GenerateScriptPubKey(Blockcore.NBitcoin.KeyId,Blockcore.NBitcoin.KeyId)">
            <summary>
            Creates a cold staking script.
            </summary>
            <remarks>Two keys control the balance associated with the script.
            The hot wallet key allows transactions to only spend amounts back to themselves while the cold
            wallet key allows amounts to be moved to different addresses. This makes it possible to perform
            staking using the hot wallet key so that even if the key becomes compromised it can't be used
            to reduce the balance. Only the person with the cold wallet key can retrieve the coins and move
            them elsewhere. This behavior is enforced by the <see cref="F:Blockcore.Consensus.ScriptInfo.OpcodeType.OP_CHECKCOLDSTAKEVERIFY"/>
            opcode within the script flow related to hot wallet key usage. It sets the <see cref="!:PosTransaction.IsColdCoinStake"/>
            flag if the transaction spending an output, which contains this instruction, is a coinstake
            transaction. If this flag is set then further rules are enforced by <see cref="!:Blockcore.Features.Consensus.Rules.CommonRules.PosColdStakingRule"/>.
            </remarks>
            <param name="hotPubKeyHash">The hot wallet public key hash to use.</param>
            <param name="coldPubKeyHash">The cold wallet public key hash to use.</param>
            <returns>The cold staking script.</returns>
            <seealso cref="!:Consensus.Rules.CommonRules.PosColdStakingRule"/>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.ColdStakingScriptTemplate.FastCheckScriptPubKey(Blockcore.Consensus.ScriptInfo.Script,System.Boolean@)">
            <summary>
            This does a fast check of whether the script is a cold staking script.
            </summary>
            <param name="scriptPubKey">The script to check.</param>
            <param name="needMoreCheck">Whether additional checks are required.</param>
            <returns>The result is <c>true</c> if the script is a cold staking script and <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.ColdStakingScriptTemplate.CheckScriptPubKeyCore(Blockcore.Consensus.ScriptInfo.Script,Blockcore.Consensus.ScriptInfo.Op[])">
            <inheritdoc />
            <remarks>
            This method is called to implement additional checks if <see cref="M:Blockcore.Consensus.ScriptInfo.ColdStakingScriptTemplate.FastCheckScriptPubKey(Blockcore.Consensus.ScriptInfo.Script,System.Boolean@)"/>
            sets <c>needMoreCheck</c> to <c>true</c>. In our case it is not set and this method is not
            called. However this method is defined as <c>abstract</c> in <see cref="T:Blockcore.Consensus.ScriptInfo.ScriptTemplate"/>
            so we still need this dummy implementation.
            </remarks>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.ColdStakingScriptTemplate.ExtractScriptPubKeyParameters(Blockcore.Consensus.ScriptInfo.Script,Blockcore.NBitcoin.KeyId@,Blockcore.NBitcoin.KeyId@)">
            <summary>
            Extracts the hot and cold wallet public key hashes from the script.
            </summary>
            <param name="scriptPubKey">The script to extract the public key hashes from.</param>
            <param name="hotPubKeyHash">The extracted hot wallet public key hash.</param>
            <param name="coldPubKeyHash">The extracted cold wallet public key hash.</param>
            <returns>Returns <c>true</c> if this is a cold staking script and the keys have been extracted.</returns>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.ColdStakingScriptTemplate.CheckScriptSigCore(Blockcore.Networks.Network,Blockcore.Consensus.ScriptInfo.Script,Blockcore.Consensus.ScriptInfo.Op[],Blockcore.Consensus.ScriptInfo.Script,Blockcore.Consensus.ScriptInfo.Op[])">
            <summary>
            Checks whether the scriptSig is valid.
            </summary>
            <param name="network">The network the script belongs to.</param>
            <param name="scriptSig">The scriptSig to check (not used).</param>
            <param name="scriptSigOps">The scriptSig opcodes.</param>
            <param name="scriptPubKey">The scriptPubKey to check (not used).</param>
            <param name="scriptPubKeyOps">The scriptPubKey opcodes (not used).</param>
            <returns>Returns <c>true</c> if the format of the scriptSig is valid and <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Blockcore.Consensus.ScriptInfo.ScriptVerify">
            <summary>
            Script verification flags
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.ScriptInfo.ScriptVerify.P2SH">
            <summary>
            Evaluate P2SH subscripts (softfork safe, BIP16).
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.ScriptInfo.ScriptVerify.StrictEnc">
            <summary>
            Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes script failure.
            Passing a pubkey that is not (0x04 + 64 bytes) or (0x02 or 0x03 + 32 bytes) to checksig causes that pubkey to be
            +
            skipped (not softfork safe: this flag can widen the validity of OP_CHECKSIG OP_NOT).
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.ScriptInfo.ScriptVerify.DerSig">
            <summary>
            Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe, BIP62 rule 1)
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.ScriptInfo.ScriptVerify.LowS">
            <summary>
            Passing a non-strict-DER signature or one with S > order/2 to a checksig operation causes script failure
            (softfork safe, BIP62 rule 5).
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.ScriptInfo.ScriptVerify.NullDummy">
            <summary>
            verify dummy stack item consumed by CHECKMULTISIG is of zero-length (softfork safe, BIP62 rule 7).
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.ScriptInfo.ScriptVerify.SigPushOnly">
            <summary>
            Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2).
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.ScriptInfo.ScriptVerify.MinimalData">
            <summary>
            Require minimal encodings for all push operations (OP_0... OP_16, OP_1NEGATE where possible, direct
            pushes up to 75 bytes, OP_PUSHDATA up to 255 bytes, OP_PUSHDATA2 for anything larger). Evaluating
            any other push causes the script to fail (BIP62 rule 3).
            In addition, whenever a stack element is interpreted as a number, it must be of minimal length (BIP62 rule 4).
            (softfork safe)
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.ScriptInfo.ScriptVerify.DiscourageUpgradableNops">
             <summary>
             Discourage use of NOPs reserved for upgrades (NOP1-10)
            
             Provided so that nodes can avoid accepting or mining transactions
             containing executed NOP's whose meaning may change after a soft-fork,
             thus rendering the script invalid; with this flag set executing
             discouraged NOPs fails the script. This verification flag will never be
             a mandatory flag applied to scripts in a block. NOPs that are not
             executed, e.g.  within an unexecuted IF ENDIF block, are *not* rejected.
             </summary>
        </member>
        <member name="F:Blockcore.Consensus.ScriptInfo.ScriptVerify.CleanStack">
            <summary>
            Require that only a single stack element remains after evaluation. This changes the success criterion from
            "At least one stack element must remain, and when interpreted as a boolean, it must be true" to
            "Exactly one stack element must remain, and when interpreted as a boolean, it must be true".
            (softfork safe, BIP62 rule 6)
            Note: CLEANSTACK should never be used without P2SH.
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.ScriptInfo.ScriptVerify.CheckLockTimeVerify">
             <summary>
             Verify CHECKLOCKTIMEVERIFY
            
             See BIP65 for details.
             </summary>
        </member>
        <member name="F:Blockcore.Consensus.ScriptInfo.ScriptVerify.CheckSequenceVerify">
            <summary>
            See BIP68 for details.
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.ScriptInfo.ScriptVerify.Witness">
            <summary>
            Support segregated witness
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.ScriptInfo.ScriptVerify.DiscourageUpgradableWitnessProgram">
            <summary>
            Making v2-v16 witness program non-standard
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.ScriptInfo.ScriptVerify.MinimalIf">
            <summary>
            Segwit script only: Require the argument of OP_IF/NOTIF to be exactly 0x01 or empty vector
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.ScriptInfo.ScriptVerify.NullFail">
            <summary>
            Signature(s) must be empty vector if an CHECK(MULTI)SIG operation failed
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.ScriptInfo.ScriptVerify.WitnessPubkeyType">
            <summary>
            Public keys in segregated witness scripts must be compressed
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.ScriptInfo.ScriptVerify.CheckColdStakeVerify">
            <summary>
            This flag is set for POS when we reach the block height where cold staking is enabled.
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.ScriptInfo.ScriptVerify.Mandatory">
             <summary>
             Mandatory script verification flags that all new blocks must comply with for
             them to be valid. (but old blocks may not comply with) Currently just P2SH,
             but in the future other flags may be added, such as a soft-fork to enforce
             strict DER encoding.
            
             Failing one of these tests may trigger a DoS ban - see CheckInputs() for
             details.
             </summary>
        </member>
        <member name="F:Blockcore.Consensus.ScriptInfo.ScriptVerify.Standard">
            <summary>
            Standard script verification flags that standard transactions will comply
            with. However scripts violating these flags may still be present in valid
            blocks and we must accept those blocks.
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.ScriptInfo.ScriptVerify.StandardNotMandatory">
            <summary>
            For convenience, standard but not mandatory verify flags
            </summary>
        </member>
        <member name="T:Blockcore.Consensus.ScriptInfo.SigHash">
            <summary>
            Signature hash types/flags
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.ScriptInfo.SigHash.All">
            <summary>
            All outputs are signed
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.ScriptInfo.SigHash.None">
            <summary>
            No outputs as signed
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.ScriptInfo.SigHash.Single">
            <summary>
            Only the output with the same index as this input is signed
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.ScriptInfo.SigHash.AnyoneCanPay">
            <summary>
            If set, no inputs, except this, are part of the signature
            </summary>
        </member>
        <member name="T:Blockcore.Consensus.ScriptInfo.OpcodeType">
            <summary>
            Script opcodes
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Blockcore.Consensus.ScriptInfo.Script.ExtractScriptCode(System.Int32)" -->
        <member name="P:Blockcore.Consensus.ScriptInfo.Script.PaymentScript">
            <summary>
            Get the P2SH scriptPubKey of this script
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.Script.IsWitness(Blockcore.Networks.Network)">
            <summary>
            True if the scriptPubKey is witness
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.Script.GetSignerAddress(Blockcore.Networks.Network)">
            <summary>
            Extract P2SH or P2PH address from scriptSig
            </summary>
            <param name="network">The network</param>
            <returns></returns>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.Script.GetSigner(Blockcore.Networks.Network)">
            <summary>
            Extract P2SH or P2PH id from scriptSig
            </summary>
            <returns>The network</returns>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.Script.GetDestinationAddress(Blockcore.Networks.Network)">
            <summary>
            Extract P2SH/P2PH/P2WSH/P2WPKH address from scriptPubKey
            </summary>
            <param name="network"></param>
            <returns></returns>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.Script.GetColdStakeDestinationAddress(Blockcore.Networks.Network)">
            <summary>
            Extract ColdStakingScript addresses from scriptPubKey
            </summary>
            <param name="network"></param>
            <returns>Both hot and cold <c>BitcoinAddress</c> addresses</returns>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.Script.GetDestination(Blockcore.Networks.Network)">
            <summary>
            Extract P2SH/P2PH/P2WSH/P2WPKH id from scriptPubKey
            </summary>
            <param name="network"></param>
            <returns></returns>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.Script.GetDestinationPublicKeys(Blockcore.Networks.Network)">
            <summary>
            Extract public keys if this script is a multi sig or pay to pub key scriptPubKey
            </summary>
            <param name="network"></param>
            <returns></returns>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.Script.ToRawScript">
            <summary>
            Get script byte array
            </summary>
            <returns></returns>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.Script.ToBytes">
            <summary>
            Get script byte array
            </summary>
            <returns></returns>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.Script.ToRawScript(System.Boolean)">
            <summary>
            Get script byte array
            </summary>
            <param name="unsafe">if false, returns a copy of the internal byte array</param>
            <returns></returns>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.Script.ToBytes(System.Boolean)">
            <summary>
            Get script byte array
            </summary>
            <param name="unsafe">if false, returns a copy of the internal byte array</param>
            <returns></returns>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.Script.VerifyScriptConsensus(System.Byte[],System.UInt32,System.Byte[],System.UInt32,System.UInt32,Blockcore.Consensus.ScriptInfo.ScriptVerify,Blockcore.Consensus.ScriptInfo.Script.BitcoinConsensusError@)">
            Returns 1 if the input nIn of the serialized transaction pointed to by
            txTo correctly spends the scriptPubKey pointed to by scriptPubKey under
            the additional constraints specified by flags.
            If not NULL, err will contain an error/success code for the operation
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.ScriptEvaluationContext.CScriptNum.#ctor(System.Int64)">
            Numeric opcodes (OP_1ADD, etc) are restricted to operating on 4-byte integers.
            The semantics are subtle, though: operands must be in the range [-2^31 +1...2^31 -1],
            but results may overflow (and are valid as long as they are not used in a subsequent
            numeric operation). CScriptNum enforces those semantics by storing results as
            an int64 and allowing out-of-range values to be returned as a vector of bytes but
            throwing an exception if arithmetic is done or the result is interpreted as an integer.
        </member>
        <member name="T:Blockcore.Consensus.ScriptInfo.ContextStack`1">
            <summary>
            ContextStack is used internally by the bitcoin script evaluator. This class contains
            operations not typically available in a "pure" Stack class, as example:
            Insert, Swap, Erase and Top (Peek w/index)
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.ContextStack`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Blockcore.Consensus.ScriptInfo.ContextStack`1"/> class.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.ContextStack`1.#ctor(Blockcore.Consensus.ScriptInfo.ContextStack{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Blockcore.Consensus.ScriptInfo.ContextStack`1"/>
            base on another stack. This is for copy/clone.
            </summary>
            <param name="stack">The stack.</param>
        </member>
        <member name="P:Blockcore.Consensus.ScriptInfo.ContextStack`1.Count">
            <summary>
            Gets the number of items in the stack.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.ContextStack`1.Push(`0)">
            <summary>
            Pushes the specified item on the stack.
            </summary>
            <param name="item">The item to by pushed.</param>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.ContextStack`1.Pop">
            <summary>
            Pops this element in top of the stack.
            </summary>
            <returns>The element in top of the stack</returns>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.ContextStack`1.Clear(System.Int32)">
            <summary>
            Pops as many items as specified.
            </summary>
            <param name="n">The number of items to be poped</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Cannot remove more elements</exception>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.ContextStack`1.Top(System.Int32)">
            <summary>
            Returns the i-th element from the top of the stack.
            </summary>
            <param name="i">The i-th index.</param>
            <returns>the i-th element from the top of the stack</returns>
            <exception cref="T:System.IndexOutOfRangeException">topIndex</exception>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.ContextStack`1.Swap(System.Int32,System.Int32)">
            <summary>
            Swaps the specified i and j elements in the stack.
            </summary>
            <param name="i">The i-th index.</param>
            <param name="j">The j-th index.</param>
            <exception cref="T:System.IndexOutOfRangeException">
            i or  j
            </exception>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.ContextStack`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an item in the specified position.
            </summary>
            <param name="position">The position.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.ContextStack`1.Remove(System.Int32)">
            <summary>
            Removes the i-th item.
            </summary>
            <param name="from">The item position</param>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.ContextStack`1.Remove(System.Int32,System.Int32)">
            <summary>
            Removes items from the i-th position to the j-th position.
            </summary>
            <param name="from">The item position</param>
            <param name="to">The item position</param>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.ContextStack`1.AsInternalArray">
            <summary>
            Returns a copy of the internal array.
            </summary>
            <returns>A copy of the internal array</returns>
        </member>
        <member name="T:Blockcore.Consensus.ScriptInfo.ContextStack`1.Enumerator">
            <summary>
            Implements a reverse enumerator for the ContextStack
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.StandardScripts.RegisterStandardScriptTemplate(Blockcore.Consensus.ScriptInfo.ScriptTemplate)">
            <summary>
            Registers a new standard script template if it does not exist yet based on <see cref="P:Blockcore.Consensus.ScriptInfo.ScriptTemplate.Type"/>.
            </summary>
            <param name="scriptTemplate">The standard script template to register.</param>
        </member>
        <member name="T:Blockcore.Consensus.ScriptInfo.StandardScriptsRegistry">
            <summary>
            Injected proxy to <see cref="T:Blockcore.Consensus.ScriptInfo.StandardScripts"/>.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.StandardScriptsRegistry.RegisterStandardScriptTemplate(Blockcore.Consensus.ScriptInfo.ScriptTemplate)">
            <summary>
            Registers a new standard script template if it does not exist yet based on <see cref="P:Blockcore.Consensus.ScriptInfo.ScriptTemplate.Type"/>.
            </summary>
            <param name="scriptTemplate">The standard script template to register.</param>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.PayToPubkeyTemplate.ExtractScriptPubKeyParameters(Blockcore.Consensus.ScriptInfo.Script)">
            <summary>
            Extract the public key or null from the script, perform quick check on pubkey
            </summary>
            <param name="scriptPubKey"></param>
            <returns>The public key</returns>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.PayToPubkeyTemplate.ExtractScriptPubKeyParameters(Blockcore.Consensus.ScriptInfo.Script,System.Boolean)">
            <summary>
            Extract the public key or null from the script
            </summary>
            <param name="scriptPubKey"></param>
            <param name="deepCheck">Whether deep checks are done on public key</param>
            <returns>The public key</returns>
        </member>
        <member name="M:Blockcore.Consensus.ScriptInfo.PayToWitScriptHashTemplate.ExtractWitScriptParameters(Blockcore.Consensus.TransactionInfo.WitScript,Blockcore.NBitcoin.WitScriptId)">
            <summary>
            Extract witness redeem from WitScript
            </summary>
            <param name="witScript">Witscript to extract information from</param>
            <param name="expectedScriptId">Expected redeem hash</param>
            <returns>The witness redeem</returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TxIn.GetSigner(Blockcore.Networks.Network)">
            <summary>
            Try to get the expected scriptPubKey of this TxIn based on its scriptSig and witScript.
            </summary>
            <returns>Null if could not infer the scriptPubKey, else, the expected scriptPubKey</returns>
        </member>
        <member name="P:Blockcore.Consensus.TransactionInfo.TxIn.WitScript">
            <summary>
            The witness script (Witness script is not serialized and deserialized at the TxIn level, but at the Transaction level)
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.TransactionInfo.IndexedTxIn.Index">
            <summary>
            The index of this TxIn in its transaction
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.WitScript.#ctor(System.Byte[][],System.Boolean)">
            <summary>
            Create a new WitnessScript
            </summary>
            <param name="script">Scripts</param>
            <param name="unsafe">If false, make a copy of the input script array</param>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.WitScript.#ctor(System.Collections.Generic.IEnumerable{System.Byte[]},System.Boolean)">
            <summary>
            Create a new WitnessScript
            </summary>
            <param name="script">Scripts</param>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.Transaction.PrecomputeHash(System.Boolean,System.Boolean)">
            <summary>
            Precompute the transaction hash and witness hash so that later calls to GetHash() and GetWitHash() will returns the precomputed hash
            </summary>
            <param name="invalidateExisting">If true, the previous precomputed hash is thrown away, else it is reused</param>
            <param name="lazily">If true, the hash will be calculated and cached at the first call to GetHash(), else it will be immediately</param>
        </member>
        <member name="P:Blockcore.Consensus.TransactionInfo.Transaction.IsColdCoinStake">
            <summary>
            This flag is used to carry state between the script engine and the
            cold staking rule checks, it should not be used outside of that context.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.Transaction.GetVirtualSize(System.Int32)">
            <summary>
            Size of the transaction discounting the witness (Used for fee calculation)
            </summary>
            <param name="witnessScaleFactor">Witness scale factor from network settings (i.e. 4 for BTC).</param>
            <returns>Transaction size</returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.Transaction.Sign(Blockcore.Networks.Network,Blockcore.NBitcoin.ISecret[],Blockcore.NBitcoin.ICoin[])">
            <summary>
            Sign a specific coin with the given secret
            </summary>
            <param name="secrets">Secrets</param>
            <param name="coins">Coins to sign</param>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.Transaction.Sign(Blockcore.Networks.Network,Blockcore.NBitcoin.Key[],Blockcore.NBitcoin.ICoin[])">
            <summary>
            Sign a specific coin with the given secret
            </summary>
            <param name="keys">Private keys</param>
            <param name="coins">Coins to sign</param>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.Transaction.Sign(Blockcore.Networks.Network,Blockcore.NBitcoin.ISecret,Blockcore.NBitcoin.ICoin[])">
            <summary>
            Sign a specific coin with the given secret
            </summary>
            <param name="secret">Secret</param>
            <param name="coins">Coins to sign</param>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.Transaction.Sign(Blockcore.Networks.Network,Blockcore.NBitcoin.ISecret[],Blockcore.NBitcoin.ICoin)">
            <summary>
            Sign a specific coin with the given secret
            </summary>
            <param name="secrets">Secrets</param>
            <param name="coins">Coins to sign</param>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.Transaction.Sign(Blockcore.Networks.Network,Blockcore.NBitcoin.ISecret,Blockcore.NBitcoin.ICoin)">
            <summary>
            Sign a specific coin with the given secret
            </summary>
            <param name="secret">Secret</param>
            <param name="coin">Coins to sign</param>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.Transaction.Sign(Blockcore.Networks.Network,Blockcore.NBitcoin.Key,Blockcore.NBitcoin.ICoin[])">
            <summary>
            Sign a specific coin with the given secret
            </summary>
            <param name="key">Private key</param>
            <param name="coins">Coins to sign</param>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.Transaction.Sign(Blockcore.Networks.Network,Blockcore.NBitcoin.Key,Blockcore.NBitcoin.ICoin)">
            <summary>
            Sign a specific coin with the given secret
            </summary>
            <param name="key">Private key</param>
            <param name="coin">Coin to sign</param>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.Transaction.Sign(Blockcore.Networks.Network,Blockcore.NBitcoin.Key[],Blockcore.NBitcoin.ICoin)">
            <summary>
            Sign a specific coin with the given secret
            </summary>
            <param name="keys">Private keys</param>
            <param name="coin">Coin to sign</param>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.Transaction.Sign(Blockcore.Networks.Network,Blockcore.NBitcoin.ISecret,System.Boolean)">
            <summary>
            Sign the transaction with a private key
            <para>ScriptSigs should be filled with previous ScriptPubKeys</para>
            <para>For more complex scenario, use TransactionBuilder</para>
            </summary>
            <param name="secret"></param>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.Transaction.Sign(Blockcore.Networks.Network,Blockcore.NBitcoin.Key,System.Boolean)">
            <summary>
            Sign the transaction with a private key
            <para>ScriptSigs should be filled with either previous scriptPubKeys or redeem script (for P2SH)</para>
            <para>For more complex scenario, use TransactionBuilder</para>
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.Transaction.GetFee(Blockcore.NBitcoin.ICoin[])">
            <summary>
            Calculate the fee of the transaction
            </summary>
            <param name="spentCoins">Coins being spent</param>
            <returns>Fee or null if some spent coins are missing or if spentCoins is null</returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.Transaction.GetFeeRate(System.Int32,Blockcore.NBitcoin.ICoin[])">
            <summary>
            Calculate the fee rate of the transaction
            </summary>
            <param name="witnessScaleFactor">Witness scale factor from network settings (i.e. 4 for BTC).</param>
            <param name="spentCoins">Coins being spent</param>
            <returns>Fee or null if some spent coins are missing or if spentCoins is null</returns>
        </member>
        <member name="F:Blockcore.Consensus.TransactionInfo.Transaction.LockTimeFlags.VerifySequence">
            <summary>
            Interpret sequence numbers as relative lock-time constraints.
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.TransactionInfo.Transaction.LockTimeFlags.MedianTimePast">
            <summary>
             Use GetMedianTimePast() instead of nTime for end point timestamp.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.Transaction.CheckSequenceLocks(System.Int32[],Blockcore.Consensus.Chain.ChainedHeader,Blockcore.Consensus.TransactionInfo.Transaction.LockTimeFlags)">
            <summary>
            Calculates the block height and time which the transaction must be later than
            in order to be considered final in the context of BIP 68.  It also removes
            from the vector of input heights any entries which did not correspond to sequence
            locked inputs as they do not affect the calculation.
            </summary>
            <param name="prevHeights">Previous Height</param>
            <param name="block">The block being evaluated</param>
            <param name="flags">If VerifySequence is not set, returns always true SequenceLock</param>
            <returns>Sequence lock of minimum SequenceLock to satisfy</returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.Transaction.CalculateSequenceLocks(System.Int32[],Blockcore.Consensus.Chain.ChainedHeader,Blockcore.Consensus.TransactionInfo.Transaction.LockTimeFlags)">
            <summary>
            Calculates the block height and time which the transaction must be later than
            in order to be considered final in the context of BIP 68.  It also removes
            from the vector of input heights any entries which did not correspond to sequence
            locked inputs as they do not affect the calculation.
            </summary>
            <param name="prevHeights">Previous Height</param>
            <param name="chainedHeader">The Chained block header being evaluated</param>
            <param name="flags">If VerifySequence is not set, returns always true SequenceLock</param>
            <returns>Sequence lock of minimum SequenceLock to satisfy</returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.Transaction.WithOptions(Blockcore.Consensus.TransactionInfo.TransactionOptions,Blockcore.Consensus.ConsensusFactory)">
            <summary>
            Create a transaction with the specified option only. (useful for stripping data from a transaction)
            </summary>
            <param name="options">Options to keep</param>
            <param name="consensusFactory">The network consensus factory.</param>
            <returns>A new transaction with only the options wanted</returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.Transaction.Check">
            <summary>
            Context free transaction check
            </summary>
            <returns>The error or success of the check</returns>
        </member>
        <member name="T:Blockcore.Consensus.TransactionInfo.AllCoinsSelector">
            <summary>
            A coin selector that selects all the coins passed by default.
            Useful when a user wants a specific set of coins to be spent.
            </summary>
        </member>
        <member name="T:Blockcore.Consensus.TransactionInfo.DefaultCoinSelector">
            <summary>
            Algorithm implemented by bitcoin core https://github.com/bitcoin/bitcoin/blob/master/src/wallet.cpp#L1276
            Minimize the change
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.TransactionInfo.DefaultCoinSelector.GroupByScriptPubKey">
            <summary>
            Select all coins belonging to same scriptPubKey together to protect privacy. (Default: true)
            </summary>
        </member>
        <member name="T:Blockcore.Consensus.TransactionInfo.NotEnoughFundsException">
            <summary>
            Exception thrown when not enough funds are present for verifying or building a transaction
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.TransactionInfo.NotEnoughFundsException.Group">
            <summary>
            The group name who is missing the funds
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.TransactionInfo.NotEnoughFundsException.Missing">
            <summary>
            Amount of Money missing
            </summary>
        </member>
        <member name="T:Blockcore.Consensus.TransactionInfo.TransactionBuilder">
            <summary>
            A class for building and signing all sort of transactions easily (http://www.codeproject.com/Articles/835098/NBitcoin-Build-Them-All)
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.TransactionInfo.TransactionBuilder.Network">
            <summary>
            This field should be mandatory in the constructor.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.TransactionInfo.TransactionBuilder.DustPrevention">
            <summary>
            Will transform transfers below Dust, so the transaction get correctly relayed by the network.
            If true, it will remove any TxOut below Dust, so the transaction get correctly relayed by the network. (Default: true)
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.TransactionInfo.TransactionBuilder.FilterUneconomicalCoins">
            <summary>
            If true, the TransactionBuilder will not select coins whose fee to spend is higher than its value. (Default: true)
            The cost of spending a coin is based on the <see cref="P:Blockcore.Consensus.TransactionInfo.TransactionBuilder.FilterUneconomicalCoinsRate"/>.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.TransactionInfo.TransactionBuilder.FilterUneconomicalCoinsRate">
            <summary>
            If <see cref="P:Blockcore.Consensus.TransactionInfo.TransactionBuilder.FilterUneconomicalCoins"/> is true, this rate is used to know if an output is economical.
            This property is set automatically when calling <see cref="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.SendEstimatedFees(Blockcore.NBitcoin.FeeRate)"/> or <see cref="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.SendEstimatedFeesSplit(Blockcore.NBitcoin.FeeRate)"/>.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.TransactionInfo.TransactionBuilder.CoinFinder">
            <summary>
            A callback used by the TransactionBuilder when it does not find the coin for an input
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.TransactionInfo.TransactionBuilder.KeyFinder">
            <summary>
            A callback used by the TransactionBuilder when it does not find the key for a scriptPubKey
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.SetGroupName(System.String)">
            <summary>
            Set the name of this group (group are separated by call to Then())
            </summary>
            <param name="groupName">Name of the group</param>
            <returns></returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.Send(Blockcore.NBitcoin.IDestination,Blockcore.NBitcoin.Money)">
            <summary>
            Send bitcoins to a destination
            </summary>
            <param name="destination">The destination</param>
            <param name="amount">The amount</param>
            <returns></returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.Send(Blockcore.Consensus.ScriptInfo.Script,Blockcore.NBitcoin.Money)">
            <summary>
            Send bitcoins to a destination
            </summary>
            <param name="scriptPubKey">The destination</param>
            <param name="amount">The amount</param>
            <returns></returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.SubtractFees">
            <summary>
            Will subtract fees from the previous TxOut added by the last TransactionBuidler.Send() call
            </summary>
            <returns></returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.Send(Blockcore.NBitcoin.IDestination,Blockcore.NBitcoin.IMoney)">
            <summary>
            Send a money amount to the destination
            </summary>
            <param name="destination">The destination</param>
            <param name="amount">The amount (supported : Money, AssetMoney, MoneyBag)</param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">The coin type is not supported</exception>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.Send(Blockcore.Consensus.ScriptInfo.Script,Blockcore.NBitcoin.IMoney)">
            <summary>
            Send a money amount to the destination
            </summary>
            <param name="destination">The destination</param>
            <param name="amount">The amount (supported : Money, AssetMoney, MoneyBag)</param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">The coin type is not supported</exception>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.SendAsset(Blockcore.NBitcoin.IDestination,Blockcore.NBitcoin.OpenAsset.AssetMoney)">
            <summary>
            Send assets (Open Asset) to a destination
            </summary>
            <param name="destination">The destination</param>
            <param name="asset">The asset and amount</param>
            <returns></returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.SendAsset(Blockcore.NBitcoin.IDestination,Blockcore.NBitcoin.OpenAsset.AssetId,System.UInt64)">
            <summary>
            Send assets (Open Asset) to a destination
            </summary>
            <param name="destination">The destination</param>
            <param name="asset">The asset and amount</param>
            <returns></returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.SetTransactionPolicy(Blockcore.NBitcoin.Policy.StandardTransactionPolicy)">
            <summary>
            Set transaction policy fluently
            </summary>
            <param name="policy">The policy</param>
            <returns>this</returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.SendEstimatedFees(Blockcore.NBitcoin.FeeRate)">
            <summary>
            Split the estimated fees across the several groups (separated by Then())
            </summary>
            <param name="feeRate"></param>
            <returns></returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.SendEstimatedFeesSplit(Blockcore.NBitcoin.FeeRate)">
            <summary>
            Estimate the fee needed for the transaction, and split among groups according to their fee weight
            </summary>
            <param name="feeRate"></param>
            <returns></returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.SendFeesSplit(Blockcore.NBitcoin.Money)">
            <summary>
            Send the fee splitted among groups according to their fee weight
            </summary>
            <param name="fees"></param>
            <returns></returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.SetFeeWeight(System.Decimal)">
            <summary>
            If using SendFeesSplit or SendEstimatedFeesSplit, determine the weight this group participate in paying the fees
            </summary>
            <param name="feeWeight">The weight of fee participation</param>
            <returns></returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.BuildTransaction(System.Boolean)">
            <summary>
            Build the transaction
            </summary>
            <param name="sign">True if signs all inputs with the available keys</param>
            <returns>The transaction</returns>
            <exception cref="T:Blockcore.Consensus.TransactionInfo.NotEnoughFundsException">Not enough funds are available</exception>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.BuildTransaction(System.Boolean,Blockcore.Consensus.ScriptInfo.SigHash)">
            <summary>
            Build the transaction
            </summary>
            <param name="sign">True if signs all inputs with the available keys</param>
            <param name="sigHash">The type of signature</param>
            <returns>The transaction</returns>
            <exception cref="T:Blockcore.Consensus.TransactionInfo.NotEnoughFundsException">Not enough funds are available</exception>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.Verify(Blockcore.Consensus.TransactionInfo.Transaction)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="tx">The transaction to check</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.Verify(Blockcore.Consensus.TransactionInfo.Transaction,Blockcore.NBitcoin.Money)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="tx">The transaction to check</param>
            <param name="expectedFees">The expected fees (more or less 10%)</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.Verify(Blockcore.Consensus.TransactionInfo.Transaction,Blockcore.NBitcoin.FeeRate)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="tx">The transaction to check</param>
            <param name="expectedFeeRate">The expected fee rate</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.Verify(Blockcore.Consensus.TransactionInfo.Transaction,Blockcore.NBitcoin.Policy.TransactionPolicyError[]@)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="tx">The transaction to check</param>
            <param name="errors">Detected errors</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.Verify(Blockcore.Consensus.TransactionInfo.Transaction,Blockcore.NBitcoin.Money,Blockcore.NBitcoin.Policy.TransactionPolicyError[]@)">
            <summary>
            Verify that a transaction is fully signed, have enough fees, and follow the Standard and Miner Transaction Policy rules
            </summary>
            <param name="tx">The transaction to check</param>
            <param name="expectedFees">The expected fees (more or less 10%)</param>
            <param name="errors">Detected errors</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.Verify(Blockcore.Consensus.TransactionInfo.Transaction,Blockcore.NBitcoin.FeeRate,Blockcore.NBitcoin.Policy.TransactionPolicyError[]@)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="tx">The transaction to check</param>
            <param name="expectedFeeRate">The expected fee rate</param>
            <param name="errors">Detected errors</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.Check(Blockcore.Consensus.TransactionInfo.Transaction,Blockcore.NBitcoin.FeeRate)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="tx">he transaction to check</param>
            <param name="expectedFeeRate">The expected fee rate</param>
            <returns>Detected errors</returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.Check(Blockcore.Consensus.TransactionInfo.Transaction,Blockcore.NBitcoin.Money)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="tx">he transaction to check</param>
            <param name="expectedFee">The expected fee</param>
            <returns>Detected errors</returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.Check(Blockcore.Consensus.TransactionInfo.Transaction)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="tx">he transaction to check</param>
            <returns>Detected errors</returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.FindSpentCoins(Blockcore.Consensus.TransactionInfo.Transaction)">
            <summary>
            Find spent coins of a transaction
            </summary>
            <param name="tx">The transaction</param>
            <returns>Array of size tx.Input.Count, if a coin is not fund, a null coin is returned.</returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.EstimateSize(Blockcore.Consensus.TransactionInfo.Transaction)">
            <summary>
            Estimate the physical size of the transaction
            </summary>
            <param name="tx">The transaction to be estimated</param>
            <returns></returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.EstimateSize(Blockcore.Consensus.TransactionInfo.Transaction,System.Boolean)">
            <summary>
            Estimate the size of the transaction
            </summary>
            <param name="tx">The transaction to be estimated</param>
            <param name="virtualSize">If true, returns the size on which fee calculation are based, else returns the physical byte size</param>
            <returns></returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.EstimateFees(Blockcore.NBitcoin.FeeRate)">
            <summary>
            Estimate fees of the built transaction
            </summary>
            <param name="feeRate">Fee rate</param>
            <returns></returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.EstimateFees(Blockcore.Consensus.TransactionInfo.Transaction,Blockcore.NBitcoin.FeeRate)">
            <summary>
            Estimate fees of an unsigned transaction
            </summary>
            <param name="tx"></param>
            <param name="feeRate">Fee rate</param>
            <returns></returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.Then">
            <summary>
            Create a new participant in the transaction with its own set of coins and keys
            </summary>
            <returns></returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.Then(System.String)">
            <summary>
            Switch to another participant in the transaction, or create a new one if it is not found.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.CoverOnly(Blockcore.NBitcoin.Money)">
            <summary>
            Specify the amount of money to cover txouts, if not specified all txout will be covered
            </summary>
            <param name="amount"></param>
            <returns></returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.ContinueToBuild(Blockcore.Consensus.TransactionInfo.Transaction)">
            <summary>
            Allows to keep building on the top of a partially built transaction
            </summary>
            <param name="transaction">Transaction to complete</param>
            <returns></returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.CoverTheRest">
            <summary>
            Will cover the remaining amount of TxOut of a partially built transaction (to call after ContinueToBuild)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.CombineSignatures(System.Boolean,Blockcore.Consensus.TransactionInfo.Transaction[])">
            <summary>
            Combine transactions by merging their signatures.
            </summary>
            <param name="requireFirstSigned">
            An optional optimisation to exit early. If set and the merging of the first input doesn't change the transaction, the method will exit.
            </param>
            <param name="transactions">The transactions to merge signatures for.</param>
            <returns>The merged transaction.</returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionBuilder.CombineSignaturesCore(Blockcore.Consensus.TransactionInfo.Transaction,Blockcore.Consensus.TransactionInfo.Transaction,System.Boolean)">
            <summary>
            Combine multiple transactions into one, merging signatures for all of their inputs.
            </summary>
            <param name="signed1">First transaction to sign.</param>
            <param name="signed2">Second transaction to sign.</param>
            <param name="requireFirstSigned">
            An optional optimisation to exit early. If set and the merging of the first input doesn't change the transaction, the method will exit.
            </param>
            <returns>The combined transaction.</returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionSignature.IsValid(Blockcore.Networks.Network,System.Byte[],Blockcore.Consensus.ScriptInfo.ScriptVerify)">
            <summary>
            Check if valid transaction signature
            </summary>
            <param name="network">The blockchain network class.</param>
            <param name="sig">Signature in bytes</param>
            <param name="scriptVerify">Verification rules</param>
            <returns>True if valid</returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionSignature.IsValid(Blockcore.Networks.Network,System.Byte[],Blockcore.Consensus.ScriptInfo.ScriptVerify,Blockcore.Consensus.ScriptInfo.ScriptError@)">
            <summary>
            Check if valid transaction signature
            </summary>
            <param name="network">The blockchain network class.</param>
            <param name="sig">The signature</param>
            <param name="scriptVerify">Verification rules</param>
            <param name="error">Error</param>
            <returns>True if valid</returns>
        </member>
        <member name="M:Blockcore.Consensus.TransactionInfo.TransactionSignature.MakeCanonical">
            <summary>
            Enforce LowS on the signature
            </summary>
        </member>
        <member name="T:Blockcore.Consensus.ValidationContext">
            <summary>
            A context that is used by consensus that is required for validation, in case validation failed the <see cref="P:Blockcore.Consensus.ValidationContext.Error"/> property will be set.
            It is used when a new block is downloaded or mined.
            </summary>
        </member>
        <member name="F:Blockcore.Consensus.ValidationContext.BanDurationNoBan">
            <summary>A value indicating the peer should not be banned.</summary>
        </member>
        <member name="F:Blockcore.Consensus.ValidationContext.BanDurationDefaultBan">
            <summary>A value indicating the peer ban time should be <see cref="P:Blockcore.Configuration.Settings.ConnectionManagerSettings.BanTimeSeconds"/>.</summary>
        </member>
        <member name="P:Blockcore.Consensus.ValidationContext.ChainedHeaderToValidate">
            <summary>Chained header of the block being validated.</summary>
        </member>
        <member name="P:Blockcore.Consensus.ValidationContext.BlockToValidate">
            <summary>Downloaded or mined block to be validated.</summary>
        </member>
        <member name="P:Blockcore.Consensus.ValidationContext.Error">
            <summary>If the block validation failed this will be set with the reason of failure.</summary>
        </member>
        <member name="P:Blockcore.Consensus.ValidationContext.RejectUntil">
            <summary>
            If the block validation failed with <see cref="P:Blockcore.Consensus.ConsensusErrors.BlockTimestampTooFar"/>
            then this is set to a time until which the block should be marked as invalid. Otherwise it is <c>null</c>.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.ValidationContext.BanDurationSeconds">
            <summary>
            If the block validation failed with a <see cref="T:Blockcore.Consensus.ConsensusError"/> that is considered malicious the peer will get banned.
            The ban, unless specified otherwise, will default to <see cref="P:Blockcore.Configuration.Settings.ConnectionManagerSettings.BanTimeSeconds"/>.
            </summary>
            <remarks>
            Setting this value to be <see cref="F:Blockcore.Consensus.ValidationContext.BanDurationNoBan"/> will prevent the peer from being banned.
            Setting this value to be <see cref="F:Blockcore.Consensus.ValidationContext.BanDurationDefaultBan"/> will default to <see cref="P:Blockcore.Configuration.Settings.ConnectionManagerSettings.BanTimeSeconds"/>.
            </remarks>
        </member>
        <member name="P:Blockcore.Consensus.ValidationContext.MissingServices">
            <summary>Services that are missing from the peers.</summary>
            <remarks>
            Set in case some information is missing from the block which leads
            to inability to validate the block properly. Set to <c>null</c> otherwise.
            </remarks>
        </member>
        <member name="P:Blockcore.Consensus.ValidationContext.InsufficientHeaderInformation">
            <summary>Gets or sets flag indicating if we do not have enough information to validate UTOX.</summary>
        </member>
        <member name="T:Blockcore.Consensus.ValidationResults.ConnectBlocksResult">
            <summary>
            Information related to the block full validation process.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.ValidationResults.ConnectBlocksResult.PeersToBan">
            <summary>List of peer IDs to be banned and disconnected.</summary>
            <remarks><c>null</c> in case <see cref="P:Blockcore.Consensus.ValidationResults.ValidationResult.Succeeded"/> is <c>false</c>.</remarks>
        </member>
        <member name="T:Blockcore.Consensus.ValidationResults.PartialValidationResult">
            <summary>
            Feedback specific to a partial block validation.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.ValidationResults.PartialValidationResult.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Blockcore.Consensus.ValidationResults.ValidationResult">
            <summary>
            Feedback after a block was validated.
            </summary>
        </member>
        <member name="M:Blockcore.Consensus.ValidationResults.ValidationResult.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Blockcore.Consensus.Validators.OnPartialValidationCompletedAsyncCallback">
            <summary>
            A callback that is invoked when <see cref="M:Blockcore.Consensus.Validators.IPartialValidator.StartPartialValidation(Blockcore.Consensus.Chain.ChainedHeader,Blockcore.Consensus.BlockInfo.Block,Blockcore.Consensus.Validators.OnPartialValidationCompletedAsyncCallback)"/> completes validation of a block.
            </summary>
            <param name="validationContext">Result of the validation including information about banning if necessary.</param>
        </member>
        <member name="M:Blockcore.Consensus.Validators.IHeaderValidator.ValidateHeader(Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>
            Validates a block header.
            </summary>
            <param name="chainedHeader">The chained header to be validated.</param>
            <returns>Context that contains validation result related information.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Validators.IPartialValidator.StartPartialValidation(Blockcore.Consensus.Chain.ChainedHeader,Blockcore.Consensus.BlockInfo.Block,Blockcore.Consensus.Validators.OnPartialValidationCompletedAsyncCallback)">
            <summary>
            Schedules a block for background partial validation.
            <para>
            Partial validation doesn't involve change to the underlying store like rewinding or updating the database.
            </para>
            </summary>
            <param name="header">The chained header that is going to be validated.</param>
            <param name="block">The block that is going to be validated.</param>
            <param name="onPartialValidationCompletedAsyncCallback">A callback that is called when validation is complete.</param>
        </member>
        <member name="M:Blockcore.Consensus.Validators.IPartialValidator.ValidateAsync(Blockcore.Consensus.Chain.ChainedHeader,Blockcore.Consensus.BlockInfo.Block)">
            <summary>
            Executes the partial validation rule set on a block.
            <para>
            Partial validation doesn't involve change to the underlying store like rewinding or updating the database.
            </para>
            </summary>
            <param name="header">The chained header that is going to be validated.</param>
            <param name="block">The block that is going to be validated.</param>
            <returns>Context that contains validation result related information.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Validators.IFullValidator.ValidateAsync(Blockcore.Consensus.Chain.ChainedHeader,Blockcore.Consensus.BlockInfo.Block)">
            <summary>
            Executes the full validation rule set on a block.
            <para>
            Full validation may involve changes to the underlying store like rewinding or updating the database.
            </para>
            </summary>
            <param name="header">The chained header that is going to be validated.</param>
            <param name="block">The block that is going to be validated.</param>
            <returns>Context that contains validation result related information.</returns>
        </member>
        <member name="M:Blockcore.Consensus.Validators.IIntegrityValidator.VerifyBlockIntegrity(Blockcore.Consensus.Chain.ChainedHeader,Blockcore.Consensus.BlockInfo.Block)">
            <summary>
            Verifies that the block data corresponds to the chain header.
            </summary>
            <remarks>
            This validation represents minimal required validation for every block that we download.
            It should be performed even if the block is behind last checkpoint or part of assume valid chain.
            </remarks>
            <param name="header">The chained header that is going to be validated.</param>
            <param name="block">The block that is going to be validated.</param>
            <returns>Context that contains validation result related information.</returns>
        </member>
        <member name="T:Blockcore.Consensus.Validators.HeaderValidator">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.Validators.HeaderValidator.ValidateHeader(Blockcore.Consensus.Chain.ChainedHeader)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Consensus.Validators.IntegrityValidator">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.Validators.IntegrityValidator.VerifyBlockIntegrity(Blockcore.Consensus.Chain.ChainedHeader,Blockcore.Consensus.BlockInfo.Block)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Consensus.Validators.PartialValidator">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.Validators.PartialValidator.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.Validators.PartialValidator.StartPartialValidation(Blockcore.Consensus.Chain.ChainedHeader,Blockcore.Consensus.BlockInfo.Block,Blockcore.Consensus.Validators.OnPartialValidationCompletedAsyncCallback)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.Validators.PartialValidator.ValidateAsync(Blockcore.Consensus.Chain.ChainedHeader,Blockcore.Consensus.BlockInfo.Block)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Consensus.Validators.PartialValidator.PartialValidationItem">
            <summary>
            Holds information related to partial validation.
            </summary>
        </member>
        <member name="P:Blockcore.Consensus.Validators.PartialValidator.PartialValidationItem.ChainedHeader">
            <summary>The header to be partially validated.</summary>
        </member>
        <member name="P:Blockcore.Consensus.Validators.PartialValidator.PartialValidationItem.Block">
            <summary>The block to be partially validated.</summary>
        </member>
        <member name="P:Blockcore.Consensus.Validators.PartialValidator.PartialValidationItem.PartialValidationCompletedAsyncCallback">
            <summary>After validation a call back will be invoked asynchronously.</summary>
        </member>
        <member name="M:Blockcore.Consensus.Validators.PartialValidator.PartialValidationItem.ToString">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Consensus.Validators.FullValidator">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Consensus.Validators.FullValidator.ValidateAsync(Blockcore.Consensus.Chain.ChainedHeader,Blockcore.Consensus.BlockInfo.Block)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.EventBus.CoreEvents.BlockConnected">
            <summary>
            Event that is executed when a block is connected to a consensus chain.
            </summary>
            <seealso cref="T:Blockcore.EventBus.EventBase" />
        </member>
        <member name="T:Blockcore.EventBus.CoreEvents.BlockDisconnected">
            <summary>
            Event that is executed when a block is disconnected from a consensus chain.
            </summary>
            <seealso cref="T:Blockcore.EventBus.EventBase" />
        </member>
        <member name="T:Blockcore.EventBus.CoreEvents.Peer.PeerConnected">
            <summary>
            Event that is published whenever a peer connects to the node.
            This happens prior to any Payload they have to exchange.
            </summary>
            <seealso cref="T:Blockcore.EventBus.EventBase" />
        </member>
        <member name="T:Blockcore.EventBus.CoreEvents.Peer.PeerConnectionAttempt">
            <summary>
            Event that is published whenever the node tries to connect to a peer.
            </summary>
            <seealso cref="T:Blockcore.EventBus.EventBase" />
        </member>
        <member name="T:Blockcore.EventBus.CoreEvents.Peer.PeerConnectionAttemptFailed">
            <summary>
            Event that is published whenever a peer connection attempt failed.
            </summary>
            <seealso cref="T:Blockcore.EventBus.EventBase" />
        </member>
        <member name="T:Blockcore.EventBus.CoreEvents.Peer.PeerDisconnected">
            <summary>
            Event that is published whenever a peer disconnects from the node.
            </summary>
            <seealso cref="T:Blockcore.EventBus.EventBase" />
        </member>
        <member name="T:Blockcore.EventBus.CoreEvents.Peer.PeerEventBase">
            <summary>
            Base peer event.
            </summary>
            <seealso cref="T:Blockcore.EventBus.EventBase" />
        </member>
        <member name="P:Blockcore.EventBus.CoreEvents.Peer.PeerEventBase.PeerEndPoint">
            <summary>
            Gets the peer end point.
            </summary>
            <value>
            The peer end point.
            </value>
        </member>
        <member name="T:Blockcore.EventBus.CoreEvents.Peer.PeerMessageReceived">
            <summary>
            A peer message has been received and parsed
            </summary>
            <seealso cref="T:Blockcore.EventBus.EventBase" />
        </member>
        <member name="T:Blockcore.EventBus.CoreEvents.Peer.PeerMessageSendFailure">
            <summary>
            A peer message failed to be sent.
            </summary>
            <seealso cref="T:Blockcore.EventBus.EventBase" />
        </member>
        <!-- Badly formed XML comment ignored for member "P:Blockcore.EventBus.CoreEvents.Peer.PeerMessageSendFailure.Message" -->
        <member name="T:Blockcore.EventBus.CoreEvents.Peer.PeerMessageSent">
            <summary>
            A peer message has been sent successfully.
            </summary>
            <seealso cref="T:Blockcore.EventBus.EventBase" />
        </member>
        <member name="P:Blockcore.EventBus.CoreEvents.Peer.PeerMessageSent.Message">
            <summary>
            Gets the sent message.
            </summary>
        </member>
        <member name="P:Blockcore.EventBus.CoreEvents.Peer.PeerMessageSent.Size">
            <summary>
            Gets the raw size of the message, in bytes.
            </summary>
        </member>
        <member name="T:Blockcore.EventBus.CoreEvents.TransactionReceived">
            <summary>
            Event that is executed when a transaction is received from another peer.
            </summary>
            <seealso cref="T:Blockcore.EventBus.EventBase" />
        </member>
        <member name="P:Blockcore.EventBus.CoreEvents.TransactionReceived.TransactionId">
            <summary>
            Makes the transaction ID available for Web Socket consumers.
            </summary>
        </member>
        <member name="T:Blockcore.EventBus.DefaultSubscriptionErrorHandler">
            <summary>
            Default implementation of <see cref="T:Blockcore.EventBus.ISubscriptionErrorHandler"/> that log the error and re-throw it.
            </summary>
            <seealso cref="T:Blockcore.EventBus.ISubscriptionErrorHandler" />
        </member>
        <member name="F:Blockcore.EventBus.DefaultSubscriptionErrorHandler.logger">
            <summary>
            The logger
            </summary>
        </member>
        <member name="M:Blockcore.EventBus.DefaultSubscriptionErrorHandler.Handle(Blockcore.EventBus.EventBase,System.Exception,Blockcore.EventBus.ISubscription)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.EventBus.GenericEventBase`1">
            <summary>
            Basic implementation of a generic <see cref="T:Blockcore.EventBus.EventBase"/> that exposes a typed Content property.
            This is abstract to force to create a specific event.
            </summary>
            <seealso cref="T:Blockcore.EventBus.EventBase" />
            <typeparam name="TContent">The type of the content.</typeparam>
            <seealso cref="T:Blockcore.EventBus.EventBase" />
        </member>
        <member name="P:Blockcore.EventBus.GenericEventBase`1.Content">
            <summary>
            Gets or sets the content of the event.
            </summary>
            <value>
            The event content.
            </value>
        </member>
        <member name="M:Blockcore.EventBus.GenericEventBase`1.#ctor(`0)">
            <summary>
            Create a new instance of the GenericEventBase class.
            </summary>
            <param name="content">Content of the event</param>
        </member>
        <member name="T:Blockcore.EventBus.IEventBus">
            <summary>
            Event Bus interface
            </summary>
        </member>
        <member name="M:Blockcore.EventBus.IEventBus.Subscribe``1(System.Action{``0})">
            <summary>
            Subscribes to the specified event type with the specified action
            </summary>
            <typeparam name="TEventBase">The type of event</typeparam>
            <param name="action">The Action to invoke when an event of this type is published</param>
            <returns>A <see cref="T:Blockcore.EventBus.SubscriptionToken"/> to be used when calling <see cref="M:Blockcore.EventBus.IEventBus.Unsubscribe(Blockcore.EventBus.SubscriptionToken)"/></returns>
        </member>
        <member name="M:Blockcore.EventBus.IEventBus.Unsubscribe(Blockcore.EventBus.SubscriptionToken)">
            <summary>
            Unsubscribe from the Event type related to the specified <see cref="T:Blockcore.EventBus.SubscriptionToken"/>
            </summary>
            <param name="token">The <see cref="T:Blockcore.EventBus.SubscriptionToken"/> received from calling the Subscribe method</param>
        </member>
        <member name="M:Blockcore.EventBus.IEventBus.Publish``1(``0)">
            <summary>
            Publishes the specified event to any subscribers for the <see cref="!:TEventBase"/> event type
            </summary>
            <typeparam name="TEventBase">The type of event</typeparam>
            <param name="eventItem">Event to publish</param>
        </member>
        <member name="F:Blockcore.EventBus.InMemoryEventBus.logger">
            <summary>Instance logger.</summary>
        </member>
        <member name="F:Blockcore.EventBus.InMemoryEventBus.subscriptionErrorHandler">
            <summary>
            The subscriber error handler
            </summary>
        </member>
        <member name="F:Blockcore.EventBus.InMemoryEventBus.subscriptions">
            <summary>
            The subscriptions stored by EventType
            </summary>
        </member>
        <member name="F:Blockcore.EventBus.InMemoryEventBus.subscriptionsLock">
            <summary>
            The subscriptions lock to prevent race condition during publishing
            </summary>
        </member>
        <member name="M:Blockcore.EventBus.InMemoryEventBus.#ctor(Microsoft.Extensions.Logging.ILoggerFactory,Blockcore.EventBus.ISubscriptionErrorHandler)">
            <summary>
            Initializes a new instance of the <see cref="T:Blockcore.EventBus.InMemoryEventBus"/> class.
            </summary>
            <param name="loggerFactory">The logger factory.</param>
            <param name="subscriptionErrorHandler">The subscription error handler. If null the default one will be used</param>
        </member>
        <member name="M:Blockcore.EventBus.InMemoryEventBus.Subscribe``1(System.Action{``0})">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.EventBus.InMemoryEventBus.Unsubscribe(Blockcore.EventBus.SubscriptionToken)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.EventBus.InMemoryEventBus.Publish``1(``0)">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.EventBus.ISubscription.SubscriptionToken">
            <summary>
            Token returned to the subscriber
            </summary>
        </member>
        <member name="M:Blockcore.EventBus.ISubscription.Publish(Blockcore.EventBus.EventBase)">
            <summary>
            Publish to the subscriber
            </summary>
            <param name="eventBase"></param>
        </member>
        <member name="M:Blockcore.EventBus.ISubscriptionErrorHandler.Handle(Blockcore.EventBus.EventBase,System.Exception,Blockcore.EventBus.ISubscription)">
            <summary>
            Handles the specified event error.
            </summary>
            <param name="event">The event that caused the error.</param>
            <param name="exception">The exception raised.</param>
            <param name="subscription">The subscription that generated the error.</param>
        </member>
        <member name="P:Blockcore.EventBus.Subscription`1.SubscriptionToken">
            <summary>
            Token returned to the subscriber
            </summary>
        </member>
        <member name="F:Blockcore.EventBus.Subscription`1.action">
            <summary>
            The action to invoke when a subscripted event type is published.
            </summary>
        </member>
        <member name="T:Blockcore.EventBus.SubscriptionToken">
            <summary>
            Represents a subscription token.
            </summary>
        </member>
        <member name="T:Blockcore.FullNode">
            <summary>
            Node providing all supported features of the blockchain and its network.
            </summary>
        </member>
        <member name="F:Blockcore.FullNode.logger">
            <summary>Instance logger.</summary>
        </member>
        <member name="F:Blockcore.FullNode.loggerFactory">
            <summary>Factory for creating loggers.</summary>
        </member>
        <member name="F:Blockcore.FullNode.fullNodeFeatureExecutor">
            <summary>Component responsible for starting and stopping all the node's features.</summary>
        </member>
        <member name="P:Blockcore.FullNode.Settings">
            <summary>Node command line and configuration file settings.</summary>
        </member>
        <member name="P:Blockcore.FullNode.ChainBehaviorState">
            <summary>Information about the best chain.</summary>
        </member>
        <member name="P:Blockcore.FullNode.InitialBlockDownloadState">
            <summary>Provider of IBD state.</summary>
        </member>
        <member name="P:Blockcore.FullNode.Signals">
            <summary>Provider of notification about newly available blocks and transactions.</summary>
        </member>
        <member name="P:Blockcore.FullNode.State">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.FullNode.StartTime">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.FullNode.ConnectionManager">
            <summary>Component responsible for connections to peers in P2P network.</summary>
        </member>
        <member name="P:Blockcore.FullNode.ChainIndexer">
            <summary>Best chain of block headers from genesis.</summary>
        </member>
        <member name="P:Blockcore.FullNode.AsyncProvider">
            <summary>Factory for creating and execution of asynchronous loops.</summary>
        </member>
        <member name="P:Blockcore.FullNode.Network">
            <summary>Specification of the network the node runs on - regtest/testnet/mainnet.</summary>
        </member>
        <member name="P:Blockcore.FullNode.DataFolder">
            <summary>Contains path locations to folders and files on disk.</summary>
        </member>
        <member name="P:Blockcore.FullNode.DateTimeProvider">
            <summary>Provider of date time functionality.</summary>
        </member>
        <member name="F:Blockcore.FullNode.nodeLifetime">
            <summary>Application life cycle control - triggers when application shuts down.</summary>
        </member>
        <member name="P:Blockcore.FullNode.NodeStats">
            <see cref="T:Blockcore.Utilities.INodeStats"/>
        </member>
        <member name="P:Blockcore.FullNode.NodeLifetime">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.FullNode.Services">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.FullNode.Version">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.FullNode.#ctor">
            <summary>Creates new instance of the <see cref="T:Blockcore.FullNode"/>.</summary>
        </member>
        <member name="M:Blockcore.FullNode.Initialize(Blockcore.Builder.IFullNodeServiceProvider)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.FullNode.Start">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.FullNode.StartPeriodicLog">
            <summary>
            Starts a loop to periodically log statistics about node's status very couple of seconds.
            <para>
            These logs are also displayed on the console.
            </para>
            </summary>
        </member>
        <member name="M:Blockcore.FullNode.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.IFullNode">
            <summary>
            Contract for the full node built by full node builder.
            </summary>
        </member>
        <member name="P:Blockcore.IFullNode.NodeLifetime">
            <summary>Global application life cycle control - triggers when application shuts down.</summary>
        </member>
        <member name="P:Blockcore.IFullNode.DateTimeProvider">
            <summary>Provider of date time functionality.</summary>
        </member>
        <member name="P:Blockcore.IFullNode.Services">
            <summary>Access to DI services and features registered for the full node.</summary>
        </member>
        <member name="P:Blockcore.IFullNode.Network">
            <summary>Specification of the network the node runs on - regtest/testnet/mainnet.</summary>
        </member>
        <member name="P:Blockcore.IFullNode.Version">
            <summary>Software version of the full node.</summary>
        </member>
        <member name="P:Blockcore.IFullNode.State">
            <summary>Provides current state of the node.</summary>
        </member>
        <member name="P:Blockcore.IFullNode.Ntype">
            <summary>
            node type
            </summary>
        </member>
        <member name="P:Blockcore.IFullNode.StartTime">
            <summary>Time the node started.</summary>
        </member>
        <member name="M:Blockcore.IFullNode.Start">
            <summary>
            Starts the full node and all its features.
            </summary>
        </member>
        <member name="M:Blockcore.IFullNode.Initialize(Blockcore.Builder.IFullNodeServiceProvider)">
            <summary>
            Initializes DI services that the node needs.
            </summary>
            <param name="serviceProvider">Provider of DI services.</param>
            <returns>Full node itself to allow fluent code.</returns>
        </member>
        <member name="M:Blockcore.IFullNode.NodeService``1(System.Boolean)">
            <summary>
            Find a service of a particular type
            </summary>
            <typeparam name="T">Class of type</typeparam>
            <param name="failWithDefault">Set to true to return null instead of throwing an error</param>
            <returns></returns>
        </member>
        <member name="M:Blockcore.IFullNode.NodeFeature``1(System.Boolean)">
            <summary>
            Find a feature of a particular type or having a given interface
            </summary>
            <typeparam name="T">Class of interface type</typeparam>
            <param name="failWithError">Set to false to return null instead of throwing an error</param>
            <returns></returns>
        </member>
        <member name="T:Blockcore.FullNodeState">
            <summary>Represents <see cref="T:Blockcore.IFullNode"/> state.</summary>
        </member>
        <member name="F:Blockcore.FullNodeState.Created">
            <summary>Assigned when <see cref="T:Blockcore.IFullNode"/> instance is created.</summary>
        </member>
        <member name="F:Blockcore.FullNodeState.Initializing">
            <summary>Assigned when <see cref="M:Blockcore.IFullNode.Initialize(Blockcore.Builder.IFullNodeServiceProvider)"/> is called.</summary>
        </member>
        <member name="F:Blockcore.FullNodeState.Initialized">
            <summary>Assigned when <see cref="M:Blockcore.IFullNode.Initialize(Blockcore.Builder.IFullNodeServiceProvider)"/> finished executing.</summary>
        </member>
        <member name="F:Blockcore.FullNodeState.Starting">
            <summary>Assigned when <see cref="M:Blockcore.IFullNode.Start"/> is called.</summary>
        </member>
        <member name="F:Blockcore.FullNodeState.Started">
            <summary>Assigned when <see cref="M:Blockcore.IFullNode.Start"/> finished executing.</summary>
        </member>
        <member name="F:Blockcore.FullNodeState.Disposing">
            <summary>Assigned when <see cref="!:IFullNode.Dispose"/> is called.</summary>
        </member>
        <member name="F:Blockcore.FullNodeState.Disposed">
            <summary>Assigned when <see cref="!:IFullNode.Dispose"/> finished executing.</summary>
        </member>
        <member name="T:Blockcore.NodeType">
            <summary>
            
            </summary>
        </member>
        <member name="T:Blockcore.Interfaces.IBlockStore">
            <summary>
            Represent access to the store of <see cref="T:Blockcore.Consensus.BlockInfo.Block"/>.
            </summary>
        </member>
        <member name="M:Blockcore.Interfaces.IBlockStore.Initialize">
            <summary>
            Initializes the blockchain storage and ensure the genesis block has been created in the database.
            </summary>
        </member>
        <member name="M:Blockcore.Interfaces.IBlockStore.GetTransactionById(Blockcore.NBitcoin.uint256)">
            <summary>Retrieve the transaction information asynchronously using transaction id.</summary>
            <param name="trxid">The transaction id to find.</param>
        </member>
        <member name="M:Blockcore.Interfaces.IBlockStore.GetTransactionsByIds(Blockcore.NBitcoin.uint256[],System.Threading.CancellationToken)">
            <summary>Retrieve transactions information asynchronously using transaction ids.</summary>
            <param name="trxids">Ids of transactions to find.</param>
            <returns>List of transactions or <c>null</c> if txindexing is disabled.</returns>
        </member>
        <member name="M:Blockcore.Interfaces.IBlockStore.GetBlockIdByTransactionId(Blockcore.NBitcoin.uint256)">
            <summary>
            Get the corresponding block hash by using transaction hash.
            </summary>
            <param name="trxid">The transaction hash.</param>
        </member>
        <member name="M:Blockcore.Interfaces.IBlockStore.GetBlock(Blockcore.NBitcoin.uint256)">
            <summary>
            Get the block from the database by using block hash.
            </summary>
            <param name="blockHash">The block hash.</param>
        </member>
        <member name="M:Blockcore.Interfaces.IBlockStoreQueue.AddToPending(Blockcore.Consensus.Chain.ChainedHeaderBlock)">
            <summary>Adds a block to the saving queue.</summary>
            <param name="chainedHeaderBlock">The block and its chained header pair to be added to pending storage.</param>
        </member>
        <member name="P:Blockcore.Interfaces.IBlockStoreQueue.BlockStoreCacheTip">
            <summary>The highest stored block in the block store cache or <c>null</c> if block store feature is not enabled.</summary>
        </member>
        <member name="T:Blockcore.Interfaces.IBlockStoreQueueFlushCondition">
            <summary>
            Determines whether or not <see cref="!:BlockStoreQueue"/> should flush it's batch to disk.
            </summary>
        </member>
        <member name="P:Blockcore.Interfaces.IBlockStoreQueueFlushCondition.ShouldFlush">
            <summary>
            Should block store flush to disk.
            <para>
            If consensus tip in IBD or store tip is a distance of more then 5 blocks from consensus tip this will return <c>false</c>.
            </para>
            </summary>
        </member>
        <member name="T:Blockcore.Interfaces.IBroadcastCheck">
            <summary>
            Allow to check a transaction is valid before broadcasting it.
            </summary>
        </member>
        <member name="T:Blockcore.Interfaces.IGetUnspentTransaction">
            <summary>
            An interface used to retrieve unspent transactions
            </summary>
        </member>
        <member name="M:Blockcore.Interfaces.IGetUnspentTransaction.GetUnspentTransactionAsync(Blockcore.Consensus.TransactionInfo.OutPoint)">
            <summary>
            Returns the unspent output for a specific transaction.
            </summary>
            <param name="outPoint">Hash of the transaction to query.</param>
            <returns>Unspent Output</returns>
        </member>
        <member name="T:Blockcore.Interfaces.IInitialBlockDownloadState">
            <summary>
            Provides IBD (Initial Block Download) state.
            </summary>
        </member>
        <member name="M:Blockcore.Interfaces.IInitialBlockDownloadState.IsInitialBlockDownload">
            <summary>
            Checks whether the node is currently in the process of initial block download.
            </summary>
            <returns><c>true</c> if the node is currently doing IBD, <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Blockcore.Interfaces.IPooledGetUnspentTransaction">
            <summary>
            An interface used to retrieve unspent transactions from a pooled source
            </summary>
        </member>
        <member name="T:Blockcore.Interfaces.IProvenBlockHeaderProvider">
            <summary>
            Interface <see cref="T:Blockcore.Consensus.BlockInfo.ProvenBlockHeader"/> provider.
            </summary>
        </member>
        <member name="M:Blockcore.Interfaces.IProvenBlockHeaderProvider.GetAsync(System.Int32)">
            <summary>
            Get a <see cref="T:Blockcore.Consensus.BlockInfo.ProvenBlockHeader"/> corresponding to a block.
            </summary>
            <param name="blockHeight"> Height used to retrieve the <see cref="T:Blockcore.Consensus.BlockInfo.ProvenBlockHeader"/>.</param>
            <returns><see cref="T:Blockcore.Consensus.BlockInfo.ProvenBlockHeader"/> retrieved.</returns>
        </member>
        <member name="P:Blockcore.Interfaces.IProvenBlockHeaderProvider.TipHashHeight">
            <summary>
            Height of the block which is currently the tip of the <see cref="T:Blockcore.Consensus.BlockInfo.ProvenBlockHeader"/>.
            </summary>
        </member>
        <member name="T:Blockcore.Interfaces.IProvenBlockHeaderRepository">
            <summary>
            Interface to insert and retrieve <see cref="T:Blockcore.Consensus.BlockInfo.ProvenBlockHeader"/> items from the database repository.
            </summary>
        </member>
        <member name="M:Blockcore.Interfaces.IProvenBlockHeaderRepository.InitializeAsync">
            <summary>
            Initializes <see cref="T:Blockcore.Consensus.BlockInfo.ProvenBlockHeader"/> items database.
            </summary>
        </member>
        <member name="M:Blockcore.Interfaces.IProvenBlockHeaderRepository.PutAsync(System.Collections.Generic.SortedDictionary{System.Int32,Blockcore.Consensus.BlockInfo.ProvenBlockHeader},Blockcore.Utilities.HashHeightPair)">
            <summary>
            Persists <see cref="T:Blockcore.Consensus.BlockInfo.ProvenBlockHeader"/> items to the database.
            </summary>
            <param name="provenBlockHeaders">List of <see cref="T:Blockcore.Consensus.BlockInfo.ProvenBlockHeader"/> items.</param>
            <param name="newTip">Block hash and height tip.</param>
            <returns><c>true</c> when a <see cref="T:Blockcore.Consensus.BlockInfo.ProvenBlockHeader"/> is saved to disk, otherwise <c>false</c>.</returns>
        </member>
        <member name="T:Blockcore.Interfaces.IProvenBlockHeaderStore">
            <summary>
            Cache layer for <see cref="T:Blockcore.Consensus.BlockInfo.ProvenBlockHeader"/>s.
            </summary>
        </member>
        <member name="M:Blockcore.Interfaces.IProvenBlockHeaderStore.InitializeAsync(Blockcore.Consensus.Chain.ChainedHeader)">
            <summary>
            Initializes the <see cref="T:Blockcore.Interfaces.IProvenBlockHeaderStore"/> at the last common header between <paramref name="chainedHeader"/> and <see cref="P:Blockcore.Interfaces.IProvenBlockHeaderProvider.TipHashHeight"/>.
            </summary>
            <param name="chainedHeader"><see cref="T:Blockcore.Consensus.Chain.ChainedHeader"/> consensus tip after <see cref="T:Blockcore.Consensus.IConsensusManager"/> initialization.</param>
            <returns>Tip at which store was initialized.</returns>
        </member>
        <member name="M:Blockcore.Interfaces.IProvenBlockHeaderStore.AddToPendingBatch(Blockcore.Consensus.BlockInfo.ProvenBlockHeader,Blockcore.Utilities.HashHeightPair)">
            <summary>
            Adds <see cref="T:Blockcore.Consensus.BlockInfo.ProvenBlockHeader"/> items to the pending batch. Ready for saving to disk.
            </summary>
            <param name="provenBlockHeader">A <see cref="T:Blockcore.Consensus.BlockInfo.ProvenBlockHeader"/> item to add.</param>
            <param name="newTip">Hash and height pair that represent the tip of <see cref="T:Blockcore.Interfaces.IProvenBlockHeaderStore"/>.</param>
        </member>
        <member name="M:Blockcore.Interfaces.IProvenBlockHeaderStore.SaveAsync">
            <summary>
            Saves pending <see cref="T:Blockcore.Consensus.BlockInfo.ProvenBlockHeader"/> items to the <see cref="T:Blockcore.Interfaces.IProvenBlockHeaderRepository"/>, then removes the items from the pending batch.
            </summary>
        </member>
        <member name="T:Blockcore.Interfaces.IScriptAddressReader">
            <summary>
            A reader for extracting an address from a Script
            </summary>
        </member>
        <member name="M:Blockcore.Interfaces.IScriptAddressReader.GetAddressFromScriptPubKey(Blockcore.Networks.Network,Blockcore.Consensus.ScriptInfo.Script)">
            <summary>
            Extracts an address from a given Script, if available. Otherwise returns <see cref="F:System.String.Empty"/>
            </summary>
        </member>
        <member name="M:Blockcore.Interfaces.IVersionProvider.GetVersion">
            <summary>
            Returns an overridden version for the particular implementation.
            </summary>
        </member>
        <member name="T:Blockcore.Mining.IBlockProvider">
            <summary>
            The block provider class is called by <see cref="!:PosMinting"/> and <see cref="!:PowMining"/>
            to create a block based on whether or not the node is mining or staking.
            <para>
            The create block logic is abstracted away from the miner or staker so that
            different implementations can be injected via dependency injection.
            </para>
            </summary>
        </member>
        <member name="M:Blockcore.Mining.IBlockProvider.BuildPowBlock(Blockcore.Consensus.Chain.ChainedHeader,Blockcore.Consensus.ScriptInfo.Script)">
            <summary>Builds a proof of work block.</summary>
        </member>
        <member name="M:Blockcore.Mining.IBlockProvider.BuildPosBlock(Blockcore.Consensus.Chain.ChainedHeader,Blockcore.Consensus.ScriptInfo.Script)">
            <summary>Builds a signed proof of stake block with the next difficulty target included in the block header.</summary>
        </member>
        <member name="M:Blockcore.Mining.IBlockProvider.BlockModified(Blockcore.Consensus.Chain.ChainedHeader,Blockcore.Consensus.BlockInfo.Block)">
            <summary>
            Called when the block was modified, used to update the merkle root.
            </summary>
        </member>
        <member name="T:Blockcore.NBitcoin.Base58Data">
            <summary>
            Base class for all Base58 check representation of data
            </summary>
        </member>
        <member name="T:Blockcore.NBitcoin.BIP32.BitcoinExtKey">
            <summary>
            Base58 representation of an ExtKey, within a particular network.
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.BIP32.BitcoinExtKey.#ctor(System.String,Blockcore.Networks.Network)">
            <summary>
            Constructor. Creates an extended key from the Base58 representation, checking the expected network.
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.BIP32.BitcoinExtKey.#ctor(Blockcore.NBitcoin.BIP32.ExtKey,Blockcore.Networks.Network)">
            <summary>
            Constructor. Creates a representation of an extended key, within the specified network.
            </summary>
        </member>
        <member name="P:Blockcore.NBitcoin.BIP32.BitcoinExtKey.IsValid">
            <summary>
            Gets whether the data is the correct expected length.
            </summary>
        </member>
        <member name="P:Blockcore.NBitcoin.BIP32.BitcoinExtKey.ExtKey">
            <summary>
            Gets the extended key, converting from the Base58 representation.
            </summary>
        </member>
        <member name="P:Blockcore.NBitcoin.BIP32.BitcoinExtKey.Type">
            <summary>
            Gets the type of item represented by this Base58 data.
            </summary>
        </member>
        <member name="P:Blockcore.NBitcoin.BIP32.BitcoinExtKey.ScriptPubKey">
            <summary>
            Gets the script of the hash of the public key corresponing to the private key 
            of the extended key of this Base58 item.
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.BIP32.BitcoinExtKey.Neuter">
            <summary>
            Gets the Base58 representation, in the same network, of the neutered extended key.
            </summary>
        </member>
        <member name="P:Blockcore.NBitcoin.BIP32.BitcoinExtKey.PrivateKey">
            <summary>
            Gets the private key of the extended key of this Base58 item.
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.BIP32.BitcoinExtKey.op_Implicit(Blockcore.NBitcoin.BIP32.BitcoinExtKey)~Blockcore.NBitcoin.BIP32.ExtKey">
            <summary>
            Implicit cast from BitcoinExtKey to ExtKey.
            </summary>
        </member>
        <member name="T:Blockcore.NBitcoin.BIP32.BitcoinExtPubKey">
            <summary>
            Base58 representation of an ExtPubKey, within a particular network.
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.BIP32.BitcoinExtPubKey.#ctor(System.String,Blockcore.Networks.Network)">
            <summary>
            Constructor. Creates an extended public key from the Base58 representation, checking the expected network.
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.BIP32.BitcoinExtPubKey.#ctor(Blockcore.NBitcoin.BIP32.ExtPubKey,Blockcore.Networks.Network)">
            <summary>
            Constructor. Creates a representation of an extended public key, within the specified network.
            </summary>
        </member>
        <member name="P:Blockcore.NBitcoin.BIP32.BitcoinExtPubKey.ExtPubKey">
            <summary>
            Gets the extended public key, converting from the Base58 representation.
            </summary>
        </member>
        <member name="P:Blockcore.NBitcoin.BIP32.BitcoinExtPubKey.Type">
            <summary>
            Gets the type of item represented by this Base58 data.
            </summary>
        </member>
        <member name="P:Blockcore.NBitcoin.BIP32.BitcoinExtPubKey.ScriptPubKey">
            <summary>
            Gets the script of the hash of the public key of the extended key of this Base58 item.
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.BIP32.BitcoinExtPubKey.op_Implicit(Blockcore.NBitcoin.BIP32.BitcoinExtPubKey)~Blockcore.NBitcoin.BIP32.ExtPubKey">
            <summary>
            Implicit cast from BitcoinExtPubKey to ExtPubKey.
            </summary>
        </member>
        <member name="T:Blockcore.NBitcoin.BIP32.ExtKey">
            <summary>
            A private Hierarchical Deterministic key
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.BIP32.ExtKey.Parse(System.String,Blockcore.Networks.Network)">
            <summary>
            Parses the Base58 data (checking the network if specified), checks it represents the
            correct type of item, and then returns the corresponding ExtKey.
            </summary>
        </member>
        <member name="P:Blockcore.NBitcoin.BIP32.ExtKey.Depth">
            <summary>
            Gets the depth of this extended key from the root key.
            </summary>
        </member>
        <member name="P:Blockcore.NBitcoin.BIP32.ExtKey.Child">
            <summary>
            Gets the child number of this key (in reference to the parent).
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.BIP32.ExtKey.#ctor(Blockcore.NBitcoin.BIP32.BitcoinExtPubKey,Blockcore.NBitcoin.BitcoinSecret)">
            <summary>
            Constructor. Reconstructs an extended key from the Base58 representations of 
            the public key and corresponding private key.  
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.BIP32.ExtKey.#ctor(Blockcore.NBitcoin.BIP32.ExtPubKey,Blockcore.NBitcoin.Key)">
            <summary>
            Constructor. Creates an extended key from the public key and corresponding private key.  
            </summary>
            <remarks>
            <para>
            The ExtPubKey has the relevant values for child number, depth, chain code, and fingerprint.
            </para>
            </remarks>
        </member>
        <member name="M:Blockcore.NBitcoin.BIP32.ExtKey.#ctor(Blockcore.NBitcoin.Key,System.Byte[],System.Byte,System.Byte[],System.UInt32)">
            <summary>
            Constructor. Creates an extended key from the private key, and specified values for
            chain code, depth, fingerprint, and child number.
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.BIP32.ExtKey.#ctor(Blockcore.NBitcoin.Key,System.Byte[])">
            <summary>
            Constructor. Creates an extended key from the private key, with the specified value
            for chain code. Depth, fingerprint, and child number, will have their default values.
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.BIP32.ExtKey.#ctor">
            <summary>
            Constructor. Creates a new extended key with a random 64 byte seed.
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.BIP32.ExtKey.#ctor(System.String)">
            <summary>
            Constructor. Creates a new extended key from the specified seed bytes, from the given hex string.
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.BIP32.ExtKey.#ctor(System.Byte[])">
            <summary>
            Constructor. Creates a new extended key from the specified seed bytes.
            </summary>
        </member>
        <member name="P:Blockcore.NBitcoin.BIP32.ExtKey.PrivateKey">
            <summary>
            Get the private key of this extended key.
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.BIP32.ExtKey.Neuter">
            <summary>
            Create the public key from this key.
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.BIP32.ExtKey.Derive(System.UInt32)">
            <summary>
            Derives a new extended key in the hierarchy as the given child number.
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.BIP32.ExtKey.Derive(System.Int32,System.Boolean)">
            <summary>
            Derives a new extended key in the hierarchy as the given child number, 
            setting the high bit if hardened is specified.
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.BIP32.ExtKey.Derive(Blockcore.NBitcoin.BIP32.KeyPath)">
            <summary>
            Derives a new extended key in the hierarchy at the given path below the current key,
            by deriving the specified child at each step.
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.BIP32.ExtKey.GetWif(Blockcore.Networks.Network)">
            <summary>
            Converts the extended key to the base58 representation, within the specified network.
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.BIP32.ExtKey.ToString(Blockcore.Networks.Network)">
            <summary>
            Converts the extended key to the base58 representation, as a string, within the specified network.
            </summary>
        </member>
        <member name="P:Blockcore.NBitcoin.BIP32.ExtKey.ScriptPubKey">
            <summary>
            Gets the script of the hash of the public key corresponding to the private key.
            </summary>
        </member>
        <member name="P:Blockcore.NBitcoin.BIP32.ExtKey.IsHardened">
            <summary>
            Gets whether or not this extended key is a hardened child.
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.BIP32.ExtKey.GetParentExtKey(Blockcore.NBitcoin.BIP32.ExtPubKey)">
            <summary>
            Recreates the private key of the parent from the private key of the child 
            combinated with the public key of the parent (hardened children cannot be
            used to recreate the parent).
            </summary>
        </member>
        <member name="T:Blockcore.NBitcoin.BIP32.ExtPubKey">
            <summary>
            A public HD key
            </summary>
        </member>
        <member name="P:Blockcore.NBitcoin.BIP32.ExtPubKey.ScriptPubKey">
            <summary>
            The P2PKH payment script
            </summary>
        </member>
        <member name="T:Blockcore.NBitcoin.BIP32.KeyPath">
            <summary>
            Represent a path in the hierarchy of HD keys (BIP32)
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.BIP32.KeyPath.Parse(System.String)">
            <summary>
            Parse a KeyPath
            </summary>
            <param name="path">The KeyPath formated like 10/0/2'/3</param>
            <returns></returns>
        </member>
        <member name="M:Blockcore.NBitcoin.BIP38.BitcoinEncryptedSecretEC.HashAddress(Blockcore.NBitcoin.BitcoinAddress)">
            <summary>
            Take the first four bytes of SHA256(SHA256(generatedaddress)) and call it addresshash.
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="T:Blockcore.NBitcoin.BIP39.Mnemonic">
            <summary>
            A .NET implementation of the Bitcoin Improvement Proposal - 39 (BIP39)
            BIP39 specification used as reference located here: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki
            Made by thashiznets@yahoo.com.au
            v1.0.1.1
            I  Bitcoin :)
            Bitcoin:1ETQjMkR1NNh4jwLuN5LxY7bMsHC9PUPSV
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.BIP39.Mnemonic.#ctor(Blockcore.NBitcoin.BIP39.Wordlist,System.Byte[])">
            <summary>
            Generate a mnemonic
            </summary>
            <param name="wordList"></param>
            <param name="entropy"></param>
        </member>
        <member name="M:Blockcore.NBitcoin.BIP39.Wordlist.#ctor(System.String[],System.Char,System.String)">
            <summary>
            Constructor used by inheritence only
            </summary>
            <param name="words">The words to be used in the wordlist</param>
        </member>
        <member name="M:Blockcore.NBitcoin.BIP39.Wordlist.WordExists(System.String,System.Int32@)">
            <summary>
            Method to determine if word exists in word list, great for auto language detection
            </summary>
            <param name="word">The word to check for existence</param>
            <returns>Exists (true/false)</returns>
        </member>
        <member name="M:Blockcore.NBitcoin.BIP39.Wordlist.GetWordAtIndex(System.Int32)">
            <summary>
            Returns a string containing the word at the specified index of the wordlist
            </summary>
            <param name="index">Index of word to return</param>
            <returns>Word</returns>
        </member>
        <member name="P:Blockcore.NBitcoin.BIP39.Wordlist.WordCount">
            <summary>
            The number of all the words in the wordlist
            </summary>
        </member>
        <member name="T:Blockcore.NBitcoin.BitcoinScriptAddress">
            <summary>
            Base58 representation of a script hash
            </summary>
        </member>
        <member name="T:Blockcore.NBitcoin.BitcoinAddress">
            <summary>
            Base58 representation of a bitcoin address
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.BitcoinAddress.Create(System.String,Blockcore.Networks.Network)">
            <summary>
            Detect whether the input base58 is a pubkey hash or a script hash
            </summary>
            <param name="str">The string to parse</param>
            <param name="expectedNetwork">The expected network to which it belongs</param>
            <returns>A BitcoinAddress or BitcoinScriptAddress</returns>
            <exception cref="T:System.FormatException">Invalid format</exception>
        </member>
        <member name="M:Blockcore.NBitcoin.BitcoinCore.Coins.Cleanup">
            <summary>
            Remove the last items that are <see cref="M:Blockcore.NBitcoin.BitcoinCore.Coins.IsNull(Blockcore.Consensus.TransactionInfo.TxOut)"/>, this method may reduce the size of the collection.
            </summary>
        </member>
        <member name="T:Blockcore.NBitcoin.BitcoinPubKeyAddress">
            <summary>
            Base58 representation of a pubkey hash and base class for the representation of a script hash
            </summary>
        </member>
        <member name="T:Blockcore.NBitcoin.BitcoinStream">
            <summary>
            A component that performs byte serialization of objects.
            </summary>
        </member>
        <member name="T:Blockcore.NBitcoin.BlockLocator">
            <summary>
            Compact representation of one's chain position which can be used to find forks with another chain.
            </summary>
        </member>
        <member name="F:Blockcore.NBitcoin.BlockLocator.MaxLocatorSize">
            <summary>Maximum number of block hashes in the locator that we will accept in a message from a peer.</summary>
            <seealso cref="!:https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-August/016285.html"/>
            <seealso cref="!:https://github.com/bitcoin/bitcoin/pull/13907"/>
        </member>
        <member name="M:Blockcore.NBitcoin.BlockLocator.ToString">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.NBitcoin.Bloom">
            <summary>
            Type representation of data used in a bloom filter.
            </summary>
        </member>
        <member name="F:Blockcore.NBitcoin.Bloom.BloomLength">
            <summary>
            Length of the bloom data in bytes. 2048 bits.
            </summary>
        </member>
        <member name="F:Blockcore.NBitcoin.Bloom.data">
            <summary>
            The actual bloom value represented as a byte array.
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.Bloom.Or(Blockcore.NBitcoin.Bloom)">
            <summary>
            Given this and another bloom, bitwise-OR all the data to get a bloom filter representing a range of data.
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.Bloom.Add(System.Byte[])">
            <summary>
            Add some input to the bloom filter.
            </summary>
            <remarks>
             From the Ethereum yellow paper (yellowpaper.io):
             M3:2048 is a specialised Bloom filter that sets three bits
             out of 2048, given an arbitrary byte series. It does this through
             taking the low-order 11 bits of each of the first three pairs of
             bytes in a Keccak-256 hash of the byte series.
            </remarks>
        </member>
        <member name="M:Blockcore.NBitcoin.Bloom.Keccak256(System.Byte[])">
            <summary>
            Returns a 32-byte Keccak256 hash of the given bytes.
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:Blockcore.NBitcoin.Bloom.Test(System.Byte[])">
            <summary>
            Determine whether some input is possibly contained within the filter.
            </summary>
            <param name="test">The byte array to test.</param>
            <returns>Whether this data could be contained within the filter.</returns>
        </member>
        <member name="M:Blockcore.NBitcoin.Bloom.Test(Blockcore.NBitcoin.Bloom)">
            <summary>
            Determine whether a second bloom is possibly contained within the filter.
            </summary>
            <param name="bloom">The second bloom to test.</param>
            <returns>Whether this data could be contained within the filter.</returns>
        </member>
        <member name="M:Blockcore.NBitcoin.Bloom.SetBit(System.Int32)">
            <summary>
            Sets the specific bit to 1 within our 256-byte array.
            </summary>
            <param name="index">Index (0-2047) of the bit to assign to 1.</param>
        </member>
        <member name="M:Blockcore.NBitcoin.Bloom.ToBytes">
            <summary>
            Returns the raw bytes of this filter.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Blockcore.NBitcoin.Bloom.GetCompressedBloom">
            <summary>
            Compresses a bloom filter to the following encoding:
              (length of encoding) [[(number of zeros)(explicit byte) ...]
            </summary>
            <param name="maxSize">The maximum size of the compressed bytes.</param>
            <returns>The compressed bytes  or <c>null</c> if <paramref name="maxSize"/> is exceeded.</returns>
        </member>
        <member name="M:Blockcore.NBitcoin.Bloom.GetDecompressedBloom(System.Byte[])">
            <summary>
            Derives a bloom filter by decompressing the following encoding:
              (length of encoding) [[(number of zeros)(explicit byte) ...]
            </summary>
            <param name="data">The data to decompress.</param>
            <returns>The bloom object.</returns>
        </member>
        <member name="T:Blockcore.NBitcoin.BloomFilter">
            <summary>
            Used by SPV client, represent the set of interesting addresses tracked by SPV client with plausible deniability
            </summary>
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.asn1.Asn1InputStream">
            a general purpose ASN.1 decoder - note: this class differs from the
            others in that it returns null after it has read the last object in
            the stream. If an ASN.1 Null is encountered a Der/BER Null object is
            returned.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.asn1.Asn1InputStream.#ctor(System.IO.Stream,System.Int32)">
             Create an ASN1InputStream where no DER object will be longer than limit.
            
             @param input stream containing ASN.1 encoded data.
             @param limit maximum size of a DER encoded object.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.asn1.Asn1InputStream.#ctor(System.Byte[])">
             Create an ASN1InputStream based on the input byte array. The length of DER objects in
             the stream is automatically limited to the length of the input array.
            
             @param input array containing ASN.1 encoded data.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.asn1.Asn1InputStream.BuildObject(System.Int32,System.Int32,System.Int32)">
            build an object given its tag and the number of bytes to construct it from.
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.asn1.Asn1Null">
            A Null object.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.asn1.Asn1Object.FromByteArray(System.Byte[])">
            <summary>Create a base ASN.1 object from a byte array.</summary>
            <param name="data">The byte array to parse.</param>
            <returns>The base ASN.1 object represented by the byte array.</returns>
            <exception cref="T:System.IO.IOException">If there is a problem parsing the data.</exception>
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.asn1.Asn1Object.FromStream(System.IO.Stream)">
            <summary>Read a base ASN.1 object from a stream.</summary>
            <param name="inStr">The stream to parse.</param>
            <returns>The base ASN.1 object represented by the byte array.</returns>
            <exception cref="T:System.IO.IOException">If there is a problem parsing the data.</exception>
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.asn1.Asn1OctetString.#ctor(System.Byte[])">
            @param string the octets making up the octet string.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.asn1.Asn1Sequence.GetInstance(System.Object)">
             return an Asn1Sequence from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="P:Blockcore.NBitcoin.BouncyCastle.asn1.Asn1Sequence.Item(System.Int32)">
             return the object at the sequence position indicated by index.
            
             @param index the sequence number (starting at zero) of the object
             @return the object at the sequence position indicated by index.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.asn1.DerInteger.GetInstance(System.Object)">
             return an integer from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="P:Blockcore.NBitcoin.BouncyCastle.asn1.DerInteger.PositiveValue">
            in some cases positive values Get crammed into a space,
            that's not quite big enough...
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.asn1.DerNull">
            A Null object.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.asn1.DerObjectIdentifier.On(Blockcore.NBitcoin.BouncyCastle.asn1.DerObjectIdentifier)">
            Return  true if this oid is an extension of the passed in branch, stem.
            @param stem the arc or branch that is a possible parent.
            @return  true if the branch is on the passed in stem, false otherwise.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.asn1.DerOctetString.#ctor(System.Byte[])">
            <param name="str">The octets making up the octet string.</param>
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.asn1.DerSequence.#ctor">
            create an empty sequence
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.asn1.DerSequence.#ctor(Blockcore.NBitcoin.BouncyCastle.asn1.Asn1Encodable)">
            create a sequence containing one object
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.asn1.DerSequence.#ctor(Blockcore.NBitcoin.BouncyCastle.asn1.Asn1EncodableVector)">
            create a sequence containing a vector of objects.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.asn1.sec.SecNamedCurves.GetByOid(Blockcore.NBitcoin.BouncyCastle.asn1.DerObjectIdentifier)">
             return the X9ECParameters object for the named curve represented by
             the passed in object identifier. Null if the curve isn't present.
            
             @param oid an object identifier representing a named curve, if present.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.asn1.sec.SecNamedCurves.GetOid(System.String)">
             return the object identifier signified by the passed in name. Null
             if there is no object identifier associated with name.
            
             @return the object identifier associated with name, if present.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.asn1.sec.SecNamedCurves.GetName(Blockcore.NBitcoin.BouncyCastle.asn1.DerObjectIdentifier)">
            return the named curve name represented by the given object identifier.
        </member>
        <member name="F:Blockcore.NBitcoin.BouncyCastle.asn1.sec.SecObjectIdentifiers.EllipticCurve">
            EllipticCurve OBJECT IDENTIFIER ::= {
                  iso(1) identified-organization(3) certicom(132) curve(0)
            }
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.asn1.x9.X9Curve">
            ASN.1 def for Elliptic-Curve Curve structure. See
            X9.62, for further details.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.asn1.x9.X9Curve.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             Curve ::= Sequence {
                 a               FieldElement,
                 b               FieldElement,
                 seed            BIT STRING      OPTIONAL
             }
            </pre>
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.asn1.x9.X9ECParameters">
            ASN.1 def for Elliptic-Curve ECParameters structure. See
            X9.62, for further details.
        </member>
        <member name="P:Blockcore.NBitcoin.BouncyCastle.asn1.x9.X9ECParameters.CurveEntry">
             Return the ASN.1 entry representing the Curve.
            
             @return the X9Curve for the curve in these parameters.
        </member>
        <member name="P:Blockcore.NBitcoin.BouncyCastle.asn1.x9.X9ECParameters.FieldIDEntry">
             Return the ASN.1 entry representing the FieldID.
            
             @return the X9FieldID for the FieldID in these parameters.
        </member>
        <member name="P:Blockcore.NBitcoin.BouncyCastle.asn1.x9.X9ECParameters.BaseEntry">
             Return the ASN.1 entry representing the base point G.
            
             @return the X9ECPoint for the base point in these parameters.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.asn1.x9.X9ECParameters.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             ECParameters ::= Sequence {
                 version         Integer { ecpVer1(1) } (ecpVer1),
                 fieldID         FieldID {{FieldTypes}},
                 curve           X9Curve,
                 base            X9ECPoint,
                 order           Integer,
                 cofactor        Integer OPTIONAL
             }
            </pre>
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.asn1.x9.X9ECPoint">
            class for describing an ECPoint as a Der object.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.asn1.x9.X9ECPoint.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             ECPoint ::= OCTET STRING
            </pre>
            <p>
            Octet string produced using ECPoint.GetEncoded().</p>
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.asn1.x9.X9FieldElement">
            Class for processing an ECFieldElement as a DER object.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.asn1.x9.X9FieldElement.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             FieldElement ::= OCTET STRING
            </pre>
            <p>
            <ol>
            <li> if <i>q</i> is an odd prime then the field element is
            processed as an Integer and converted to an octet string
            according to x 9.62 4.3.1.</li>
            <li> if <i>q</i> is 2<sup>m</sup> then the bit string
            contained in the field element is converted into an octet
            string with the same ordering padded at the front if necessary.
            </li>
            </ol>
            </p>
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.asn1.x9.X9FieldID">
            ASN.1 def for Elliptic-Curve Field ID structure. See
            X9.62, for further details.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.asn1.x9.X9FieldID.#ctor(Blockcore.NBitcoin.BouncyCastle.math.BigInteger)">
            Constructor for elliptic curves over prime fields
            <code>F<sub>2</sub></code>.
            @param primeP The prime <code>p</code> defining the prime field.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.asn1.x9.X9FieldID.#ctor(System.Int32,System.Int32)">
            Constructor for elliptic curves over binary fields
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.asn1.x9.X9FieldID.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            Constructor for elliptic curves over binary fields
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>..
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.asn1.x9.X9FieldID.ToAsn1Object">
            Produce a Der encoding of the following structure.
            <pre>
             FieldID ::= Sequence {
                 fieldType       FIELD-ID.&amp;id({IOSet}),
                 parameters      FIELD-ID.&amp;Type({IOSet}{&#64;fieldType})
             }
            </pre>
        </member>
        <member name="F:Blockcore.NBitcoin.BouncyCastle.asn1.x9.X9ObjectIdentifiers.IdDsaWithSha1">
            id-dsa-with-sha1 OBJECT IDENTIFIER ::=  { iso(1) member-body(2)
                  us(840) x9-57 (10040) x9cm(4) 3 }
        </member>
        <member name="F:Blockcore.NBitcoin.BouncyCastle.asn1.x9.X9ObjectIdentifiers.X9x63Scheme">
            X9.63
        </member>
        <member name="F:Blockcore.NBitcoin.BouncyCastle.asn1.x9.X9ObjectIdentifiers.ansi_x9_42">
            X9.42
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.crypto.BufferedBlockCipher">
            A wrapper class that allows block ciphers to be used to process data in
            a piecemeal fashion. The BufferedBlockCipher outputs a block only when the
            buffer is full and more data is being added, or on a doFinal.
            <p>
            Note: in the case where the underlying cipher is either a CFB cipher or an
            OFB one the last block may not be a multiple of the block size.
            </p>
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.BufferedBlockCipher.#ctor">
            constructor for subclasses
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.BufferedBlockCipher.#ctor(Blockcore.NBitcoin.BouncyCastle.crypto.IBlockCipher)">
             Create a buffered block cipher without padding.
            
             @param cipher the underlying block cipher this buffering object wraps.
             false otherwise.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.BufferedBlockCipher.Init(System.Boolean,Blockcore.NBitcoin.BouncyCastle.crypto.ICipherParameters)">
             initialise the cipher.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.BufferedBlockCipher.GetBlockSize">
             return the blocksize for the underlying cipher.
            
             @return the blocksize for the underlying cipher.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.BufferedBlockCipher.GetUpdateOutputSize(System.Int32)">
             return the size of the output buffer required for an update
             an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update
             with len bytes of input.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.BufferedBlockCipher.GetOutputSize(System.Int32)">
             return the size of the output buffer required for an update plus a
             doFinal with an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update and doFinal
             with len bytes of input.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.BufferedBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             process a single byte, producing an output block if necessary.
            
             @param in the input byte.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.BufferedBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process an array of bytes, producing output if necessary.
            
             @param in the input byte array.
             @param inOff the offset at which the input data starts.
             @param len the number of bytes to be copied out of the input array.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.BufferedBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Process the last block in the buffer.
            
             @param out the array the block currently being held is copied into.
             @param outOff the offset at which the copying starts.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there is insufficient space in out for
             the output, or the input is not block size aligned and should be.
             @exception InvalidOperationException if the underlying cipher is not
             initialised.
             @exception InvalidCipherTextException if padding is expected and not found.
             @exception DataLengthException if the input is not block size
             aligned.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.BufferedBlockCipher.Reset">
            Reset the buffer and cipher. After resetting the object is in the same
            state as it was after the last init (if there was one).
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.crypto.DataLengthException">
            this exception is thrown if a buffer that is meant to have output
            copied into it turns out to be too short, or if we've been given
            insufficient input. In general this exception will Get thrown rather
            than an ArrayOutOfBounds exception.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.DataLengthException.#ctor">
            base constructor.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.DataLengthException.#ctor(System.String)">
             create a DataLengthException with the given message.
            
             @param message the message to be carried with the exception.
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.crypto.digests.GeneralDigest">
            base implementation of MD4 family style digest as outlined in
            "Handbook of Applied Cryptography", pages 344 - 347.
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.crypto.digests.LongDigest">
            Base class for SHA-384 and SHA-512.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.digests.LongDigest.#ctor">
            Constructor for variable length word
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.digests.LongDigest.#ctor(Blockcore.NBitcoin.BouncyCastle.crypto.digests.LongDigest)">
            Copy constructor.  We are using copy constructors in place
            of the object.Clone() interface as this interface is not
            supported by J2ME.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.digests.LongDigest.AdjustByteCounts">
            adjust the byte counts so that byteCount2 represents the
            upper long (less 3 bits) word of the byte count.
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.crypto.digests.RipeMD160Digest">
            implementation of RipeMD see,
            http://www.esat.kuleuven.ac.be/~bosselae/ripemd160.html
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.digests.RipeMD160Digest.#ctor">
            Standard constructor
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.digests.RipeMD160Digest.#ctor(Blockcore.NBitcoin.BouncyCastle.crypto.digests.RipeMD160Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.digests.RipeMD160Digest.Reset">
            reset the chaining variables to the IV values.
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.crypto.digests.Sha1Digest">
             implementation of SHA-1 as outlined in "Handbook of Applied Cryptography", pages 346 - 349.
            
             It is interesting to ponder why the, apart from the extra IV, the other difference here from MD5
             is the "endianness" of the word processing!
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.digests.Sha1Digest.#ctor(Blockcore.NBitcoin.BouncyCastle.crypto.digests.Sha1Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.digests.Sha1Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.crypto.digests.Sha224Digest">
            SHA-224 as described in RFC 3874
            <pre>
                    block  word  digest
            SHA-1   512    32    160
            SHA-224 512    32    224
            SHA-256 512    32    256
            SHA-384 1024   64    384
            SHA-512 1024   64    512
            </pre>
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.digests.Sha224Digest.#ctor">
            Standard constructor
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.digests.Sha224Digest.#ctor(Blockcore.NBitcoin.BouncyCastle.crypto.digests.Sha224Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.digests.Sha224Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.crypto.digests.Sha256Digest">
             Draft FIPS 180-2 implementation of SHA-256. <b>Note:</b> As this is
             based on a draft this implementation is subject to change.
            
             <pre>
                     block  word  digest
             SHA-1   512    32    160
             SHA-256 512    32    256
             SHA-384 1024   64    384
             SHA-512 1024   64    512
             </pre>
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.digests.Sha256Digest.#ctor(Blockcore.NBitcoin.BouncyCastle.crypto.digests.Sha256Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.digests.Sha256Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.crypto.digests.Sha384Digest">
             Draft FIPS 180-2 implementation of SHA-384. <b>Note:</b> As this is
             based on a draft this implementation is subject to change.
            
             <pre>
                     block  word  digest
             SHA-1   512    32    160
             SHA-256 512    32    256
             SHA-384 1024   64    384
             SHA-512 1024   64    512
             </pre>
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.digests.Sha384Digest.#ctor(Blockcore.NBitcoin.BouncyCastle.crypto.digests.Sha384Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.digests.Sha384Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.crypto.digests.Sha512Digest">
             Draft FIPS 180-2 implementation of SHA-512. <b>Note:</b> As this is
             based on a draft this implementation is subject to change.
            
             <pre>
                     block  word  digest
             SHA-1   512    32    160
             SHA-256 512    32    256
             SHA-384 1024   64    384
             SHA-512 1024   64    512
             </pre>
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.digests.Sha512Digest.#ctor(Blockcore.NBitcoin.BouncyCastle.crypto.digests.Sha512Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.digests.Sha512Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.crypto.engines.AesEngine">
             an implementation of the AES (Rijndael), from FIPS-197.
             <p>
             For further details see: <a href="http://csrc.nist.gov/encryption/aes/">http://csrc.nist.gov/encryption/aes/</a>.
            
             This implementation is based on optimizations from Dr. Brian Gladman's paper and C code at
             <a href="http://fp.gladman.plus.com/cryptography_technology/rijndael/">http://fp.gladman.plus.com/cryptography_technology/rijndael/</a>
            
             There are three levels of tradeoff of speed vs memory
             Because java has no preprocessor, they are written as three separate classes from which to choose
            
             The fastest uses 8Kbytes of static tables to precompute round calculations, 4 256 word tables for encryption
             and 4 for decryption.
            
             The middle performance version uses only one 256 word table for each, for a total of 2Kbytes,
             adding 12 rotate operations per round to compute the values contained in the other tables from
             the contents of the first.
            
             The slowest version uses no static tables at all and computes the values in each round.
             </p>
             <p>
             This file contains the middle performance version with 2Kbytes of static tables for round precomputation.
             </p>
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.engines.AesEngine.GenerateWorkingKey(System.Byte[],System.Boolean)">
            Calculate the necessary round keys
            The number of calculations depends on key size and block size
            AES specified a fixed block size of 128 bits and key sizes 128/192/256 bits
            This code is written assuming those are the only possible values
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.engines.AesEngine.#ctor">
            default constructor - 128 bit block size.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.engines.AesEngine.Init(System.Boolean,Blockcore.NBitcoin.BouncyCastle.crypto.ICipherParameters)">
             initialise an AES cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.crypto.engines.AesFastEngine">
             an implementation of the AES (Rijndael)), from FIPS-197.
             <p>
             For further details see: <a href="http://csrc.nist.gov/encryption/aes/">http://csrc.nist.gov/encryption/aes/</a>.
            
             This implementation is based on optimizations from Dr. Brian Gladman's paper and C code at
             <a href="http://fp.gladman.plus.com/cryptography_technology/rijndael/">http://fp.gladman.plus.com/cryptography_technology/rijndael/</a>
            
             There are three levels of tradeoff of speed vs memory
             Because java has no preprocessor), they are written as three separate classes from which to choose
            
             The fastest uses 8Kbytes of static tables to precompute round calculations), 4 256 word tables for encryption
             and 4 for decryption.
            
             The middle performance version uses only one 256 word table for each), for a total of 2Kbytes),
             adding 12 rotate operations per round to compute the values contained in the other tables from
             the contents of the first
            
             The slowest version uses no static tables at all and computes the values in each round
             </p>
             <p>
             This file contains the fast version with 8Kbytes of static tables for round precomputation
             </p>
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.engines.AesFastEngine.GenerateWorkingKey(System.Byte[],System.Boolean)">
            Calculate the necessary round keys
            The number of calculations depends on key size and block size
            AES specified a fixed block size of 128 bits and key sizes 128/192/256 bits
            This code is written assuming those are the only possible values
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.engines.AesFastEngine.#ctor">
            default constructor - 128 bit block size.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.engines.AesFastEngine.Init(System.Boolean,Blockcore.NBitcoin.BouncyCastle.crypto.ICipherParameters)">
             initialise an AES cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.crypto.IAsymmetricBlockCipher">
            <remarks>Base interface for a public/private key block cipher.</remarks>
        </member>
        <member name="P:Blockcore.NBitcoin.BouncyCastle.crypto.IAsymmetricBlockCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.IAsymmetricBlockCipher.Init(System.Boolean,Blockcore.NBitcoin.BouncyCastle.crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">Initialise for encryption if true, for decryption if false.</param>
            <param name="parameters">The key or other data required by the cipher.</param>
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.IAsymmetricBlockCipher.GetInputBlockSize">
            <returns>The maximum size, in bytes, an input block may be.</returns>
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.IAsymmetricBlockCipher.GetOutputBlockSize">
            <returns>The maximum size, in bytes, an output block will be.</returns>
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.IAsymmetricBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>Process a block.</summary>
            <param name="inBuf">The input buffer.</param>
            <param name="inOff">The offset into <paramref>inBuf</paramref> that the input block begins.</param>
            <param name="inLen">The length of the input block.</param>
            <exception cref="T:Blockcore.NBitcoin.BouncyCastle.crypto.InvalidCipherTextException">Input decrypts improperly.</exception>
            <exception cref="T:Blockcore.NBitcoin.BouncyCastle.crypto.DataLengthException">Input is too large for the cipher.</exception>
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.crypto.IBlockCipher">
            <remarks>Base interface for a symmetric key block cipher.</remarks>
        </member>
        <member name="P:Blockcore.NBitcoin.BouncyCastle.crypto.IBlockCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.IBlockCipher.Init(System.Boolean,Blockcore.NBitcoin.BouncyCastle.crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">Initialise for encryption if true, for decryption if false.</param>
            <param name="parameters">The key or other data required by the cipher.</param>
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.IBlockCipher.GetBlockSize">
            <returns>The block size for this cipher, in bytes.</returns>
        </member>
        <member name="P:Blockcore.NBitcoin.BouncyCastle.crypto.IBlockCipher.IsPartialBlockOkay">
            <summary>Indicates whether this cipher can handle partial blocks.</summary>
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.IBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>Process a block.</summary>
            <param name="inBuf">The input buffer.</param>
            <param name="inOff">The offset into <paramref>inBuf</paramref> that the input block begins.</param>
            <param name="outBuf">The output buffer.</param>
            <param name="outOff">The offset into <paramref>outBuf</paramref> to write the output block.</param>
            <exception cref="T:Blockcore.NBitcoin.BouncyCastle.crypto.DataLengthException">If input block is wrong size, or outBuf too small.</exception>
            <returns>The number of bytes processed and produced.</returns>
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.IBlockCipher.Reset">
            <summary>
            Reset the cipher to the same state as it was after the last init (if there was one).
            </summary>
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.crypto.IBufferedCipher">
            <remarks>Block cipher engines are expected to conform to this interface.</remarks>
        </member>
        <member name="P:Blockcore.NBitcoin.BouncyCastle.crypto.IBufferedCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.IBufferedCipher.Init(System.Boolean,Blockcore.NBitcoin.BouncyCastle.crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">If true the cipher is initialised for encryption,
            if false for decryption.</param>
            <param name="parameters">The key and other data required by the cipher.</param>
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.IBufferedCipher.Reset">
            <summary>
            Reset the cipher. After resetting the cipher is in the same state
            as it was after the last init (if there was one).
            </summary>
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.crypto.ICipherParameters">
            all parameter classes implement this.
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.crypto.IDigest">
            interface that a message digest conforms to.
        </member>
        <member name="P:Blockcore.NBitcoin.BouncyCastle.crypto.IDigest.AlgorithmName">
             return the algorithm name
            
             @return the algorithm name
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.IDigest.GetDigestSize">
             return the size, in bytes, of the digest produced by this message digest.
            
             @return the size, in bytes, of the digest produced by this message digest.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.IDigest.GetByteLength">
             return the size, in bytes, of the internal buffer used by this digest.
            
             @return the size, in bytes, of the internal buffer used by this digest.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.IDigest.Update(System.Byte)">
             update the message digest with a single byte.
            
             @param inByte the input byte to be entered.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.IDigest.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
             update the message digest with a block of bytes.
            
             @param input the byte array containing the data.
             @param inOff the offset into the byte array where the data starts.
             @param len the length of the data.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.IDigest.DoFinal(System.Byte[],System.Int32)">
             Close the digest, producing the final digest value. The doFinal
             call leaves the digest reset.
            
             @param output the array the digest is to be copied into.
             @param outOff the offset into the out array the digest is to start at.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.IDigest.Reset">
            reset the digest back to it's initial state.
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.crypto.IDsa">
            interface for classes implementing the Digital Signature Algorithm
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.IDsa.Init(System.Boolean,Blockcore.NBitcoin.BouncyCastle.crypto.ICipherParameters)">
             initialise the signer for signature generation or signature
             verification.
            
             @param forSigning true if we are generating a signature, false
             otherwise.
             @param param key parameters for signature generation.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.IDsa.GenerateSignature(System.Byte[])">
             sign the passed in message (usually the output of a hash function).
            
             @param message the message to be signed.
             @return two big integers representing the r and s values respectively.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.IDsa.VerifySignature(System.Byte[],Blockcore.NBitcoin.BouncyCastle.math.BigInteger,Blockcore.NBitcoin.BouncyCastle.math.BigInteger)">
             verify the message message against the signature values r and s.
            
             @param message the message that was supposed to have been signed.
             @param r the r signature value.
             @param s the s signature value.
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.crypto.IMac">
            The base interface for implementations of message authentication codes (MACs).
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.IMac.Init(Blockcore.NBitcoin.BouncyCastle.crypto.ICipherParameters)">
             Initialise the MAC.
            
             @param param the key and other data required by the MAC.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="P:Blockcore.NBitcoin.BouncyCastle.crypto.IMac.AlgorithmName">
             Return the name of the algorithm the MAC implements.
            
             @return the name of the algorithm the MAC implements.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.IMac.GetMacSize">
             Return the block size for this MAC (in bytes).
            
             @return the block size for this MAC in bytes.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.IMac.Update(System.Byte)">
             add a single byte to the mac for processing.
            
             @param in the byte to be processed.
             @exception InvalidOperationException if the MAC is not initialised.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.IMac.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            @param in the array containing the input.
            @param inOff the index in the array the data begins at.
            @param len the length of the input starting at inOff.
            @exception InvalidOperationException if the MAC is not initialised.
            @exception DataLengthException if there isn't enough data in in.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.IMac.DoFinal(System.Byte[],System.Int32)">
            Compute the final stage of the MAC writing the output to the out
            parameter.
            <p>
            doFinal leaves the MAC in the same state it was after the last init.
            </p>
            @param out the array the MAC is to be output to.
            @param outOff the offset into the out buffer the output is to start at.
            @exception DataLengthException if there isn't enough space in out.
            @exception InvalidOperationException if the MAC is not initialised.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.IMac.Reset">
            Reset the MAC. At the end of resetting the MAC should be in the
            in the same state it was after the last init (if there was one).
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.crypto.InvalidCipherTextException">
            this exception is thrown whenever we find something we don't expect in a
            message.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.InvalidCipherTextException.#ctor">
            base constructor.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.InvalidCipherTextException.#ctor(System.String)">
             create a InvalidCipherTextException with the given message.
            
             @param message the message to be carried with the exception.
        </member>
        <member name="P:Blockcore.NBitcoin.BouncyCastle.crypto.ISigner.AlgorithmName">
             Return the name of the algorithm the signer implements.
            
             @return the name of the algorithm the signer implements.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.ISigner.Init(System.Boolean,Blockcore.NBitcoin.BouncyCastle.crypto.ICipherParameters)">
             Initialise the signer for signing or verification.
            
             @param forSigning true if for signing, false otherwise
             @param param necessary parameters.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.ISigner.Update(System.Byte)">
            update the internal digest with the byte b
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.ISigner.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            update the internal digest with the byte array in
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.ISigner.GenerateSignature">
            Generate a signature for the message we've been loaded with using
            the key we were initialised with.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.ISigner.VerifySignature(System.Byte[])">
            return true if the internal state represents the signature described
            in the passed in array.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.ISigner.Reset">
            reset the internal state
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.crypto.macs.HMac">
             HMAC implementation based on RFC2104
            
             H(K XOR opad, H(K XOR ipad, text))
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.macs.HMac.Reset">
            Reset the mac generator.
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.crypto.paddings.IBlockCipherPadding">
            Block cipher padders are expected to conform to this interface
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.paddings.IBlockCipherPadding.Init(Blockcore.NBitcoin.BouncyCastle.security.SecureRandom)">
             Initialise the padder.
            
             @param param parameters, if any required.
        </member>
        <member name="P:Blockcore.NBitcoin.BouncyCastle.crypto.paddings.IBlockCipherPadding.PaddingName">
             Return the name of the algorithm the cipher implements.
            
             @return the name of the algorithm the cipher implements.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.paddings.IBlockCipherPadding.AddPadding(System.Byte[],System.Int32)">
            add the pad bytes to the passed in block, returning the
            number of bytes added.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.paddings.IBlockCipherPadding.PadCount(System.Byte[])">
            return the number of pad bytes present in the block.
            @exception InvalidCipherTextException if the padding is badly formed
            or invalid.
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.crypto.paddings.PaddedBufferedBlockCipher">
            A wrapper class that allows block ciphers to be used to process data in
            a piecemeal fashion with padding. The PaddedBufferedBlockCipher
            outputs a block only when the buffer is full and more data is being added,
            or on a doFinal (unless the current block in the buffer is a pad block).
            The default padding mechanism used is the one outlined in Pkcs5/Pkcs7.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.paddings.PaddedBufferedBlockCipher.#ctor(Blockcore.NBitcoin.BouncyCastle.crypto.IBlockCipher,Blockcore.NBitcoin.BouncyCastle.crypto.paddings.IBlockCipherPadding)">
             Create a buffered block cipher with the desired padding.
            
             @param cipher the underlying block cipher this buffering object wraps.
             @param padding the padding type.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.paddings.PaddedBufferedBlockCipher.#ctor(Blockcore.NBitcoin.BouncyCastle.crypto.IBlockCipher)">
             Create a buffered block cipher Pkcs7 padding
            
             @param cipher the underlying block cipher this buffering object wraps.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.paddings.PaddedBufferedBlockCipher.Init(System.Boolean,Blockcore.NBitcoin.BouncyCastle.crypto.ICipherParameters)">
             initialise the cipher.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.paddings.PaddedBufferedBlockCipher.GetOutputSize(System.Int32)">
             return the minimum size of the output buffer required for an update
             plus a doFinal with an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update and doFinal
             with len bytes of input.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.paddings.PaddedBufferedBlockCipher.GetUpdateOutputSize(System.Int32)">
             return the size of the output buffer required for an update
             an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update
             with len bytes of input.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.paddings.PaddedBufferedBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             process a single byte, producing an output block if necessary.
            
             @param in the input byte.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.paddings.PaddedBufferedBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process an array of bytes, producing output if necessary.
            
             @param in the input byte array.
             @param inOff the offset at which the input data starts.
             @param len the number of bytes to be copied out of the input array.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.paddings.PaddedBufferedBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Process the last block in the buffer. If the buffer is currently
             full and padding needs to be added a call to doFinal will produce
             2 * GetBlockSize() bytes.
            
             @param out the array the block currently being held is copied into.
             @param outOff the offset at which the copying starts.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there is insufficient space in out for
             the output or we are decrypting and the input is not block size aligned.
             @exception InvalidOperationException if the underlying cipher is not
             initialised.
             @exception InvalidCipherTextException if padding is expected and not found.
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.crypto.paddings.Pkcs7Padding">
            A padder that adds Pkcs7/Pkcs5 padding to a block.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.paddings.Pkcs7Padding.Init(Blockcore.NBitcoin.BouncyCastle.security.SecureRandom)">
             Initialise the padder.
            
             @param random - a SecureRandom if available.
        </member>
        <member name="P:Blockcore.NBitcoin.BouncyCastle.crypto.paddings.Pkcs7Padding.PaddingName">
             Return the name of the algorithm the cipher implements.
            
             @return the name of the algorithm the cipher implements.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.paddings.Pkcs7Padding.AddPadding(System.Byte[],System.Int32)">
            add the pad bytes to the passed in block, returning the
            number of bytes added.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.paddings.Pkcs7Padding.PadCount(System.Byte[])">
            return the number of pad bytes present in the block.
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.crypto.signers.ECDsaSigner">
            EC-DSA as described in X9.62
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.signers.ECDsaSigner.#ctor">
            Default configuration, random K values.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.signers.ECDsaSigner.#ctor(Blockcore.NBitcoin.BouncyCastle.crypto.signers.IDsaKCalculator)">
             Configuration with an alternate, possibly deterministic calculator of K.
            
             @param kCalculator a K value calculator.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.signers.ECDsaSigner.GenerateSignature(System.Byte[])">
             Generate a signature for the given message using the key we were
             initialised with. For conventional DSA the message should be a SHA-1
             hash of the message of interest.
            
             @param message the message that will be verified later.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.signers.ECDsaSigner.VerifySignature(System.Byte[],Blockcore.NBitcoin.BouncyCastle.math.BigInteger,Blockcore.NBitcoin.BouncyCastle.math.BigInteger)">
            return true if the value r and s represent a DSA signature for
            the passed in message (for standard DSA the message should be
            a SHA-1 hash of the real message to be verified).
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.crypto.signers.HMacDsaKCalculator">
            A deterministic K calculator based on the algorithm in section 3.2 of RFC 6979.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.signers.HMacDsaKCalculator.#ctor(Blockcore.NBitcoin.BouncyCastle.crypto.IDigest)">
             Base constructor.
            
             @param digest digest to build the HMAC on.
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.crypto.signers.IDsaKCalculator">
            Interface define calculators of K values for DSA/ECDSA.
        </member>
        <member name="P:Blockcore.NBitcoin.BouncyCastle.crypto.signers.IDsaKCalculator.IsDeterministic">
             Return true if this calculator is deterministic, false otherwise.
            
             @return true if deterministic, otherwise false.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.signers.IDsaKCalculator.Init(Blockcore.NBitcoin.BouncyCastle.math.BigInteger,Blockcore.NBitcoin.BouncyCastle.security.SecureRandom)">
             Non-deterministic initialiser.
            
             @param n the order of the DSA group.
             @param random a source of randomness.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.signers.IDsaKCalculator.Init(Blockcore.NBitcoin.BouncyCastle.math.BigInteger,Blockcore.NBitcoin.BouncyCastle.math.BigInteger,System.Byte[])">
             Deterministic initialiser.
            
             @param n the order of the DSA group.
             @param d the DSA private value.
             @param message the message being signed.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.crypto.signers.IDsaKCalculator.NextK">
             Return the next valid value of K.
            
             @return a K value.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.BigInteger.AddMagnitudes(System.Int32[],System.Int32[])">
            return a = a + b - b preserved.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.BigInteger.CompareTo(System.Int32,System.Int32[],System.Int32,System.Int32[])">
            unsigned comparison on two arrays - note the arrays may
            start with leading zeros.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.BigInteger.Divide(System.Int32[],System.Int32[])">
            return z = x / y - done in place (z value preserved, x contains the
            remainder)
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.BigInteger.IsProbablePrime(System.Int32)">
            return whether or not a BigInteger is probably prime with a
            probability of 1 - (1/2)**certainty.
            <p>From Knuth Vol 2, pg 395.</p>
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.BigInteger.ExtEuclid(Blockcore.NBitcoin.BouncyCastle.math.BigInteger,Blockcore.NBitcoin.BouncyCastle.math.BigInteger,Blockcore.NBitcoin.BouncyCastle.math.BigInteger@)">
             Calculate the numbers u1, u2, and u3 such that:
            
             u1 * a + u2 * b = u3
            
             where u3 is the greatest common divider of a and b.
             a and b using the extended Euclid algorithm (refer p. 323
             of The Art of Computer Programming vol 2, 2nd ed).
             This also seems to have the side effect of calculating
             some form of multiplicative inverse.
            
             @param a    First number to calculate gcd for
             @param b    Second number to calculate gcd for
             @param u1Out      the return object for the u1 value
             @return     The greatest common divisor of a and b
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.BigInteger.Square(System.Int32[],System.Int32[])">
            return w with w = x * x - w is assumed to have enough space.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.BigInteger.Multiply(System.Int32[],System.Int32[],System.Int32[])">
            return x with x = y * z - x is assumed to have enough space.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.BigInteger.GetMQuote">
            Calculate mQuote = -m^(-1) mod b with b = 2^32 (32 = word size)
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.BigInteger.MultiplyMonty(System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.UInt32,System.Boolean)">
            Montgomery multiplication: a = x * y * R^(-1) mod m
            <br/>
            Based algorithm 14.36 of Handbook of Applied Cryptography.
            <br/>
            <li> m, x, y should have length n </li>
            <li> a should have length (n + 1) </li>
            <li> b = 2^32, R = b^n </li>
            <br/>
            The result is put in x
            <br/>
            NOTE: the indices of x, y, m, a different in HAC and in Java
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.BigInteger.Remainder(System.Int32[],System.Int32[])">
            return x = x % y - done in place (y value preserved)
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.BigInteger.ShiftLeft(System.Int32[],System.Int32)">
            do a left shift - this returns a new array.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.BigInteger.ShiftRightInPlace(System.Int32,System.Int32[],System.Int32)">
            do a right shift - this does it in place.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.BigInteger.ShiftRightOneInPlace(System.Int32,System.Int32[])">
            do a right shift by one - this does it in place.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.BigInteger.Subtract(System.Int32,System.Int32[],System.Int32,System.Int32[])">
            returns x = x - y - we assume x is >= y
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.math.ec.abc.SimpleBigDecimal">
            Class representing a simple version of a big decimal. A
            <code>SimpleBigDecimal</code> is basically a
            {@link java.math.BigInteger BigInteger} with a few digits on the right of
            the decimal point. The number of (binary) digits on the right of the decimal
            point is called the <code>scale</code> of the <code>SimpleBigDecimal</code>.
            Unlike in {@link java.math.BigDecimal BigDecimal}, the scale is not adjusted
            automatically, but must be set manually. All <code>SimpleBigDecimal</code>s
            taking part in the same arithmetic operation must have equal scale. The
            result of a multiplication of two <code>SimpleBigDecimal</code>s returns a
            <code>SimpleBigDecimal</code> with double scale.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.abc.SimpleBigDecimal.GetInstance(Blockcore.NBitcoin.BouncyCastle.math.BigInteger,System.Int32)">
            Returns a <code>SimpleBigDecimal</code> representing the same numerical
            value as <code>value</code>.
            @param value The value of the <code>SimpleBigDecimal</code> to be
            created. 
            @param scale The scale of the <code>SimpleBigDecimal</code> to be
            created. 
            @return The such created <code>SimpleBigDecimal</code>.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.abc.SimpleBigDecimal.#ctor(Blockcore.NBitcoin.BouncyCastle.math.BigInteger,System.Int32)">
            Constructor for <code>SimpleBigDecimal</code>. The value of the
            constructed <code>SimpleBigDecimal</code> Equals <code>bigInt / 
            2<sup>scale</sup></code>.
            @param bigInt The <code>bigInt</code> value parameter.
            @param scale The scale of the constructed <code>SimpleBigDecimal</code>.
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.math.ec.abc.Tnaf">
            Class holding methods for point multiplication based on the window
            &#964;-adic nonadjacent form (WTNAF). The algorithms are based on the
            paper "Improved Algorithms for Arithmetic on Anomalous Binary Curves"
            by Jerome A. Solinas. The paper first appeared in the Proceedings of
            Crypto 1997.
        </member>
        <member name="F:Blockcore.NBitcoin.BouncyCastle.math.ec.abc.Tnaf.Width">
            The window width of WTNAF. The standard value of 4 is slightly less
            than optimal for running time, but keeps space requirements for
            precomputation low. For typical curves, a value of 5 or 6 results in
            a better running time. When changing this value, the
            <code>&#945;<sub>u</sub></code>'s must be computed differently, see
            e.g. "Guide to Elliptic Curve Cryptography", Darrel Hankerson,
            Alfred Menezes, Scott Vanstone, Springer-Verlag New York Inc., 2004,
            p. 121-122
        </member>
        <member name="F:Blockcore.NBitcoin.BouncyCastle.math.ec.abc.Tnaf.Pow2Width">
            2<sup>4</sup>
        </member>
        <member name="F:Blockcore.NBitcoin.BouncyCastle.math.ec.abc.Tnaf.Alpha0">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=0</code> as an array
            of <code>ZTauElement</code>s.
        </member>
        <member name="F:Blockcore.NBitcoin.BouncyCastle.math.ec.abc.Tnaf.Alpha0Tnaf">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=0</code> as an array
            of TNAFs.
        </member>
        <member name="F:Blockcore.NBitcoin.BouncyCastle.math.ec.abc.Tnaf.Alpha1">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=1</code> as an array
            of <code>ZTauElement</code>s.
        </member>
        <member name="F:Blockcore.NBitcoin.BouncyCastle.math.ec.abc.Tnaf.Alpha1Tnaf">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=1</code> as an array
            of TNAFs.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.abc.Tnaf.Norm(System.SByte,Blockcore.NBitcoin.BouncyCastle.math.ec.abc.ZTauElement)">
            Computes the norm of an element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @return The norm of <code>&#955;</code>.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.abc.Tnaf.Norm(System.SByte,Blockcore.NBitcoin.BouncyCastle.math.ec.abc.SimpleBigDecimal,Blockcore.NBitcoin.BouncyCastle.math.ec.abc.SimpleBigDecimal)">
            Computes the norm of an element <code>&#955;</code> of
            <code><b>R</b>[&#964;]</code>, where <code>&#955; = u + v&#964;</code>
            and <code>u</code> and <code>u</code> are real numbers (elements of
            <code><b>R</b></code>). 
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param u The real part of the element <code>&#955;</code> of
            <code><b>R</b>[&#964;]</code>.
            @param v The <code>&#964;</code>-adic part of the element
            <code>&#955;</code> of <code><b>R</b>[&#964;]</code>.
            @return The norm of <code>&#955;</code>.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.abc.Tnaf.Round(Blockcore.NBitcoin.BouncyCastle.math.ec.abc.SimpleBigDecimal,Blockcore.NBitcoin.BouncyCastle.math.ec.abc.SimpleBigDecimal,System.SByte)">
            Rounds an element <code>&#955;</code> of <code><b>R</b>[&#964;]</code>
            to an element of <code><b>Z</b>[&#964;]</code>, such that their difference
            has minimal norm. <code>&#955;</code> is given as
            <code>&#955; = &#955;<sub>0</sub> + &#955;<sub>1</sub>&#964;</code>.
            @param lambda0 The component <code>&#955;<sub>0</sub></code>.
            @param lambda1 The component <code>&#955;<sub>1</sub></code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve. Must
            equal 1 or -1.
            @return The rounded element of <code><b>Z</b>[&#964;]</code>.
            @throws ArgumentException if <code>lambda0</code> and
            <code>lambda1</code> do not have same scale.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.abc.Tnaf.ApproximateDivisionByN(Blockcore.NBitcoin.BouncyCastle.math.BigInteger,Blockcore.NBitcoin.BouncyCastle.math.BigInteger,Blockcore.NBitcoin.BouncyCastle.math.BigInteger,System.SByte,System.Int32,System.Int32)">
            Approximate division by <code>n</code>. For an integer
            <code>k</code>, the value <code>&#955; = s k / n</code> is
            computed to <code>c</code> bits of accuracy.
            @param k The parameter <code>k</code>.
            @param s The curve parameter <code>s<sub>0</sub></code> or
            <code>s<sub>1</sub></code>.
            @param vm The Lucas Sequence element <code>V<sub>m</sub></code>.
            @param a The parameter <code>a</code> of the elliptic curve.
            @param m The bit length of the finite field
            <code><b>F</b><sub>m</sub></code>.
            @param c The number of bits of accuracy, i.e. the scale of the returned
            <code>SimpleBigDecimal</code>.
            @return The value <code>&#955; = s k / n</code> computed to
            <code>c</code> bits of accuracy.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.abc.Tnaf.TauAdicNaf(System.SByte,Blockcore.NBitcoin.BouncyCastle.math.ec.abc.ZTauElement)">
            Computes the <code>&#964;</code>-adic NAF (non-adjacent form) of an
            element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @return The <code>&#964;</code>-adic NAF of <code>&#955;</code>.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.abc.Tnaf.Tau(Blockcore.NBitcoin.BouncyCastle.math.ec.AbstractF2mPoint)">
            Applies the operation <code>&#964;()</code> to an
            <code>AbstractF2mPoint</code>. 
            @param p The AbstractF2mPoint to which <code>&#964;()</code> is applied.
            @return <code>&#964;(p)</code>
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.abc.Tnaf.GetMu(Blockcore.NBitcoin.BouncyCastle.math.ec.AbstractF2mCurve)">
            Returns the parameter <code>&#956;</code> of the elliptic curve.
            @param curve The elliptic curve from which to obtain <code>&#956;</code>.
            The curve must be a Koblitz curve, i.e. <code>a</code> Equals
            <code>0</code> or <code>1</code> and <code>b</code> Equals
            <code>1</code>. 
            @return <code>&#956;</code> of the elliptic curve.
            @throws ArgumentException if the given ECCurve is not a Koblitz
            curve.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.abc.Tnaf.GetLucas(System.SByte,System.Int32,System.Boolean)">
            Calculates the Lucas Sequence elements <code>U<sub>k-1</sub></code> and
            <code>U<sub>k</sub></code> or <code>V<sub>k-1</sub></code> and
            <code>V<sub>k</sub></code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param k The index of the second element of the Lucas Sequence to be
            returned.
            @param doV If set to true, computes <code>V<sub>k-1</sub></code> and
            <code>V<sub>k</sub></code>, otherwise <code>U<sub>k-1</sub></code> and
            <code>U<sub>k</sub></code>.
            @return An array with 2 elements, containing <code>U<sub>k-1</sub></code>
            and <code>U<sub>k</sub></code> or <code>V<sub>k-1</sub></code>
            and <code>V<sub>k</sub></code>.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.abc.Tnaf.GetTw(System.SByte,System.Int32)">
            Computes the auxiliary value <code>t<sub>w</sub></code>. If the width is
            4, then for <code>mu = 1</code>, <code>t<sub>w</sub> = 6</code> and for
            <code>mu = -1</code>, <code>t<sub>w</sub> = 10</code> 
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param w The window width of the WTNAF.
            @return the auxiliary value <code>t<sub>w</sub></code>
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.abc.Tnaf.GetSi(Blockcore.NBitcoin.BouncyCastle.math.ec.AbstractF2mCurve)">
            Computes the auxiliary values <code>s<sub>0</sub></code> and
            <code>s<sub>1</sub></code> used for partial modular reduction. 
            @param curve The elliptic curve for which to compute
            <code>s<sub>0</sub></code> and <code>s<sub>1</sub></code>.
            @throws ArgumentException if <code>curve</code> is not a
            Koblitz curve (Anomalous Binary Curve, ABC).
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.abc.Tnaf.PartModReduction(Blockcore.NBitcoin.BouncyCastle.math.BigInteger,System.Int32,System.SByte,Blockcore.NBitcoin.BouncyCastle.math.BigInteger[],System.SByte,System.SByte)">
            Partial modular reduction modulo
            <code>(&#964;<sup>m</sup> - 1)/(&#964; - 1)</code>.
            @param k The integer to be reduced.
            @param m The bitlength of the underlying finite field.
            @param a The parameter <code>a</code> of the elliptic curve.
            @param s The auxiliary values <code>s<sub>0</sub></code> and
            <code>s<sub>1</sub></code>.
            @param mu The parameter &#956; of the elliptic curve.
            @param c The precision (number of bits of accuracy) of the partial
            modular reduction.
            @return <code>&#961; := k partmod (&#964;<sup>m</sup> - 1)/(&#964; - 1)</code>
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.abc.Tnaf.MultiplyRTnaf(Blockcore.NBitcoin.BouncyCastle.math.ec.AbstractF2mPoint,Blockcore.NBitcoin.BouncyCastle.math.BigInteger)">
            Multiplies a {@link NBitcoin.BouncyCastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by a <code>BigInteger</code> using the reduced <code>&#964;</code>-adic
            NAF (RTNAF) method.
            @param p The AbstractF2mPoint to Multiply.
            @param k The <code>BigInteger</code> by which to Multiply <code>p</code>.
            @return <code>k * p</code>
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.abc.Tnaf.MultiplyTnaf(Blockcore.NBitcoin.BouncyCastle.math.ec.AbstractF2mPoint,Blockcore.NBitcoin.BouncyCastle.math.ec.abc.ZTauElement)">
            Multiplies a {@link NBitcoin.BouncyCastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>
            using the <code>&#964;</code>-adic NAF (TNAF) method.
            @param p The AbstractF2mPoint to Multiply.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @return <code>&#955; * p</code>
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.abc.Tnaf.MultiplyFromTnaf(Blockcore.NBitcoin.BouncyCastle.math.ec.AbstractF2mPoint,System.SByte[])">
            Multiplies a {@link NBitcoin.BouncyCastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>
            using the <code>&#964;</code>-adic NAF (TNAF) method, given the TNAF
            of <code>&#955;</code>.
            @param p The AbstractF2mPoint to Multiply.
            @param u The the TNAF of <code>&#955;</code>..
            @return <code>&#955; * p</code>
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.abc.Tnaf.TauAdicWNaf(System.SByte,Blockcore.NBitcoin.BouncyCastle.math.ec.abc.ZTauElement,System.SByte,Blockcore.NBitcoin.BouncyCastle.math.BigInteger,Blockcore.NBitcoin.BouncyCastle.math.BigInteger,Blockcore.NBitcoin.BouncyCastle.math.ec.abc.ZTauElement[])">
            Computes the <code>[&#964;]</code>-adic window NAF of an element
            <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>.
            @param mu The parameter &#956; of the elliptic curve.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code> of which to compute the
            <code>[&#964;]</code>-adic NAF.
            @param width The window width of the resulting WNAF.
            @param pow2w 2<sup>width</sup>.
            @param tw The auxiliary value <code>t<sub>w</sub></code>.
            @param alpha The <code>&#945;<sub>u</sub></code>'s for the window width.
            @return The <code>[&#964;]</code>-adic window NAF of
            <code>&#955;</code>.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.abc.Tnaf.GetPreComp(Blockcore.NBitcoin.BouncyCastle.math.ec.AbstractF2mPoint,System.SByte)">
            Does the precomputation for WTNAF multiplication.
            @param p The <code>ECPoint</code> for which to do the precomputation.
            @param a The parameter <code>a</code> of the elliptic curve.
            @return The precomputation array for <code>p</code>. 
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.math.ec.abc.ZTauElement">
            Class representing an element of <code><b>Z</b>[&#964;]</code>. Let
            <code>&#955;</code> be an element of <code><b>Z</b>[&#964;]</code>. Then
            <code>&#955;</code> is given as <code>&#955; = u + v&#964;</code>. The
            components <code>u</code> and <code>v</code> may be used directly, there
            are no accessor methods.
            Immutable class.
        </member>
        <member name="F:Blockcore.NBitcoin.BouncyCastle.math.ec.abc.ZTauElement.u">
            The &quot;real&quot; part of <code>&#955;</code>.
        </member>
        <member name="F:Blockcore.NBitcoin.BouncyCastle.math.ec.abc.ZTauElement.v">
            The &quot;<code>&#964;</code>-adic&quot; part of <code>&#955;</code>.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.abc.ZTauElement.#ctor(Blockcore.NBitcoin.BouncyCastle.math.BigInteger,Blockcore.NBitcoin.BouncyCastle.math.BigInteger)">
            Constructor for an element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @param u The &quot;real&quot; part of <code>&#955;</code>.
            @param v The &quot;<code>&#964;</code>-adic&quot; part of
            <code>&#955;</code>.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.custom.sec.SecP256K1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.custom.sec.SecP256K1Point.#ctor(Blockcore.NBitcoin.BouncyCastle.math.ec.ECCurve,Blockcore.NBitcoin.BouncyCastle.math.ec.ECFieldElement,Blockcore.NBitcoin.BouncyCastle.math.ec.ECFieldElement)">
            Create a point which encodes with point compression.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.custom.sec.SecP256K1Point.#ctor(Blockcore.NBitcoin.BouncyCastle.math.ec.ECCurve,Blockcore.NBitcoin.BouncyCastle.math.ec.ECFieldElement,Blockcore.NBitcoin.BouncyCastle.math.ec.ECFieldElement,System.Boolean)">
            Create a point that encodes with or without point compresion.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            @param withCompression
                       if true encode with point compression
            
            @deprecated per-point compression property will be removed, refer
                        {@link #getEncoded(bool)}
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.ECAlgorithms.ReferenceMultiply(Blockcore.NBitcoin.BouncyCastle.math.ec.ECPoint,Blockcore.NBitcoin.BouncyCastle.math.BigInteger)">
            Simple shift-and-add multiplication. Serves as reference implementation
            to verify (possibly faster) implementations, and for very small scalars.
            
            @param p
                       The point to multiply.
            @param k
                       The multiplier.
            @return The result of the point multiplication <code>kP</code>.
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.math.ec.ECCurve">
            <remarks>Base class for an elliptic curve.</remarks>
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.ECCurve.SetPreCompInfo(Blockcore.NBitcoin.BouncyCastle.math.ec.ECPoint,System.String,Blockcore.NBitcoin.BouncyCastle.math.ec.multiplier.PreCompInfo)">
            Adds <code>PreCompInfo</code> for a point on this curve, under a given name. Used by
            <code>ECMultiplier</code>s to save the precomputation for this <code>ECPoint</code> for use
            by subsequent multiplication.
            
            @param point
                       The <code>ECPoint</code> to store precomputations for.
            @param name
                       A <code>String</code> used to index precomputations of different types.
            @param preCompInfo
                       The values precomputed by the <code>ECMultiplier</code>.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.ECCurve.NormalizeAll(Blockcore.NBitcoin.BouncyCastle.math.ec.ECPoint[])">
            Normalization ensures that any projective coordinate is 1, and therefore that the x, y
            coordinates reflect those of the equivalent point in an affine coordinate system. Where more
            than one point is to be normalized, this method will generally be more efficient than
            normalizing each point separately.
            
            @param points
                       An array of points that will be updated in place with their normalized versions,
                       where necessary
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.ECCurve.NormalizeAll(Blockcore.NBitcoin.BouncyCastle.math.ec.ECPoint[],System.Int32,System.Int32,Blockcore.NBitcoin.BouncyCastle.math.ec.ECFieldElement)">
            Normalization ensures that any projective coordinate is 1, and therefore that the x, y
            coordinates reflect those of the equivalent point in an affine coordinate system. Where more
            than one point is to be normalized, this method will generally be more efficient than
            normalizing each point separately. An (optional) z-scaling factor can be applied; effectively
            each z coordinate is scaled by this value prior to normalization (but only one
            actual multiplication is needed).
            
            @param points
                       An array of points that will be updated in place with their normalized versions,
                       where necessary
            @param off
                       The start of the range of points to normalize
            @param len
                       The length of the range of points to normalize
            @param iso
                       The (optional) z-scaling factor - can be null
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.ECCurve.GetMultiplier">
            Sets the default <code>ECMultiplier</code>, unless already set. 
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.ECCurve.DecodePoint(System.Byte[])">
            Decode a point on this curve from its ASN.1 encoding. The different
            encodings are taken account of, including point compression for
            <code>F<sub>p</sub></code> (X9.62 s 4.2.1 pg 17).
            @return The decoded point.
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.math.ec.FpCurve">
            Elliptic curve over Fp
        </member>
        <member name="F:Blockcore.NBitcoin.BouncyCastle.math.ec.AbstractF2mCurve.si">
            The auxiliary values <code>s<sub>0</sub></code> and
            <code>s<sub>1</sub></code> used for partial modular reduction for
            Koblitz curves.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.AbstractF2mCurve.SolveQuadradicEquation(Blockcore.NBitcoin.BouncyCastle.math.ec.ECFieldElement)">
             Solves a quadratic equation <code>z<sup>2</sup> + z = beta</code>(X9.62
             D.1.6) The other solution is <code>z + 1</code>.
            
             @param beta
                        The value to solve the qradratic equation for.
             @return the solution for <code>z<sup>2</sup> + z = beta</code> or
                     <code>null</code> if no solution exists.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.AbstractF2mCurve.GetSi">
            @return the auxiliary values <code>s<sub>0</sub></code> and
            <code>s<sub>1</sub></code> used for partial modular reduction for
            Koblitz curves.
        </member>
        <member name="P:Blockcore.NBitcoin.BouncyCastle.math.ec.AbstractF2mCurve.IsKoblitz">
            Returns true if this is a Koblitz curve (ABC curve).
            @return true if this is a Koblitz curve (ABC curve), false otherwise
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.math.ec.F2mCurve">
            Elliptic curves over F2m. The Weierstrass equation is given by
            <code>y<sup>2</sup> + xy = x<sup>3</sup> + ax<sup>2</sup> + b</code>.
        </member>
        <member name="F:Blockcore.NBitcoin.BouncyCastle.math.ec.F2mCurve.m">
            The exponent <code>m</code> of <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="F:Blockcore.NBitcoin.BouncyCastle.math.ec.F2mCurve.k1">
            TPB: The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction polynomial
            <code>f(z)</code>.<br/>
            PPB: The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="F:Blockcore.NBitcoin.BouncyCastle.math.ec.F2mCurve.k2">
            TPB: Always set to <code>0</code><br/>
            PPB: The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="F:Blockcore.NBitcoin.BouncyCastle.math.ec.F2mCurve.k3">
            TPB: Always set to <code>0</code><br/>
            PPB: The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="F:Blockcore.NBitcoin.BouncyCastle.math.ec.F2mCurve.m_infinity">
            The point at infinity on this curve.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.F2mCurve.#ctor(System.Int32,System.Int32,Blockcore.NBitcoin.BouncyCastle.math.BigInteger,Blockcore.NBitcoin.BouncyCastle.math.BigInteger)">
            Constructor for Trinomial Polynomial Basis (TPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction
            polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.F2mCurve.#ctor(System.Int32,System.Int32,Blockcore.NBitcoin.BouncyCastle.math.BigInteger,Blockcore.NBitcoin.BouncyCastle.math.BigInteger,Blockcore.NBitcoin.BouncyCastle.math.BigInteger,Blockcore.NBitcoin.BouncyCastle.math.BigInteger)">
            Constructor for Trinomial Polynomial Basis (TPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction
            polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param order The order of the main subgroup of the elliptic curve.
            @param cofactor The cofactor of the elliptic curve, i.e.
            <code>#E<sub>a</sub>(F<sub>2<sup>m</sup></sub>) = h * n</code>.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.F2mCurve.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,Blockcore.NBitcoin.BouncyCastle.math.BigInteger,Blockcore.NBitcoin.BouncyCastle.math.BigInteger)">
            Constructor for Pentanomial Polynomial Basis (PPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.F2mCurve.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,Blockcore.NBitcoin.BouncyCastle.math.BigInteger,Blockcore.NBitcoin.BouncyCastle.math.BigInteger,Blockcore.NBitcoin.BouncyCastle.math.BigInteger,Blockcore.NBitcoin.BouncyCastle.math.BigInteger)">
            Constructor for Pentanomial Polynomial Basis (PPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param order The order of the main subgroup of the elliptic curve.
            @param cofactor The cofactor of the elliptic curve, i.e.
            <code>#E<sub>a</sub>(F<sub>2<sup>m</sup></sub>) = h * n</code>.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.F2mCurve.IsTrinomial">
             Return true if curve uses a Trinomial basis.
            
             @return true if curve Trinomial, false otherwise.
        </member>
        <member name="P:Blockcore.NBitcoin.BouncyCastle.math.ec.FpFieldElement.FieldName">
             return the field name for this field.
            
             @return the string "Fp".
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.FpFieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation
            returns the right value - if none exists it returns null.
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.math.ec.F2mFieldElement">
            Class representing the Elements of the finite field
            <code>F<sub>2<sup>m</sup></sub></code> in polynomial basis (PB)
            representation. Both trinomial (Tpb) and pentanomial (Ppb) polynomial
            basis representations are supported. Gaussian normal basis (GNB)
            representation is not supported.
        </member>
        <member name="F:Blockcore.NBitcoin.BouncyCastle.math.ec.F2mFieldElement.Gnb">
            Indicates gaussian normal basis representation (GNB). Number chosen
            according to X9.62. GNB is not implemented at present.
        </member>
        <member name="F:Blockcore.NBitcoin.BouncyCastle.math.ec.F2mFieldElement.Tpb">
            Indicates trinomial basis representation (Tpb). Number chosen
            according to X9.62.
        </member>
        <member name="F:Blockcore.NBitcoin.BouncyCastle.math.ec.F2mFieldElement.Ppb">
            Indicates pentanomial basis representation (Ppb). Number chosen
            according to X9.62.
        </member>
        <member name="F:Blockcore.NBitcoin.BouncyCastle.math.ec.F2mFieldElement.representation">
            Tpb or Ppb.
        </member>
        <member name="F:Blockcore.NBitcoin.BouncyCastle.math.ec.F2mFieldElement.m">
            The exponent <code>m</code> of <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="F:Blockcore.NBitcoin.BouncyCastle.math.ec.F2mFieldElement.x">
            The <code>LongArray</code> holding the bits.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.F2mFieldElement.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,Blockcore.NBitcoin.BouncyCastle.math.BigInteger)">
            Constructor for Ppb.
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param x The BigInteger representing the value of the field element.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.F2mFieldElement.#ctor(System.Int32,System.Int32,Blockcore.NBitcoin.BouncyCastle.math.BigInteger)">
            Constructor for Tpb.
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction
            polynomial <code>f(z)</code>.
            @param x The BigInteger representing the value of the field element.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.F2mFieldElement.CheckFieldElements(Blockcore.NBitcoin.BouncyCastle.math.ec.ECFieldElement,Blockcore.NBitcoin.BouncyCastle.math.ec.ECFieldElement)">
            Checks, if the ECFieldElements <code>a</code> and <code>b</code>
            are elements of the same field <code>F<sub>2<sup>m</sup></sub></code>
            (having the same representation).
            @param a field element.
            @param b field element to be compared.
            @throws ArgumentException if <code>a</code> and <code>b</code>
            are not elements of the same field
            <code>F<sub>2<sup>m</sup></sub></code> (having the same
            representation).
        </member>
        <member name="P:Blockcore.NBitcoin.BouncyCastle.math.ec.F2mFieldElement.Representation">
            @return the representation of the field
            <code>F<sub>2<sup>m</sup></sub></code>, either of
            {@link F2mFieldElement.Tpb} (trinomial
            basis representation) or
            {@link F2mFieldElement.Ppb} (pentanomial
            basis representation).
        </member>
        <member name="P:Blockcore.NBitcoin.BouncyCastle.math.ec.F2mFieldElement.M">
            @return the degree <code>m</code> of the reduction polynomial
            <code>f(z)</code>.
        </member>
        <member name="P:Blockcore.NBitcoin.BouncyCastle.math.ec.F2mFieldElement.K1">
            @return Tpb: The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction polynomial
            <code>f(z)</code>.<br/>
            Ppb: The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="P:Blockcore.NBitcoin.BouncyCastle.math.ec.F2mFieldElement.K2">
            @return Tpb: Always returns <code>0</code><br/>
            Ppb: The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="P:Blockcore.NBitcoin.BouncyCastle.math.ec.F2mFieldElement.K3">
            @return Tpb: Always set to <code>0</code><br/>
            Ppb: The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.math.ec.ECPoint">
            base class for points on elliptic curves.
        </member>
        <member name="P:Blockcore.NBitcoin.BouncyCastle.math.ec.ECPoint.X">
            Normalizes this point, and then returns the affine x-coordinate.
            
            Note: normalization can be expensive, this method is deprecated in favour
            of caller-controlled normalization.
        </member>
        <member name="P:Blockcore.NBitcoin.BouncyCastle.math.ec.ECPoint.Y">
            Normalizes this point, and then returns the affine y-coordinate.
            
            Note: normalization can be expensive, this method is deprecated in favour
            of caller-controlled normalization.
        </member>
        <member name="P:Blockcore.NBitcoin.BouncyCastle.math.ec.ECPoint.AffineXCoord">
            Returns the affine x-coordinate after checking that this point is normalized.
            
            @return The affine x-coordinate of this point
            @throws IllegalStateException if the point is not normalized
        </member>
        <member name="P:Blockcore.NBitcoin.BouncyCastle.math.ec.ECPoint.AffineYCoord">
            Returns the affine y-coordinate after checking that this point is normalized
            
            @return The affine y-coordinate of this point
            @throws IllegalStateException if the point is not normalized
        </member>
        <member name="P:Blockcore.NBitcoin.BouncyCastle.math.ec.ECPoint.XCoord">
            Returns the x-coordinate.
            
            Caution: depending on the curve's coordinate system, this may not be the same value as in an
            affine coordinate system; use Normalize() to get a point where the coordinates have their
            affine values, or use AffineXCoord if you expect the point to already have been normalized.
            
            @return the x-coordinate of this point
        </member>
        <member name="P:Blockcore.NBitcoin.BouncyCastle.math.ec.ECPoint.YCoord">
            Returns the y-coordinate.
            
            Caution: depending on the curve's coordinate system, this may not be the same value as in an
            affine coordinate system; use Normalize() to get a point where the coordinates have their
            affine values, or use AffineYCoord if you expect the point to already have been normalized.
            
            @return the y-coordinate of this point
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.ECPoint.Normalize">
            Normalization ensures that any projective coordinate is 1, and therefore that the x, y
            coordinates reflect those of the equivalent point in an affine coordinate system.
            
            @return a new ECPoint instance representing the same point, but with normalized coordinates
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.ECPointBase.GetEncoded(System.Boolean)">
            return the field element encoded with point compression. (S 4.3.6)
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.ECPointBase.Multiply(Blockcore.NBitcoin.BouncyCastle.math.BigInteger)">
            Multiplies this <code>ECPoint</code> by the given number.
            @param k The multiplicator.
            @return <code>k * this</code>.
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.math.ec.FpPoint">
            Elliptic curve points over Fp
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.FpPoint.#ctor(Blockcore.NBitcoin.BouncyCastle.math.ec.ECCurve,Blockcore.NBitcoin.BouncyCastle.math.ec.ECFieldElement,Blockcore.NBitcoin.BouncyCastle.math.ec.ECFieldElement)">
             Create a point which encodes without point compression.
            
             @param curve the curve to use
             @param x affine x co-ordinate
             @param y affine y co-ordinate
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.FpPoint.#ctor(Blockcore.NBitcoin.BouncyCastle.math.ec.ECCurve,Blockcore.NBitcoin.BouncyCastle.math.ec.ECFieldElement,Blockcore.NBitcoin.BouncyCastle.math.ec.ECFieldElement,System.Boolean)">
             Create a point that encodes with or without point compression.
            
             @param curve the curve to use
             @param x affine x co-ordinate
             @param y affine y co-ordinate
             @param withCompression if true encode with point compression
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.math.ec.F2mPoint">
            Elliptic curve points over F2m
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.F2mPoint.#ctor(Blockcore.NBitcoin.BouncyCastle.math.ec.ECCurve,Blockcore.NBitcoin.BouncyCastle.math.ec.ECFieldElement,Blockcore.NBitcoin.BouncyCastle.math.ec.ECFieldElement)">
            @param curve base curve
            @param x x point
            @param y y point
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.F2mPoint.#ctor(Blockcore.NBitcoin.BouncyCastle.math.ec.ECCurve,Blockcore.NBitcoin.BouncyCastle.math.ec.ECFieldElement,Blockcore.NBitcoin.BouncyCastle.math.ec.ECFieldElement,System.Boolean)">
            @param curve base curve
            @param x x point
            @param y y point
            @param withCompression true if encode with point compression.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.F2mPoint.#ctor(Blockcore.NBitcoin.BouncyCastle.math.ec.ECCurve)">
            Constructor for point at infinity
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.multiplier.DoubleAddMultiplier.MultiplyPositive(Blockcore.NBitcoin.BouncyCastle.math.ec.ECPoint,Blockcore.NBitcoin.BouncyCastle.math.BigInteger)">
            Joye's double-add algorithm.
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.math.ec.multiplier.ECMultiplier">
            Interface for classes encapsulating a point multiplication algorithm
            for <code>ECPoint</code>s.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.multiplier.ECMultiplier.Multiply(Blockcore.NBitcoin.BouncyCastle.math.ec.ECPoint,Blockcore.NBitcoin.BouncyCastle.math.BigInteger)">
            Multiplies the <code>ECPoint p</code> by <code>k</code>, i.e.
            <code>p</code> is added <code>k</code> times to itself.
            @param p The <code>ECPoint</code> to be multiplied.
            @param k The factor by which <code>p</code> is multiplied.
            @return <code>p</code> multiplied by <code>k</code>.
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.math.ec.multiplier.FixedPointPreCompInfo">
            Class holding precomputation data for fixed-point multiplications.
        </member>
        <member name="F:Blockcore.NBitcoin.BouncyCastle.math.ec.multiplier.FixedPointPreCompInfo.m_preComp">
            Array holding the precomputed <code>ECPoint</code>s used for a fixed
            point multiplication.
        </member>
        <member name="F:Blockcore.NBitcoin.BouncyCastle.math.ec.multiplier.FixedPointPreCompInfo.m_width">
            The width used for the precomputation. If a larger width precomputation
            is already available this may be larger than was requested, so calling
            code should refer to the actual width.
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.math.ec.multiplier.PreCompInfo">
            Interface for classes storing precomputation data for multiplication
            algorithms. Used as a Memento (see GOF patterns) for
            <code>WNafMultiplier</code>.
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.math.ec.multiplier.WNafL2RMultiplier">
            Class implementing the WNAF (Window Non-Adjacent Form) multiplication
            algorithm.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.multiplier.WNafL2RMultiplier.MultiplyPositive(Blockcore.NBitcoin.BouncyCastle.math.ec.ECPoint,Blockcore.NBitcoin.BouncyCastle.math.BigInteger)">
            Multiplies <code>this</code> by an integer <code>k</code> using the
            Window NAF method.
            @param k The integer by which <code>this</code> is multiplied.
            @return A new <code>ECPoint</code> which equals <code>this</code>
            multiplied by <code>k</code>.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.multiplier.WNafL2RMultiplier.GetWindowSize(System.Int32)">
            Determine window width to use for a scalar multiplication of the given size.
            
            @param bits the bit-length of the scalar to multiply by
            @return the window size to use
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.math.ec.multiplier.WNafPreCompInfo">
            Class holding precomputation data for the WNAF (Window Non-Adjacent Form)
            algorithm.
        </member>
        <member name="F:Blockcore.NBitcoin.BouncyCastle.math.ec.multiplier.WNafPreCompInfo.m_preComp">
            Array holding the precomputed <code>ECPoint</code>s used for a Window
            NAF multiplication.
        </member>
        <member name="F:Blockcore.NBitcoin.BouncyCastle.math.ec.multiplier.WNafPreCompInfo.m_preCompNeg">
            Array holding the negations of the precomputed <code>ECPoint</code>s used
            for a Window NAF multiplication.
        </member>
        <member name="F:Blockcore.NBitcoin.BouncyCastle.math.ec.multiplier.WNafPreCompInfo.m_twice">
            Holds an <code>ECPoint</code> representing Twice(this). Used for the
            Window NAF multiplication to create or extend the precomputed values.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.multiplier.WNafUtilities.GenerateWindowNaf(System.Int32,Blockcore.NBitcoin.BouncyCastle.math.BigInteger)">
            Computes the Window NAF (non-adjacent Form) of an integer.
            @param width The width <code>w</code> of the Window NAF. The width is
            defined as the minimal number <code>w</code>, such that for any
            <code>w</code> consecutive digits in the resulting representation, at
            most one is non-zero.
            @param k The integer of which the Window NAF is computed.
            @return The Window NAF of the given width, such that the following holds:
            <code>k = &amp;sum;<sub>i=0</sub><sup>l-1</sup> k<sub>i</sub>2<sup>i</sup>
            </code>, where the <code>k<sub>i</sub></code> denote the elements of the
            returned <code>byte[]</code>.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.multiplier.WNafUtilities.GetWindowSize(System.Int32)">
            Determine window width to use for a scalar multiplication of the given size.
            
            @param bits the bit-length of the scalar to multiply by
            @return the window size to use
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.multiplier.WNafUtilities.GetWindowSize(System.Int32,System.Int32[])">
            Determine window width to use for a scalar multiplication of the given size.
            
            @param bits the bit-length of the scalar to multiply by
            @param windowSizeCutoffs a monotonically increasing list of bit sizes at which to increment the window width
            @return the window size to use
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.math.ec.multiplier.WTauNafMultiplier">
            Class implementing the WTNAF (Window
            <code>&#964;</code>-adic Non-Adjacent Form) algorithm.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.multiplier.WTauNafMultiplier.MultiplyPositive(Blockcore.NBitcoin.BouncyCastle.math.ec.ECPoint,Blockcore.NBitcoin.BouncyCastle.math.BigInteger)">
            Multiplies a {@link NBitcoin.BouncyCastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by <code>k</code> using the reduced <code>&#964;</code>-adic NAF (RTNAF)
            method.
            @param p The AbstractF2mPoint to multiply.
            @param k The integer by which to multiply <code>k</code>.
            @return <code>p</code> multiplied by <code>k</code>.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.multiplier.WTauNafMultiplier.MultiplyWTnaf(Blockcore.NBitcoin.BouncyCastle.math.ec.AbstractF2mPoint,Blockcore.NBitcoin.BouncyCastle.math.ec.abc.ZTauElement,Blockcore.NBitcoin.BouncyCastle.math.ec.multiplier.PreCompInfo,System.SByte,System.SByte)">
            Multiplies a {@link NBitcoin.BouncyCastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code> using
            the <code>&#964;</code>-adic NAF (TNAF) method.
            @param p The AbstractF2mPoint to multiply.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code> of which to compute the
            <code>[&#964;]</code>-adic NAF.
            @return <code>p</code> multiplied by <code>&#955;</code>.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.math.ec.multiplier.WTauNafMultiplier.MultiplyFromWTnaf(Blockcore.NBitcoin.BouncyCastle.math.ec.AbstractF2mPoint,System.SByte[],Blockcore.NBitcoin.BouncyCastle.math.ec.multiplier.PreCompInfo)">
            Multiplies a {@link NBitcoin.BouncyCastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>
            using the window <code>&#964;</code>-adic NAF (TNAF) method, given the
            WTNAF of <code>&#955;</code>.
            @param p The AbstractF2mPoint to multiply.
            @param u The the WTNAF of <code>&#955;</code>..
            @return <code>&#955; * p</code>
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.math.ec.multiplier.WTauNafPreCompInfo">
            Class holding precomputation data for the WTNAF (Window
            <code>&#964;</code>-adic Non-Adjacent Form) algorithm.
        </member>
        <member name="F:Blockcore.NBitcoin.BouncyCastle.math.ec.multiplier.WTauNafPreCompInfo.m_preComp">
            Array holding the precomputed <code>AbstractF2mPoint</code>s used for the
            WTNAF multiplication in <code>
            {@link NBitcoin.BouncyCastle.math.ec.multiplier.WTauNafMultiplier.multiply()
            WTauNafMultiplier.multiply()}</code>.
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.util.Arrays">
            <summary> General array utilities.</summary>
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.util.Arrays.AreEqual(System.Byte[],System.Byte[])">
            <summary>
            Are two arrays equal.
            </summary>
            <param name="a">Left side.</param>
            <param name="b">Right side.</param>
            <returns>True if equal.</returns>
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.util.Arrays.ConstantTimeAreEqual(System.Byte[],System.Byte[])">
            <summary>
            A constant time equals comparison - does not terminate early if
            test will fail.
            </summary>
            <param name="a">first array</param>
            <param name="b">second array</param>
            <returns>true if arrays equal, false otherwise.</returns>
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.util.Arrays.CopyOfRange(System.Byte[],System.Int32,System.Int32)">
             Make a copy of a range of bytes from the passed in data array. The range can
             extend beyond the end of the input array, in which case the return array will
             be padded with zeroes.
            
             @param data the array from which the data is to be copied.
             @param from the start index at which the copying should take place.
             @param to the final index of the range (exclusive).
            
             @return a new byte array containing the range given.
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.util.BigIntegers">
            BigInteger utilities.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.util.BigIntegers.AsUnsignedByteArray(Blockcore.NBitcoin.BouncyCastle.math.BigInteger)">
             Return the passed in value as an unsigned byte array.
            
             @param value value to be converted.
             @return a byte array without a leading zero byte if present in the signed encoding.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.util.BigIntegers.AsUnsignedByteArray(System.Int32,Blockcore.NBitcoin.BouncyCastle.math.BigInteger)">
             Return the passed in value as an unsigned byte array of specified length, zero-extended as necessary.
            
             @param length desired length of result array.
             @param n value to be converted.
             @return a byte array of specified length, with leading zeroes as necessary given the size of n.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.util.BigIntegers.CreateRandomInRange(Blockcore.NBitcoin.BouncyCastle.math.BigInteger,Blockcore.NBitcoin.BouncyCastle.math.BigInteger,Blockcore.NBitcoin.BouncyCastle.security.SecureRandom)">
            Return a random BigInteger not less than 'min' and not greater than 'max'
            
            @param min the least value that may be generated
            @param max the greatest value that may be generated
            @param random the source of randomness
            @return a random BigInteger value in the range [min,max]
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.util.encoders.Hex">
            <summary>
            Class to decode and encode Hex.
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.util.encoders.Hex.Encode(System.Byte[])">
             encode the input data producing a Hex encoded byte array.
            
             @return a byte array containing the Hex encoded data.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.util.encoders.Hex.Encode(System.Byte[],System.Int32,System.Int32)">
             encode the input data producing a Hex encoded byte array.
            
             @return a byte array containing the Hex encoded data.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.util.encoders.Hex.Encode(System.Byte[],System.IO.Stream)">
             Hex encode the byte data writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.util.encoders.Hex.Encode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             Hex encode the byte data writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.util.encoders.Hex.Decode(System.Byte[])">
             decode the Hex encoded input data. It is assumed the input data is valid.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.util.encoders.Hex.Decode(System.String)">
             decode the Hex encoded string data - whitespace will be ignored.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.util.encoders.Hex.Decode(System.String,System.IO.Stream)">
             decode the Hex encoded string data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.util.encoders.HexEncoder.Encode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             encode the input data producing a Hex output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.util.encoders.HexEncoder.Decode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             decode the Hex encoded byte data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.util.encoders.HexEncoder.DecodeString(System.String,System.IO.Stream)">
             decode the Hex encoded string data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="T:Blockcore.NBitcoin.BouncyCastle.util.encoders.IEncoder">
            Encode and decode byte arrays (typically from binary to 7-bit ASCII
            encodings).
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.util.IMemoable.Copy">
            <summary>
            Produce a copy of this object with its configuration and in its current state.
            </summary>
            <remarks>
            The returned object may be used simply to store the state, or may be used as a similar object
            starting from the copied state.
            </remarks>
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.util.IMemoable.Reset(Blockcore.NBitcoin.BouncyCastle.util.IMemoable)">
            <summary>
            Restore a copied object state into this object.
            </summary>
            <remarks>
            Implementations of this method <em>should</em> try to avoid or minimise memory allocation to perform the reset.
            </remarks>
            <param name="other">an object originally {@link #copy() copied} from an object of the same type as this instance.</param>
            <exception cref="T:System.InvalidCastException">if the provided object is not of the correct type.</exception>
        </member>
        <member name="M:Blockcore.NBitcoin.BouncyCastle.util.io.Streams.PipeAllLimited(System.IO.Stream,System.Int64,System.IO.Stream)">
            <summary>
            Pipe all bytes from <c>inStr</c> to <c>outStr</c>, throwing <c>StreamFlowException</c> if greater
            than <c>limit</c> bytes in <c>inStr</c>.
            </summary>
            <param name="inStr">
            A <see cref="T:System.IO.Stream"/>
            </param>
            <param name="limit">
            A <see cref="T:System.Int64"/>
            </param>
            <param name="outStr">
            A <see cref="T:System.IO.Stream"/>
            </param>
            <returns>The number of bytes actually transferred, if not greater than <c>limit</c></returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Blockcore.NBitcoin.BuilderExtensions.BuilderExtension">
            <summary>
            Base extension class to derive from for extending the TransactionBuilder
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.ICoin.GetScriptCode(Blockcore.Networks.Network)">
            <summary>
            Returns the script actually signed and executed
            </summary>
            <exception cref="T:System.InvalidOperationException">Additional information needed to get the ScriptCode</exception>
            <returns>The executed script</returns>
        </member>
        <member name="T:Blockcore.NBitcoin.ScriptCoin">
            <summary>
            Represent a coin which need a redeem script to be spent (P2SH or P2WSH)
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.ScriptCoin.GetRedeemHash(Blockcore.Networks.Network,Blockcore.Consensus.ScriptInfo.Script)">
            <summary>
            Returns the hash contained in the scriptPubKey (P2SH or P2WSH)
            </summary>
            <param name="scriptPubKey">The scriptPubKey</param>
            <returns>The hash of the scriptPubkey</returns>
        </member>
        <member name="T:Blockcore.NBitcoin.Crypto.Cryptsharp.Pbkdf2">
             <summary>
             Implements the PBKDF2 key derivation function.
             </summary>
             
             <example>
             <code title="Computing a Derived Key">
             using System.Security.Cryptography;
             using CryptSharp.Utility;
             
             // Compute a 128-byte derived key using HMAC-SHA256, 1000 iterations, and a given key and salt.
             byte[] derivedKey = Pbkdf2.ComputeDerivedKey(new HMACSHA256(key), salt, 1000, 128);
             </code>
             <code title="Creating a Derived Key Stream">
             using System.IO;
             using System.Security.Cryptography;
             using CryptSharp.Utility;
            
             // Create a stream using HMAC-SHA512, 1000 iterations, and a given key and salt.
             Stream derivedKeyStream = new Pbkdf2(new HMACSHA512(key), salt, 1000);
             </code>
             </example>
        </member>
        <member name="M:Blockcore.NBitcoin.Crypto.Cryptsharp.Pbkdf2.#ctor(Blockcore.NBitcoin.BouncyCastle.crypto.IMac,System.Byte[],System.Int32)">
            <summary>
            Creates a new PBKDF2 stream.
            </summary>
            <param name="hmacAlgorithm">
            </param>
            <param name="salt">
                The salt.
                A unique salt means a unique PBKDF2 stream, even if the original key is identical.
            </param>
            <param name="iterations">The number of iterations to apply.</param>
        </member>
        <member name="M:Blockcore.NBitcoin.Crypto.Cryptsharp.Pbkdf2.Read(System.Int32)">
            <summary>
            Reads from the derived key stream.
            </summary>
            <param name="count">The number of bytes to read.</param>
            <returns>Bytes from the derived key stream.</returns>
        </member>
        <member name="M:Blockcore.NBitcoin.Crypto.Cryptsharp.Pbkdf2.ComputeDerivedKey(Blockcore.NBitcoin.BouncyCastle.crypto.IMac,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Computes a derived key.
            </summary>
            <param name="hmacAlgorithm">
            </param>
            <param name="salt">
                The salt.
                A unique salt means a unique derived key, even if the original key is identical.
            </param>
            <param name="iterations">The number of iterations to apply.</param>
            <param name="derivedKeyLength">The desired length of the derived key.</param>
            <returns>The derived key.</returns>
        </member>
        <member name="M:Blockcore.NBitcoin.Crypto.Cryptsharp.Pbkdf2.Dispose(System.Boolean)">
            <summary>
            Closes the stream, clearing memory and disposing of the HMAC algorithm.
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.Crypto.Cryptsharp.Pbkdf2.Flush">
            <exclude />
        </member>
        <member name="M:Blockcore.NBitcoin.Crypto.Cryptsharp.Pbkdf2.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.NBitcoin.Crypto.Cryptsharp.Pbkdf2.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.NBitcoin.Crypto.Cryptsharp.Pbkdf2.SetLength(System.Int64)">
            <exclude />
        </member>
        <member name="M:Blockcore.NBitcoin.Crypto.Cryptsharp.Pbkdf2.Write(System.Byte[],System.Int32,System.Int32)">
            <exclude />
        </member>
        <member name="P:Blockcore.NBitcoin.Crypto.Cryptsharp.Pbkdf2.CanRead">
            <exclude />
        </member>
        <member name="P:Blockcore.NBitcoin.Crypto.Cryptsharp.Pbkdf2.CanSeek">
            <exclude />
        </member>
        <member name="P:Blockcore.NBitcoin.Crypto.Cryptsharp.Pbkdf2.CanWrite">
            <exclude />
        </member>
        <member name="P:Blockcore.NBitcoin.Crypto.Cryptsharp.Pbkdf2.Length">
            <summary>
            The maximum number of bytes that can be derived is 2^32-1 times the HMAC size.
            </summary>
        </member>
        <member name="P:Blockcore.NBitcoin.Crypto.Cryptsharp.Pbkdf2.Position">
            <summary>
            The position within the derived key stream.
            </summary>
        </member>
        <member name="T:Blockcore.NBitcoin.Crypto.Cryptsharp.Salsa20Core">
            <summary>
            Implements the Salsa20 hash function.
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.Crypto.Cryptsharp.Salsa20Core.Compute(System.Int32,System.UInt32[],System.Int32,System.UInt32[],System.Int32)">
            <summary>
            Applies the Salsa20 hash function.
            It maps a 16 element input to an output of the same size.
            </summary>
            <param name="rounds">The number of rounds. SCrypt uses 8.</param>
            <param name="input">The input buffer.</param>
            <param name="inputOffset">The offset into the input buffer.</param>
            <param name="output">The output buffer.</param>
            <param name="outputOffset">The offset into the output buffer.</param>
        </member>
        <member name="T:Blockcore.NBitcoin.Crypto.Cryptsharp.SCrypt">
            <summary>
            Implements the SCrypt key derivation function.
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.Crypto.Cryptsharp.SCrypt.ComputeDerivedKey(System.Byte[],System.Byte[],System.Int32,System.Int32,System.Int32,System.Nullable{System.Int32},System.Int32)">
            <summary>
            Computes a derived key.
            </summary>
            <param name="key">The key to derive from.</param>
            <param name="salt">
                The salt.
                A unique salt means a unique SCrypt stream, even if the original key is identical.
            </param>
            <param name="cost">
                The cost parameter, typically a fairly large number such as 262144.
                Memory usage and CPU time scale approximately linearly with this parameter.
            </param>
            <param name="blockSize">
                The mixing block size, typically 8.
                Memory usage and CPU time scale approximately linearly with this parameter.
            </param>
            <param name="parallel">
                The level of parallelism, typically 1.
                CPU time scales approximately linearly with this parameter.
            </param>
            <param name="maxThreads">
                The maximum number of threads to spawn to derive the key.
                This is limited by the <paramref name="parallel"/> value.
                <c>null</c> will use as many threads as possible.
            </param>
            <param name="derivedKeyLength">The desired length of the derived key.</param>
            <returns>The derived key.</returns>
        </member>
        <member name="M:Blockcore.NBitcoin.Crypto.Cryptsharp.SCrypt.GetEffectivePbkdf2Salt(System.Byte[],System.Byte[],System.Int32,System.Int32,System.Int32,System.Nullable{System.Int32})">
            <summary>
            The SCrypt algorithm creates a salt which it then uses as a one-iteration
            PBKDF2 key stream with SHA256 HMAC. This method lets you retrieve this intermediate salt.
            </summary>
            <param name="key">The key to derive from.</param>
            <param name="salt">
                The salt.
                A unique salt means a unique SCrypt stream, even if the original key is identical.
            </param>
            <param name="cost">
                The cost parameter, typically a fairly large number such as 262144.
                Memory usage and CPU time scale approximately linearly with this parameter.
            </param>
            <param name="blockSize">
                The mixing block size, typically 8.
                Memory usage and CPU time scale approximately linearly with this parameter.
            </param>
            <param name="parallel">
                The level of parallelism, typically 1.
                CPU time scales approximately linearly with this parameter.
            </param>
            <param name="maxThreads">
                The maximum number of threads to spawn to derive the key.
                This is limited by the <paramref name="parallel"/> value.
                <c>null</c> will use as many threads as possible.
            </param>
            <returns>The effective salt.</returns>
        </member>
        <member name="M:Blockcore.NBitcoin.Crypto.Cryptsharp.SCrypt.GetStream(System.Byte[],System.Byte[],System.Int32,System.Int32,System.Int32,System.Nullable{System.Int32})">
            <summary>
            Creates a derived key stream from which a derived key can be read.
            </summary>
            <param name="key">The key to derive from.</param>
            <param name="salt">
                The salt.
                A unique salt means a unique scrypt stream, even if the original key is identical.
            </param>
            <param name="cost">
                The cost parameter, typically a fairly large number such as 262144.
                Memory usage and CPU time scale approximately linearly with this parameter.
            </param>
            <param name="blockSize">
                The mixing block size, typically 8.
                Memory usage and CPU time scale approximately linearly with this parameter.
            </param>
            <param name="parallel">
                The level of parallelism, typically 1.
                CPU time scales approximately linearly with this parameter.
            </param>
            <param name="maxThreads">
                The maximum number of threads to spawn to derive the key.
                This is limited by the <paramref name="parallel"/> value.
                <c>null</c> will use as many threads as possible.
            </param>
            <returns>The derived key stream.</returns>
        </member>
        <member name="M:Blockcore.NBitcoin.Crypto.ECDSASignature.ToDER">
            What we get back from the signer are the two components of a signature, r and s. To get a flat byte stream
            of the type used by Bitcoin we have to encode them using DER encoding, which is just a way to pack the two
            components into a structure.
        </member>
        <member name="M:Blockcore.NBitcoin.Crypto.ECDSASignature.MakeCanonical">
            <summary>
            Enforce LowS on the signature
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.Crypto.ECDSASignature.MakeNonCanonical">
            <summary>
            Allow creation of signature with non-LowS for test purposes
            </summary>
            <remarks>Not to be used under normal circumstances</remarks>
        </member>
        <member name="P:Blockcore.NBitcoin.Crypto.HashX13.Instance">
            <summary>
            using the instance method is not thread safe. 
            to calling the hashing method in a multi threaded environment use the create() method
            </summary>
        </member>
        <member name="T:Blockcore.NBitcoin.Crypto.SchnorrSignature">
            <summary>
            Schnorr Signatures using Bouncy Castle
            Implementation taken from NBitcoin
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.Crypto.Sha512T.GetHash(System.Byte[])">
            <summary>
            Truncated double-SHA512 hash. Used are the first 32 bytes of the second hash output.
            </summary>
            <seealso cref="!:https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf"/>
            <param name="src">bytes to hash</param>
            <returns>hash</returns>
        </member>
        <member name="P:Blockcore.NBitcoin.FeeRate.FeePerK">
            <summary>
            Fee per KB
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.FeeRate.GetFee(System.Int32)">
            <summary>
            Get fee for the size
            </summary>
            <param name="virtualSize">Size in bytes</param>
            <returns></returns>
        </member>
        <member name="T:Blockcore.NBitcoin.IDestination">
            <summary>
            Represent any type which represent an underlying ScriptPubKey
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.Key.SignMessageBytes(System.Byte[])">
            <summary>
            Hashes and signs a message, returning the signature.
            </summary>
            <param name="messageBytes">The message to hash then sign.</param>
            <returns>The signature of the hashed and signed message.</returns>
        </member>
        <member name="M:Blockcore.NBitcoin.Key.GetWif(Blockcore.Networks.Network)">
            <summary>
            Same than GetBitcoinSecret
            </summary>
            <param name="network"></param>
            <returns></returns>
        </member>
        <member name="M:Blockcore.NBitcoin.MoneyBag.GetAmount(Blockcore.NBitcoin.OpenAsset.AssetId)">
            <summary>
            Get the Money corresponding to the input assetId
            </summary>
            <param name="assetId">The asset id, if null, will assume bitcoin amount</param>
            <returns>Never returns null, eithers the AssetMoney or Money if assetId is null</returns>
        </member>
        <member name="M:Blockcore.NBitcoin.MoneyBag.Split(System.Int32)">
            <summary>
            Split the MoneyBag in several one, without loss
            </summary>
            <param name="parts">The number of parts (must be more than 0)</param>
            <returns>The splitted money</returns>
        </member>
        <member name="M:Blockcore.NBitcoin.Money.TryParse(System.String,Blockcore.NBitcoin.Money@)">
            <summary>
            Parse a bitcoin amount (Culture Invariant)
            </summary>
            <param name="bitcoin"></param>
            <param name="nRet"></param>
            <returns></returns>
        </member>
        <member name="M:Blockcore.NBitcoin.Money.Parse(System.String)">
            <summary>
            Parse a bitcoin amount (Culture Invariant)
            </summary>
            <param name="bitcoin"></param>
            <returns></returns>
        </member>
        <member name="M:Blockcore.NBitcoin.Money.Abs">
            <summary>
            Get absolute value of the instance
            </summary>
            <returns></returns>
        </member>
        <member name="M:Blockcore.NBitcoin.Money.Split(System.Int32)">
            <summary>
            Split the Money in parts without loss
            </summary>
            <param name="parts">The number of parts (must be more than 0)</param>
            <returns>The splitted money</returns>
        </member>
        <member name="M:Blockcore.NBitcoin.Money.ToUnit(Blockcore.NBitcoin.MoneyUnit)">
            <summary>
            Convert Money to decimal (same as ToDecimal)
            </summary>
            <param name="unit"></param>
            <returns></returns>
        </member>
        <member name="M:Blockcore.NBitcoin.Money.ToDecimal(Blockcore.NBitcoin.MoneyUnit)">
            <summary>
            Convert Money to decimal (same as ToUnit)
            </summary>
            <param name="unit"></param>
            <returns></returns>
        </member>
        <member name="M:Blockcore.NBitcoin.Money.ToString">
            <summary>
            Returns a culture invariant string representation of Bitcoin amount
            </summary>
            <returns></returns>
        </member>
        <member name="M:Blockcore.NBitcoin.Money.ToString(System.Boolean,System.Boolean)">
            <summary>
            Returns a culture invariant string representation of Bitcoin amount
            </summary>
            <param name="fplus">True if show + for a positive amount</param>
            <param name="trimExcessZero">True if trim excess zeroes</param>
            <returns></returns>
        </member>
        <member name="M:Blockcore.NBitcoin.Money.Almost(Blockcore.NBitcoin.Money,Blockcore.NBitcoin.Money)">
            <summary>
            Tell if amount is almost equal to this instance
            </summary>
            <param name="amount"></param>
            <param name="dust">more or less amount</param>
            <returns>true if equals, else false</returns>
        </member>
        <member name="M:Blockcore.NBitcoin.Money.Almost(Blockcore.NBitcoin.Money,System.Decimal)">
            <summary>
            Tell if amount is almost equal to this instance
            </summary>
            <param name="amount"></param>
            <param name="margin">error margin (between 0 and 1)</param>
            <returns>true if equals, else false</returns>
        </member>
        <member name="T:Blockcore.NBitcoin.OpenAsset.AssetId">
            <summary>
            A unique Id for an asset
            </summary>
        </member>
        <member name="P:Blockcore.NBitcoin.OpenAsset.AssetMoney.Id">
            <summary>
            AssetId of the current amount
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.OpenAsset.AssetMoney.Abs">
            <summary>
            Get absolute value of the instance
            </summary>
            <returns></returns>
        </member>
        <member name="M:Blockcore.NBitcoin.OpenAsset.AssetMoney.Split(System.Int32)">
            <summary>
            Split the Money in parts without loss
            </summary>
            <param name="parts">The number of parts (must be more than 0)</param>
            <returns>The splitted money</returns>
        </member>
        <member name="T:Blockcore.NBitcoin.OpenAsset.BitcoinAssetId">
            <summary>
            Base58 representation of an asset id
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.PartialMerkleTree.Trim(Blockcore.NBitcoin.uint256[])">
            <summary>
            Remove superflous branches
            </summary>
            <param name="transaction"></param>
            <returns></returns>
        </member>
        <member name="M:Blockcore.NBitcoin.Policy.ITransactionPolicy.Check(Blockcore.Consensus.TransactionInfo.Transaction,Blockcore.NBitcoin.ICoin[])">
            <summary>
            Check if the given transaction violate the policy
            </summary>
            <param name="transaction">The transaction</param>
            <param name="spentCoins">The previous coins</param>
            <returns>Policy errors</returns>
        </member>
        <member name="T:Blockcore.NBitcoin.Policy.NotEnoughFundsPolicyError">
            <summary>
            Error when not enough funds are present for verifying or building a transaction
            </summary>
        </member>
        <member name="P:Blockcore.NBitcoin.Policy.NotEnoughFundsPolicyError.Missing">
            <summary>
            Amount of Money missing
            </summary>
        </member>
        <member name="F:Blockcore.NBitcoin.Policy.StandardTransactionPolicy.MaxScriptSigLength">
            <summary>
            Biggest 'standard' txin is a 15-of-15 P2SH multisig with compressed keys
            (remember the 520 byte limit on redeemScript size).
            That works out to a (15*(33+1))+3=513 byte redeemScript, 513+1+15*(73+1)+3=1627 bytes of scriptSig,
            which we round off to 1650 bytes for some minor future-proofing.
            That's also enough to spend a 20-of-20 CHECKMULTISIG scriptPubKey, though such a scriptPubKey is not considered standard.
            </summary>
        </member>
        <member name="P:Blockcore.NBitcoin.Policy.StandardTransactionPolicy.MaxTransactionSize">
            <summary>
            The maximum size for transactions we're willing to relay/mine.
            </summary>
        </member>
        <member name="P:Blockcore.NBitcoin.Policy.StandardTransactionPolicy.MaxTxFee">
            <summary>
            Safety check, if the FeeRate exceed this value, a policy error is raised.
            </summary>
        </member>
        <member name="P:Blockcore.NBitcoin.Policy.StandardTransactionPolicy.MinRelayTxFee">
            <summary>
            Fees smaller than this (in satoshi) are considered zero fee (for relaying).
            </summary>
        </member>
        <member name="P:Blockcore.NBitcoin.Policy.StandardTransactionPolicy.CheckMalleabilitySafe">
            <summary>
            Check if the transaction is safe from malleability (default: false).
            </summary>
        </member>
        <member name="P:Blockcore.NBitcoin.Policy.StandardTransactionPolicy.CheckFee">
            <summary>
            A value indicating whether to include checking the fee as part of checking the transaction.
            This is set to false in some unit tests but otherwise defaults to true.
            </summary>
        </member>
        <member name="P:Blockcore.NBitcoin.Policy.StandardTransactionPolicy.CheckScriptPubKey">
            <summary>
            Check the standardness of scriptPubKey.
            </summary>
        </member>
        <member name="T:Blockcore.NBitcoin.Protocol.NodeSocketEventManager">
            <summary>
            Singleton class which deals with a single instance of <see cref="T:System.Net.Sockets.SocketAsyncEventArgs"/>.
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.Protocol.NodeSocketEventManager.Create(System.Threading.ManualResetEvent,System.Net.IPEndPoint)">
            <summary>
            Creates a <see cref="T:Blockcore.NBitcoin.Protocol.NodeSocketEventManager"/> with a instance of <see cref="T:System.Net.Sockets.SocketAsyncEventArgs"/>.
            </summary>
            <param name="completedEvent">The event that will fire once the connection has been completed.</param>
            <param name="endpoint">The end point to connect to.</param>
        </member>
        <member name="P:Blockcore.NBitcoin.Protocol.NodeSocketEventManager.SocketEvent">
            <summary>
            An instance of <see cref="T:System.Net.Sockets.SocketAsyncEventArgs"/> which we will use in this manager.
            </summary>
        </member>
        <member name="T:Blockcore.NBitcoin.Protocol.ProtocolVersion">
            <summary>
            Network protocol versioning.
            </summary>
        </member>
        <member name="F:Blockcore.NBitcoin.Protocol.ProtocolVersion.POS_PROTOCOL_VERSION">
            <summary>
            Represents th protocol version of POS chains that was used before <see cref="F:Blockcore.NBitcoin.Protocol.ProtocolVersion.PROVEN_HEADER_VERSION"/>
            </summary>
        </member>
        <member name="F:Blockcore.NBitcoin.Protocol.ProtocolVersion.INIT_PROTO_VERSION">
            <summary>
            Initial protocol version; to be increased after version/verack negotiation.
            </summary>
        </member>
        <member name="F:Blockcore.NBitcoin.Protocol.ProtocolVersion.MIN_PEER_PROTO_VERSION">
            <summary>
            Disconnect from peers older than this protocol version.
            </summary>
        </member>
        <member name="F:Blockcore.NBitcoin.Protocol.ProtocolVersion.CADDR_TIME_VERSION">
            <summary>
            nTime field added to CAddress; starting with this version;
            if possible; avoid requesting addresses nodes older than this.
            </summary>
        </member>
        <member name="F:Blockcore.NBitcoin.Protocol.ProtocolVersion.NOBLKS_VERSION_START">
            <summary>
            Only request blocks from nodes outside this range of versions (START).
            </summary>
        </member>
        <member name="F:Blockcore.NBitcoin.Protocol.ProtocolVersion.NOBLKS_VERSION_END">
            <summary>
            Only request blocks from nodes outside this range of versions (END).
            </summary>
        </member>
        <member name="F:Blockcore.NBitcoin.Protocol.ProtocolVersion.BIP0031_VERSION">
            <summary>
            BIP 0031; pong message; is enabled for all versions AFTER this one.
            </summary>
        </member>
        <member name="F:Blockcore.NBitcoin.Protocol.ProtocolVersion.MEMPOOL_GD_VERSION">
            <summary>
            "mempool" command; enhanced "getdata" behavior starts with this version.
            </summary>
        </member>
        <member name="F:Blockcore.NBitcoin.Protocol.ProtocolVersion.REJECT_VERSION">
            <summary>
            "reject" command.
            </summary>
        </member>
        <member name="F:Blockcore.NBitcoin.Protocol.ProtocolVersion.NO_BLOOM_VERSION">
            <summary>
            ! "filter*" commands are disabled without NODE_BLOOM after and including this version.
            </summary>
        </member>
        <member name="F:Blockcore.NBitcoin.Protocol.ProtocolVersion.SENDHEADERS_VERSION">
            <summary>
            ! "sendheaders" command and announcing blocks with headers starts with this version.
            </summary>
        </member>
        <member name="F:Blockcore.NBitcoin.Protocol.ProtocolVersion.WITNESS_VERSION">
            <summary>
            ! Version after which witness support potentially exists.
            </summary>
        </member>
        <member name="F:Blockcore.NBitcoin.Protocol.ProtocolVersion.PROVEN_HEADER_VERSION">
            <summary>
            Communication between nodes with proven headers is possible after this version.
            This is for stratis only. Temporary solution; refers to issue #2144
            https://github.com/stratisproject/StratisBitcoinFullNode/issues/2144
            </summary>
        </member>
        <member name="F:Blockcore.NBitcoin.Protocol.ProtocolVersion.SHORT_IDS_BLOCKS_VERSION">
            <summary>
            shord-id-based block download starts with this version.
            </summary>
        </member>
        <member name="F:Blockcore.NBitcoin.Protocol.ProtocolVersion.FEEFILTER_VERSION">
            <summary>
            "feefilter" tells peers to filter invs to you by fee starts with this version.
            </summary>
        </member>
        <member name="F:Blockcore.NBitcoin.Protocol.ProtocolVersion.CIRRUS_MIN_SUPPORTED_VERSION">
            <summary>
            Oldest supported version of the CirrusNode which this node can connect to.
            </summary>
        </member>
        <member name="F:Blockcore.NBitcoin.Protocol.ProtocolVersion.CIRRUS_VERSION">
            <summary>
            Current version of the CirrusNode.
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.PubKey.#ctor(System.String)">
            <summary>
            Create a new Public key from string
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.PubKey.#ctor(System.Byte[])">
            <summary>
            Create a new Public key from byte array
            </summary>
        </member>
        <member name="M:Blockcore.NBitcoin.PubKey.#ctor(System.Byte[],System.Boolean)">
            <summary>
            Create a new Public key from byte array
            </summary>
            <param name="bytes">byte array</param>
            <param name="unsafe">If false, make internal copy of bytes and does perform only a costly check for PubKey format. If true, the bytes array is used as is and only PubKey.Check is used for validating the format. </param>
        </member>
        <member name="M:Blockcore.NBitcoin.PubKey.Check(System.Byte[],System.Boolean)">
            <summary>
            Check on public key format.
            </summary>
            <param name="data">bytes array</param>
            <param name="deep">If false, will only check the first byte and length of the array. If true, will also check that the ECC coordinates are correct.</param>
            <returns>true if byte array is valid</returns>
        </member>
        <member name="M:Blockcore.NBitcoin.PubKey.VerifyMessage(System.String,System.String)">
            <summary>
            Verify message signed using signmessage from bitcoincore
            </summary>
            <param name="message">The message</param>
            <param name="signature">The signature</param>
            <returns>True if signatures is valid</returns>
        </member>
        <member name="M:Blockcore.NBitcoin.PubKey.VerifyMessage(System.Byte[],System.String)">
            <summary>
            Verify message signed using signmessage from bitcoincore
            </summary>
            <param name="message">The message</param>
            <param name="signature">The signature</param>
            <returns>True if signatures is valid</returns>
        </member>
        <member name="M:Blockcore.NBitcoin.PubKey.VerifyMessage(System.Byte[],Blockcore.NBitcoin.Crypto.ECDSASignature)">
            <summary>
            Verify message signed using signmessage from bitcoincore.
            </summary>
            <param name="messageBytes">The message.</param>
            <param name="sig">The signature.</param>
            <returns>True if signature is valid.</returns>
        </member>
        <member name="M:Blockcore.NBitcoin.PubKey.DecodeSigString(System.String)">
            <summary>
            Decode signature from bitcoincore verify/signing rpc methods
            </summary>
            <param name="signature"></param>
            <returns></returns>
        </member>
        <member name="M:Blockcore.NBitcoin.PubKey.GetSharedSecret(Blockcore.NBitcoin.Key)">
            <summary>
            Exchange shared secret through ECDH
            </summary>
            <param name="key">Private key</param>
            <returns>Shared secret</returns>
        </member>
        <member name="M:Blockcore.NBitcoin.PubKey.GetSharedPubkey(Blockcore.NBitcoin.Key)">
            <summary>
            Exchange shared secret through ECDH
            </summary>
            <param name="key">Private key</param>
            <returns>Shared pubkey</returns>
        </member>
        <member name="T:Blockcore.NBitcoin.Repository.ITransactionRepository">
            <summary>
            Represent a transaction map
            </summary>
        </member>
        <member name="F:Blockcore.NBitcoin.Sequence.SEQUENCE_LOCKTIME_DISABLE_FLAG">
            <summary>
            If this flag set, CTxIn::nSequence is NOT interpreted as a
            relative lock-time. 
            </summary>
        </member>
        <member name="F:Blockcore.NBitcoin.Sequence.SEQUENCE_LOCKTIME_TYPE_FLAG">
            <summary>
            If CTxIn::nSequence encodes a relative lock-time and this flag
            is set, the relative lock-time has units of 512 seconds,
            otherwise it specifies blocks with a granularity of 1. 
            </summary>
        </member>
        <member name="F:Blockcore.NBitcoin.Sequence.SEQUENCE_LOCKTIME_MASK">
            <summary>
            If CTxIn::nSequence encodes a relative lock-time, this mask is
            applied to extract that lock-time from the sequence field.
            </summary>
        </member>
        <member name="F:Blockcore.NBitcoin.Sequence.SEQUENCE_FINAL">
            <summary>
            Setting nSequence to this value for every input in a transaction
            disables nLockTime. */
            </summary>
            <remarks>
            If this flag set, CTxIn::nSequence is NOT interpreted as a
            relative lock-time. Setting the most significant bit of a
            sequence number disabled relative lock-time.
            </remarks>
        </member>
        <member name="F:Blockcore.NBitcoin.Sequence.SEQUENCE_LOCKTIME_GRANULARITY">
            <summary>
            In order to use the same number of bits to encode roughly the
            same wall-clock duration, and because blocks are naturally
            limited to occur every 600s on average, the minimum granularity
            for time-based relative lock-time is fixed at 512 seconds.
            Converting from CTxIn::nSequence to seconds is performed by
            multiplying by 512 = 2^9, or equivalently shifting up by
            9 bits. 
            </summary>
        </member>
        <member name="T:Blockcore.NBitcoin.Target">
            <summary>
            Represent the challenge that miners must solve for finding a new block
            </summary>
        </member>
        <member name="T:Blockcore.NBitcoin.uint256">
            <summary>
            An implementation of uint256 based on https://github.com/MithrilMan/MithrilShards
            Link to type https://github.com/MithrilMan/MithrilShards/blob/master/src/MithrilShards.Core/DataTypes/Uint256.cs
            Big credit to @MithrilMan for making this optimization
            </summary>
        </member>
        <member name="T:Blockcore.Networks.NetworksSelector">
            <summary>
            A container of all network instances of a certain high level network.
            Every network normally comes in 3 flavors mainnet, testnet and regtest.
            </summary>
        </member>
        <member name="P:Blockcore.Networks.Network.DefaultBanTimeSeconds">
            <summary>
            The default amount of seconds to keep misbehaving peers from reconnecting.
            <para>
            This value should be calculated as (TargetSpacingSeconds * maxReorgLength) / 2.
            </para>
            </summary>
        </member>
        <member name="P:Blockcore.Networks.Network.MaxTimeOffsetSeconds">
            <summary>
            Maximal value for the calculated time offset.
            If the value is over this limit, the time syncing feature will be switched off.
            </summary>
        </member>
        <member name="P:Blockcore.Networks.Network.MaxTipAge">
            <summary>
            Maximum tip age in seconds to consider node in initial block download.
            </summary>
        </member>
        <member name="P:Blockcore.Networks.Network.MaxTxFee">
            <summary>
            The total fee this node will allow
            </summary>
        </member>
        <member name="P:Blockcore.Networks.Network.MinTxFee">
            <summary>
            Mininum fee rate for all transactions.
            Fees smaller than this are considered zero fee for transaction creation.
            Be careful setting this: if you set it to zero then a transaction spammer can cheaply fill blocks using
            1-satoshi-fee transactions. It should be set above the real cost to you of processing a transaction.
            </summary>
            <remarks>
            The <see cref="P:Blockcore.Networks.Network.MinRelayTxFee"/> and <see cref="P:Blockcore.Networks.Network.MinTxFee"/> are typically the same value to prevent dos attacks on the network.
            If <see cref="P:Blockcore.Networks.Network.MinRelayTxFee"/> is less than <see cref="P:Blockcore.Networks.Network.MinTxFee"/>, an attacker can broadcast a lot of transactions with fees between these two values,
            which will lead to transactions filling the mempool without ever being mined.
            </remarks>
        </member>
        <member name="P:Blockcore.Networks.Network.FallbackFee">
            <summary>
            A fee rate that will be used when fee estimation has insufficient data.
            </summary>
        </member>
        <member name="P:Blockcore.Networks.Network.MinRelayTxFee">
            <summary>
            The minimum fee under which transactions may be rejected from being relayed.
            </summary>
            <remarks>
            The <see cref="P:Blockcore.Networks.Network.MinRelayTxFee"/> and <see cref="P:Blockcore.Networks.Network.MinTxFee"/> are typically the same value to prevent dos attacks on the network.
            If <see cref="P:Blockcore.Networks.Network.MinRelayTxFee"/> is less than <see cref="P:Blockcore.Networks.Network.MinTxFee"/>, an attacker can broadcast a lot of transactions with fees between these two values,
            which will lead to transactions filling the mempool without ever being mined.
            </remarks>
        </member>
        <member name="P:Blockcore.Networks.Network.DefaultRPCPort">
            <summary>
            Port on which to listen for incoming RPC connections.
            </summary>
        </member>
        <member name="P:Blockcore.Networks.Network.DefaultAPIPort">
            <summary>
            Port on which to listen for incoming API connections.
            </summary>
        </member>
        <member name="P:Blockcore.Networks.Network.DefaultPort">
            <summary>
            The default port on which nodes of this network communicate with external clients.
            </summary>
        </member>
        <member name="P:Blockcore.Networks.Network.DefaultMaxOutboundConnections">
            <summary>
            The default maximum number of outbound connections a node on this network will form.
            </summary>
        </member>
        <member name="P:Blockcore.Networks.Network.DefaultMaxInboundConnections">
            <summary>
            The default maximum number of inbound connections a node on this network will accept.
            </summary>
        </member>
        <member name="P:Blockcore.Networks.Network.Consensus">
            <summary>
            The consensus for this network.
            </summary>
        </member>
        <member name="P:Blockcore.Networks.Network.Name">
            <summary>
            The name of the network.
            </summary>
        </member>
        <member name="P:Blockcore.Networks.Network.AdditionalNames">
            <summary>
            A list of additional names the network can be referred as.
            For example, Bitcoin Main can have "Mainnet" as an additional name.
            </summary>
        </member>
        <member name="P:Blockcore.Networks.Network.CoinTicker">
            <summary>
            An indicative coin ticker for use with external applications.
            </summary>
        </member>
        <member name="P:Blockcore.Networks.Network.RootFolderName">
            <summary>
            The name of the root folder containing blockchains operating with the same consensus rules (for now, this will be bitcoin or stratis).
            </summary>
        </member>
        <member name="P:Blockcore.Networks.Network.DefaultConfigFilename">
            <summary>
            The default name used for the network configuration file.
            </summary>
        </member>
        <member name="P:Blockcore.Networks.Network.SeedNodes">
            <summary>
            The list of nodes on the network that our current node tries to connect to.
            </summary>
        </member>
        <member name="P:Blockcore.Networks.Network.DNSSeeds">
            <summary>
            The list of DNS seeds from which to get IP addresses when bootstrapping a node.
            </summary>
        </member>
        <member name="P:Blockcore.Networks.Network.Checkpoints">
            <summary>
            A list of well-known block hashes.
            The node considers all transactions and blocks up to these checkpoints as valid and irreversible.
            </summary>
        </member>
        <member name="P:Blockcore.Networks.Network.Base58Prefixes">
            <summary>
            List of prefixes used in Base58 addresses.
            </summary>
        </member>
        <member name="P:Blockcore.Networks.Network.Bech32Encoders">
            <summary>
            A list of Bech32 encoders.
            </summary>
        </member>
        <member name="P:Blockcore.Networks.Network.Magic">
            <summary>
            A number used to identify the network.
            The message start string is designed to be unlikely to occur in normal data.
            The characters are rarely used upper ascii, not valid as UTF-8, and produce
            a large 4-byte int at any alignment.
            </summary>
        </member>
        <member name="F:Blockcore.Networks.Network.MagicBytesArray">
            <summary>
            Byte array representation of a magic number.
            </summary>
        </member>
        <member name="P:Blockcore.Networks.Network.MagicBytes">
            <summary>
            Byte representation of a magic number.
            Uses <see cref="P:Blockcore.Networks.Network.Magic"/> if <see cref="F:Blockcore.Networks.Network.MagicBytesArray"/> is null.
            TODO: Merge these 3 magic properties into fewer.
            </summary>
        </member>
        <member name="P:Blockcore.Networks.Network.GenesisTime">
            <summary>
            The UNIX time at inception of the genesis block for this network.
            </summary>
        </member>
        <member name="P:Blockcore.Networks.Network.GenesisNonce">
            <summary>
            A hash which proves that a sufficient amount of computation has been carried out to create the genesis block.
            </summary>
        </member>
        <member name="P:Blockcore.Networks.Network.GenesisBits">
            <summary>
            Represents the encoded form of the target threshold as it appears in the block header.
            </summary>
        </member>
        <member name="P:Blockcore.Networks.Network.GenesisVersion">
            <summary>
            The version of the genesis block.
            </summary>
        </member>
        <member name="P:Blockcore.Networks.Network.GenesisReward">
            <summary>
            The reward for the genesis block, which is unspendable.
            </summary>
        </member>
        <member name="P:Blockcore.Networks.Network.StandardScriptsRegistry">
            <summary>
            The list of script templates regarded as standard.
            Standardness is a distinct property from consensus validity.
            A non-standard transaction can still be mined/staked by a willing node and the resulting block will be accepted by the network.
            However, a non-standard transaction will typically not be relayed between nodes.
            </summary>
        </member>
        <member name="P:Blockcore.Networks.Network.FullNodeBuilderServiceOverride">
            <summary>
            Allow the DI to override services.
            </summary>
        </member>
        <member name="M:Blockcore.Networks.Network.MineGenesisBlock(Blockcore.Consensus.ConsensusFactory,System.String,Blockcore.NBitcoin.Target,Blockcore.NBitcoin.Money,System.Int32)">
            <summary>
            Mines a new genesis block, to use with a new network.
            Typically, 3 such genesis blocks need to be created when bootstrapping a new coin: for Main, Test and Reg networks.
            </summary>
            <param name="consensusFactory">
            The consensus factory used to create transactions and blocks.
            Use <see cref="T:Blockcore.Consensus.BlockInfo.PosConsensusFactory"/> for proof-of-stake based networks.
            </param>
            <param name="coinbaseText">
            Traditionally a news headline from the day of the launch, but could be any string or link.
            This will be inserted in the input coinbase transaction script.
            It should be shorter than 92 characters.
            </param>
            <param name="target">
            The difficulty target under which the hash of the block need to be.
            Some more details: As an example, the target for the Stratis Main network is 00000fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff.
            To make it harder to mine the genesis block, have more zeros at the beginning (keeping the length the same). This will make the target smaller, so finding a number under it will be more difficult.
            To make it easier to mine the genesis block ,do the opposite. Example of an easy one: 00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff.
            Make the Test and Reg targets ones easier to find than the Main one so that you don't wait too long to mine the genesis block.
            </param>
            <param name="genesisReward">
            Specify how many coins to put in the genesis transaction's output. These coins are unspendable.
            </param>
            <param name="version">
            The version of the transaction and the block header set in the genesis block.
            </param>
            <example>
            The following example shows the creation of a genesis block.
            <code>
            Block genesis = MineGenesisBlock(new PosConsensusFactory(), "Some topical headline.", new Target(new uint256("000fffff00000000000000000000000000000000000000000000000000000000")), Money.Coins(50m));
            BlockHeader header = genesis.Header;
            Console.WriteLine("Make a note of the following values:");
            Console.WriteLine("bits: " + header.Bits);
            Console.WriteLine("nonce: " + header.Nonce);
            Console.WriteLine("time: " + header.Time);
            Console.WriteLine("version: " + header.Version);
            Console.WriteLine("hash: " + header.GetHash());
            Console.WriteLine("merkleroot: " + header.HashMerkleRoot);
            </code>
            </example>
            <returns>A genesis block.</returns>
        </member>
        <member name="M:Blockcore.Networks.Network.CreateBitcoinAddress(System.String)">
            <summary>
            Create a bitcoin address from base58 data, return a BitcoinAddress or BitcoinScriptAddress
            </summary>
            <param name="base58">base58 address</param>
            <exception cref="T:System.FormatException">Invalid base58 address</exception>
            <returns>BitcoinScriptAddress, BitcoinAddress</returns>
        </member>
        <member name="T:Blockcore.Networks.NetworkRegistration">
            <summary>
            A container for storing/retrieving known networks.
            </summary>
        </member>
        <member name="M:Blockcore.Networks.NetworkRegistration.Register(Blockcore.Networks.Network)">
            <summary>
            Register an immutable <see cref="T:Blockcore.Networks.Network"/> instance so it is queryable through <see cref="M:Blockcore.Networks.NetworkRegistration.GetNetwork(System.String)"/> and <see cref="M:Blockcore.Networks.NetworkRegistration.GetNetworks"/>.
            <para>
            If the network already exists, the already registered instance will be returned from the <see cref="F:Blockcore.Networks.NetworkRegistration.RegisteredNetworks"/> collection.
            </para>
            </summary>
        </member>
        <member name="M:Blockcore.Networks.NetworkRegistration.Clear">
            <summary>
            Clears the <see cref="F:Blockcore.Networks.NetworkRegistration.RegisteredNetworks"/> collection.
            </summary>
        </member>
        <member name="M:Blockcore.Networks.NetworkRegistration.GetNetwork(System.String)">
            <summary>
            Get network from name
            </summary>
            <param name="name">main,mainnet,testnet,test,testnet3,reg,regtest,seg,segnet</param>
            <returns>The network or null of the name does not match any network.</returns>
        </member>
        <member name="T:Blockcore.P2P.DNSSeedData">
            <summary>
            Represent a DNS seed.
            This is intended to help nodes to connect to the network on their first run.
            As such, DNS seeds must be run by entities in which some level of trust if given by the community running the nodes.
            </summary>
        </member>
        <member name="F:Blockcore.P2P.DNSSeedData.addresses">
            <summary> A list of IP addresses associated with this host. </summary>
        </member>
        <member name="P:Blockcore.P2P.DNSSeedData.Name">
            <summary> The name given to this DNS seed. </summary>
        </member>
        <member name="P:Blockcore.P2P.DNSSeedData.Host">
            <summary> The DNS server host. </summary>
        </member>
        <member name="M:Blockcore.P2P.DNSSeedData.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Blockcore.P2P.DNSSeedData"/> class.
            </summary>
            <param name="name">The name given to this DNS seed.</param>
            <param name="host">The DNS server host.</param>
        </member>
        <member name="M:Blockcore.P2P.DNSSeedData.GetAddressNodes(System.Boolean)">
            <summary>
            Gets the IP addresses of nodes associated with the host.
            </summary>
            <param name="forceRefresh">Normally the DNS lookups get cached after the first resolution. This indicates that the results should be discarded and overwritten.</param>
            <returns>A list of IP addresses.</returns>
        </member>
        <member name="M:Blockcore.P2P.DNSSeedData.ToString">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.P2P.IPeerAddressManager">
            <summary>Contract for <see cref="T:Blockcore.P2P.PeerAddressManager"/>.</summary>
        </member>
        <member name="P:Blockcore.P2P.IPeerAddressManager.PeerFilePath">
            <summary>Data folder of where the json peer file is located.</summary>
        </member>
        <member name="P:Blockcore.P2P.IPeerAddressManager.Peers">
            <summary>A collection of all discovered peers.</summary>
        </member>
        <member name="M:Blockcore.P2P.IPeerAddressManager.AddPeer(System.Net.IPEndPoint,System.Net.IPAddress)">
            <summary>
            Adds a peer to the <see cref="P:Blockcore.P2P.IPeerAddressManager.Peers"/> dictionary if it doesn't exist yet.
            <para>
            Only routable IP addresses will be added. See <see cref="M:Blockcore.P2P.IpExtensions.IsRoutable(System.Net.IPAddress,System.Boolean)"/>.
            </para>
            </summary>
        </member>
        <member name="M:Blockcore.P2P.IPeerAddressManager.AddPeers(System.Collections.Generic.IEnumerable{System.Net.IPEndPoint},System.Net.IPAddress)">
            <summary>
            Add a set of peers to the <see cref="P:Blockcore.P2P.IPeerAddressManager.Peers"/> dictionary.
            <para>
            Only routable IP addresses will be added. <see cref="M:Blockcore.P2P.IpExtensions.IsRoutable(System.Net.IPAddress,System.Boolean)"/>
            </para>
            </summary>
        </member>
        <member name="M:Blockcore.P2P.IPeerAddressManager.RemovePeer(System.Net.IPEndPoint)">
            <summary>
            Remove a peer from the <see cref="P:Blockcore.P2P.IPeerAddressManager.Peers"/> dictionary.
            </summary>
        </member>
        <member name="M:Blockcore.P2P.IPeerAddressManager.FindPeer(System.Net.IPEndPoint)">
            <summary>Find a peer by endpoint.</summary>
        </member>
        <member name="M:Blockcore.P2P.IPeerAddressManager.FindPeersByIp(System.Net.IPEndPoint)">
            <summary>Find peers by IP (the port is irrelevant).</summary>
        </member>
        <member name="M:Blockcore.P2P.IPeerAddressManager.LoadPeers">
            <summary>Loads peers from a json formatted file on disk.</summary>
        </member>
        <member name="M:Blockcore.P2P.IPeerAddressManager.SavePeers">
            <summary>Persist peers to disk in json format.</summary>
        </member>
        <member name="M:Blockcore.P2P.IPeerAddressManager.PeerAttempted(System.Net.IPEndPoint,System.DateTime)">
            <summary>
            A connection attempt was made to a peer.
            <para>
            Increments <see cref="P:Blockcore.P2P.PeerAddress.ConnectionAttempts"/> of the peer as well as the <see cref="P:Blockcore.P2P.PeerAddress.LastConnectionSuccess"/>
            </para>
            </summary>
        </member>
        <member name="M:Blockcore.P2P.IPeerAddressManager.PeerConnected(System.Net.IPEndPoint,System.DateTimeOffset)">
            <summary>
            A peer was successfully connected to.
            <para>
            Resets the <see cref="P:Blockcore.P2P.PeerAddress.ConnectionAttempts"/> and <see cref="P:Blockcore.P2P.PeerAddress.LastAttempt"/> of the peer.
            Sets the peer's <see cref="P:Blockcore.P2P.PeerAddress.LastConnectionSuccess"/> to now.
            </para>
            </summary>
        </member>
        <member name="M:Blockcore.P2P.IPeerAddressManager.PeerDiscoveredFrom(System.Net.IPEndPoint,System.DateTime)">
            <summary>
            Sets the last time the peer was asked for addresses via discovery.
            </summary>
        </member>
        <member name="M:Blockcore.P2P.IPeerAddressManager.PeerHandshaked(System.Net.IPEndPoint,System.DateTimeOffset)">
            <summary>
            A version handshake between two peers was successful.
            <para>
            Sets the peer's <see cref="P:Blockcore.P2P.PeerAddress.LastConnectionHandshake"/> time to now.
            </para>
            </summary>
        </member>
        <member name="M:Blockcore.P2P.IPeerAddressManager.PeerSeen(System.Net.IPEndPoint,System.DateTime)">
            <summary>
            Sets the last time the peer was seen.
            </summary>
        </member>
        <member name="P:Blockcore.P2P.IPeerAddressManager.PeerSelector">
            <summary>Peer selector instance, used to select peers to connect to.</summary>
        </member>
        <member name="M:Blockcore.P2P.IpExtensions.IsRFC5737(System.Net.IPAddress)">
            <summary>192.0.2.0/24, 198.51.100.0/24, 203.0.113.0/24 Documentation. Not globally reachable.</summary>
        </member>
        <member name="M:Blockcore.P2P.IpExtensions.IsRFC6598(System.Net.IPAddress)">
            <summary>100.64.0.0/10 Shared Address Space. Not globally reachable.</summary>
        </member>
        <member name="M:Blockcore.P2P.IpExtensions.IsRFC7535(System.Net.IPAddress)">
            <summary>192.31.196.0/24 AS112-v4. Globally reachable.</summary>
        </member>
        <member name="M:Blockcore.P2P.IpExtensions.IsRFC7450(System.Net.IPAddress)">
            <summary>192.52.193.0/24 AMT. Globally reachable.</summary>
        </member>
        <member name="M:Blockcore.P2P.IpExtensions.IsRFC7526(System.Net.IPAddress)">
            <summary>192.88.99.0/24 Deprecated (6to4 Relay Anycast).</summary>
        </member>
        <member name="M:Blockcore.P2P.IpExtensions.IsRFC7534(System.Net.IPAddress)">
            <summary>192.175.48.0/24 Direct Delegation AS112 Service. Globally reachable. Not globally unique.</summary>
        </member>
        <member name="M:Blockcore.P2P.IpExtensions.IsRFC2544(System.Net.IPAddress)">
            <summary>198.18.0.0/15 Benchmarking. Not globally reachable.</summary>
        </member>
        <member name="M:Blockcore.P2P.IpExtensions.IsRFC1112(System.Net.IPAddress)">
            <summary>240.0.0.0/4 Reserved.</summary>
        </member>
        <member name="M:Blockcore.P2P.IpExtensions.IsRFC6890(System.Net.IPAddress)">
            <summary>192.0.0.0/24 IETF Protocol Assignments.</summary>
        </member>
        <member name="M:Blockcore.P2P.IpExtensions.IsRoutable(System.Net.IPAddress,System.Boolean)">
            <summary>
            Specific IP address ranges that are reserved specifically as non - routable addresses to be used in
            private networks: 10.0.0.0 through 10.255.255.255. 172.16.0.0 through 172.32.255.255. 192.168.0.0
            through 192.168.255.255.
            </summary>
        </member>
        <member name="T:Blockcore.P2P.ISelfEndpointTracker">
            <summary>
            Tracker for endpoints known to be self.
            </summary>
        </member>
        <member name="M:Blockcore.P2P.ISelfEndpointTracker.UpdateAndAssignMyExternalAddress(System.Net.IPEndPoint,System.Boolean,System.Int32)">
            <summary>Update external IP address and peer score of the node.</summary>
            <param name="ipEndPoint">The endpoint to add.</param>
            <param name="suppliedEndPointIsFinal">Whether the <paramref name="ipEndPoint"/> supplied should be marked final on the endpoint tracker.</param>
            <param name="ipEndPointPeerScore">Peer score of the <paramref name="ipEndPoint"/> supplied. Default value of 1.</param>
        </member>
        <member name="P:Blockcore.P2P.ISelfEndpointTracker.MyExternalAddress">
            <summary>External IP address of the node.</summary>
        </member>
        <member name="M:Blockcore.P2P.ISelfEndpointTracker.Add(System.Net.IPEndPoint)">
            <summary>Adds an endpoint to the currently known list.</summary>
            <param name="ipEndPoint">The endpoint to add.</param>
        </member>
        <member name="M:Blockcore.P2P.ISelfEndpointTracker.IsSelf(System.Net.IPEndPoint)">
            <summary>Checks if endpoint is known to be itself against the pruned dictionary.</summary>
            <param name="ipEndPoint">The endpoint to check.</param>
            <returns><c>true</c> if self, <c>false</c> if unknown.</returns>
        </member>
        <member name="T:Blockcore.P2P.PeerAddress">
            <summary>
            A class which holds data on a peer's (IPEndPoint) attempts, connections and successful handshake events.
            </summary>
        </member>
        <member name="F:Blockcore.P2P.PeerAddress.AttemptThreshold">
            <summary>
            The maximum amount of times a peer can be attempted within a give time frame.
            </summary>
        </member>
        <member name="F:Blockcore.P2P.PeerAddress.AttemptHandshakeThreshold">
            <summary>
            The maximum amount of times handshake can be attempted within a give time frame.
            </summary>
        </member>
        <member name="F:Blockcore.P2P.PeerAddress.AttempThresholdHours">
            <summary>
            The amount of hours we will wait before selecting an attempted peer again,
            if it hasn't yet reached the <see cref="F:Blockcore.P2P.PeerAddress.AttemptThreshold"/> amount of attempts.
            </summary>
        </member>
        <member name="F:Blockcore.P2P.PeerAddress.AttemptResetThresholdHours">
            <summary>
            The amount of hours after which the peer's failed connection attempts
            will be reset to zero.
            </summary>
        </member>
        <member name="P:Blockcore.P2P.PeerAddress.Endpoint">
            <summary>Endpoint of this peer.</summary>
        </member>
        <member name="F:Blockcore.P2P.PeerAddress.addressTime">
            <summary>Used to construct the <see cref="!:NetworkAddress"/> after deserializing this peer.</summary>
        </member>
        <member name="F:Blockcore.P2P.PeerAddress.loopback">
            <summary>The source address of this peer.</summary>
        </member>
        <member name="P:Blockcore.P2P.PeerAddress.ConnectionAttempts">
            <summary>
            The amount of connection attempts.
            <para>
            This gets reset when a connection was successful.</para>
            </summary>
        </member>
        <member name="P:Blockcore.P2P.PeerAddress.HandshakedAttempts">
            <summary>
            The amount of handshake attempts.
            <para>
            This gets reset when a handshake was successful.</para>
            </summary>
        </member>
        <member name="P:Blockcore.P2P.PeerAddress.LastConnectionHandshake">
            <summary>
            The last successful version handshake.
            <para>
            This is set when the connection attempt was successful and a handshake was done.
            </para>
            </summary>
        </member>
        <member name="P:Blockcore.P2P.PeerAddress.LastHandshakeAttempt">
            <summary>
            The last handshake attempt.
            </summary>
        </member>
        <member name="P:Blockcore.P2P.PeerAddress.LastSeen">
            <summary>
            The last time this peer was seen.
            <para>
            This is set via <see cref="T:Blockcore.P2P.Protocol.Behaviors.PingPongBehavior"/> to ensure that a peer is live.
            </para>
            </summary>
        </member>
        <member name="P:Blockcore.P2P.PeerAddress.BanTimeStamp">
            <summary>
            UTC DateTime when a peer is banned.
            </summary>
            <remarks>
            This is set in <see cref="!:PeerBanning"/>.
            </remarks>
        </member>
        <member name="P:Blockcore.P2P.PeerAddress.BanUntil">
            <summary>
            UTC DateTime when the ban expires against the peer.
            </summary>
            <remarks>
            This is set in <see cref="!:PeerBanning"/>.
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Blockcore.P2P.PeerAddress.BanReason" -->
        <member name="P:Blockcore.P2P.PeerAddress.BanScore">
            <summary>
            Maintain a count of bad behaviour.
            <para>
            Once a certain score is reached ban the peer.
            </para>
            </summary>
            <remarks>
            The logic around this has not yet been implemented.
            This is set in <see cref="!:PeerBanning"/>.
            </remarks>
        </member>
        <member name="P:Blockcore.P2P.PeerAddress.Attempted">
            <summary>
            <c>True</c> if the peer has had connection attempts but none successful.
            </summary>
        </member>
        <member name="P:Blockcore.P2P.PeerAddress.Connected">
            <summary>
            <c>True</c> if the peer has had a successful connection attempt.
            </summary>
        </member>
        <member name="P:Blockcore.P2P.PeerAddress.Fresh">
            <summary>
            <c>True</c> if the peer has never had connection attempts.
            </summary>
        </member>
        <member name="P:Blockcore.P2P.PeerAddress.Handshaked">
            <summary>
            <c>True</c> if the peer has had a successful connection attempt and handshaked.
            </summary>
        </member>
        <member name="P:Blockcore.P2P.PeerAddress.LastAttempt">
            <summary>
            The last connection attempt.
            <para>
            This is set regardless of whether or not the connection attempt was successful or not.
            </para>
            </summary>
        </member>
        <member name="P:Blockcore.P2P.PeerAddress.LastConnectionSuccess">
            <summary>
            The last successful connection attempt.
            <para>
            This is set when the connection attempt was successful (but not necessarily handshaked).
            </para>
            </summary>
        </member>
        <member name="P:Blockcore.P2P.PeerAddress.LastDiscoveredFrom">
            <summary>
            The last time this peer was discovered from.
            </summary>
        </member>
        <member name="P:Blockcore.P2P.PeerAddress.CanResetAttempts">
            <summary>
            Determines whether the peer's attempt thresholds has been reached so that it can be reset.
            <para>
            Resetting this allows the <see cref="T:Blockcore.P2P.PeerSelector"/> to re-select the peer for connection.
            </para>
            <para>
            <list>
            <item>The last attempt was more than the <see cref="F:Blockcore.P2P.PeerAddress.AttemptResetThresholdHours"/> time ago.</item>
            <item>The peer has been attempted more than the maximum amount of attempts (<see cref="F:Blockcore.P2P.PeerAddress.AttemptThreshold"/>.</item>
            </list>
            </para>
            </summary>
        </member>
        <member name="M:Blockcore.P2P.PeerAddress.ResetAttempts">
            <summary>
            Resets the amount of <see cref="P:Blockcore.P2P.PeerAddress.ConnectionAttempts"/>.
            <para>
            This is reset when the amount of failed connection attempts reaches
            the <see cref="F:Blockcore.P2P.PeerAddress.AttemptThreshold"/> and the last attempt was
            made more than <see cref="F:Blockcore.P2P.PeerAddress.AttemptResetThresholdHours"/> ago.
            </para>
            </summary>
        </member>
        <member name="M:Blockcore.P2P.PeerAddress.ResetHandshakeAttempts">
            <summary>
            Resets the amount of <see cref="P:Blockcore.P2P.PeerAddress.HandshakedAttempts"/>.
            <para>
            This is reset when the amount of failed handshake attempts reaches
            the <see cref="P:Blockcore.P2P.PeerAddress.HandshakedAttempts"/> and the last attempt was
            made more than <see cref="F:Blockcore.P2P.PeerAddress.AttempThresholdHours"/> ago.
            </para>
            </summary>
        </member>
        <member name="M:Blockcore.P2P.PeerAddress.SetAttempted(System.DateTime)">
            <summary>
            Increments <see cref="P:Blockcore.P2P.PeerAddress.ConnectionAttempts"/> and sets the <see cref="P:Blockcore.P2P.PeerAddress.LastAttempt"/>.
            </summary>
        </member>
        <member name="M:Blockcore.P2P.PeerAddress.SetHandshakeAttempted(System.DateTimeOffset)">
            <summary>
            Increments <see cref="P:Blockcore.P2P.PeerAddress.HandshakedAttempts"/> and sets the <see cref="P:Blockcore.P2P.PeerAddress.LastHandshakeAttempt"/>.
            </summary>
        </member>
        <member name="M:Blockcore.P2P.PeerAddress.SetConnected(System.DateTimeOffset)">
            <summary>
            Sets the <see cref="P:Blockcore.P2P.PeerAddress.LastConnectionSuccess"/>, <see cref="F:Blockcore.P2P.PeerAddress.addressTime"/> and <see cref="!:NetworkAddress.Time"/> properties.
            <para>
            Resets <see cref="P:Blockcore.P2P.PeerAddress.ConnectionAttempts"/> and <see cref="P:Blockcore.P2P.PeerAddress.LastAttempt"/>.
            </para>
            </summary>
        </member>
        <member name="M:Blockcore.P2P.PeerAddress.SetDiscoveredFrom(System.DateTime)">
            <summary>Sets the <see cref="P:Blockcore.P2P.PeerAddress.LastDiscoveredFrom"/> time.</summary>
        </member>
        <member name="M:Blockcore.P2P.PeerAddress.SetHandshaked(System.DateTimeOffset)">
            <summary>Sets the <see cref="P:Blockcore.P2P.PeerAddress.LastConnectionHandshake"/> date.</summary>
        </member>
        <member name="M:Blockcore.P2P.PeerAddress.SetLastSeen(System.DateTime)">
            <summary>Sets the <see cref="P:Blockcore.P2P.PeerAddress.LastSeen"/> date.</summary>
        </member>
        <member name="M:Blockcore.P2P.PeerAddress.IsBanned(System.DateTime)">
            <summary>Determines if the peer is currently banned.</summary>
        </member>
        <member name="M:Blockcore.P2P.PeerAddress.UnBan">
            <summary>
            Un-bans a peer by resetting the <see cref="P:Blockcore.P2P.PeerAddress.BanReason"/>, <see cref="P:Blockcore.P2P.PeerAddress.BanScore"/>, <see cref="P:Blockcore.P2P.PeerAddress.BanTimeStamp"/> and <see cref="P:Blockcore.P2P.PeerAddress.BanUntil"/> properties.
            </summary>
        </member>
        <member name="M:Blockcore.P2P.PeerAddress.Create(System.Net.IPEndPoint)">
            <summary>
            Creates a new peer address instance.
            </summary>
            <param name="endPoint">The end point of the peer.</param>
        </member>
        <member name="M:Blockcore.P2P.PeerAddress.Create(System.Net.IPEndPoint,System.Net.IPAddress)">
            <summary>
            Creates a new peer address instance and sets the loopback address (source).
            </summary>
            <param name="endPoint">The end point of the peer.</param>
            <param name="loopback">The loopback (source) of the peer.</param>
        </member>
        <member name="T:Blockcore.P2P.PeerAddressManager">
            <summary>
            This manager keeps a set of peers discovered on the network in cache and on disk.
            <para>
            The manager updates peer state according to how recent they have been connected to or not.
            </para>
            </summary>
        </member>
        <member name="F:Blockcore.P2P.PeerAddressManager.dateTimeProvider">
            <summary>Provider of time functions.</summary>
        </member>
        <member name="F:Blockcore.P2P.PeerAddressManager.logger">
            <summary>Instance logger.</summary>
        </member>
        <member name="F:Blockcore.P2P.PeerAddressManager.peerInfoByPeerAddress">
            <summary>Key value store that indexes all discovered peers by their end point.</summary>
        </member>
        <member name="P:Blockcore.P2P.PeerAddressManager.Peers">
            <inheritdoc />
        </member>
        <member name="F:Blockcore.P2P.PeerAddressManager.PeerFileName">
            <summary>The file name of the peers file.</summary>
        </member>
        <member name="P:Blockcore.P2P.PeerAddressManager.PeerFilePath">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.P2P.PeerAddressManager.PeerSelector">
            <summary>Peer selector instance, used to select peers to connect to.</summary>
        </member>
        <member name="F:Blockcore.P2P.PeerAddressManager.fileStorage">
            <summary>An object capable of storing a list of <see cref="T:Blockcore.P2P.PeerAddress"/>s to the file system.</summary>
        </member>
        <member name="M:Blockcore.P2P.PeerAddressManager.#ctor(Blockcore.Utilities.IDateTimeProvider,Blockcore.Configuration.DataFolder,Microsoft.Extensions.Logging.ILoggerFactory,Blockcore.P2P.ISelfEndpointTracker)">
            <summary>Constructor used by dependency injection.</summary>
        </member>
        <member name="M:Blockcore.P2P.PeerAddressManager.LoadPeers">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.P2P.PeerAddressManager.SavePeers">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.P2P.PeerAddressManager.AddPeer(System.Net.IPEndPoint,System.Net.IPAddress)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.PeerAddressManager.AddPeers(System.Collections.Generic.IEnumerable{System.Net.IPEndPoint},System.Net.IPAddress)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.PeerAddressManager.RemovePeer(System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.PeerAddressManager.PeerAttempted(System.Net.IPEndPoint,System.DateTime)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.PeerAddressManager.PeerConnected(System.Net.IPEndPoint,System.DateTimeOffset)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.PeerAddressManager.PeerDiscoveredFrom(System.Net.IPEndPoint,System.DateTime)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.PeerAddressManager.PeerHandshaked(System.Net.IPEndPoint,System.DateTimeOffset)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.PeerAddressManager.PeerSeen(System.Net.IPEndPoint,System.DateTime)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.PeerAddressManager.FindPeer(System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.PeerAddressManager.FindPeersByIp(System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.PeerAddressManager.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.P2P.PeerAddressManagerBehaviour">
            <summary>
            Behaviour implementation that encapsulates <see cref="T:Blockcore.P2P.IPeerAddressManager"/>.
            <para>
            Subscribes to state change events from <see cref="T:Blockcore.P2P.Peer.INetworkPeer"/> and relays connection and handshake attempts to
            the <see cref="T:Blockcore.P2P.IPeerAddressManager"/> instance.
            </para>
            </summary>
        </member>
        <member name="F:Blockcore.P2P.PeerAddressManagerBehaviour.dateTimeProvider">
            <summary>Provider of time functions.</summary>
        </member>
        <member name="F:Blockcore.P2P.PeerAddressManagerBehaviour.logger">
            <summary>Instance logger.</summary>
        </member>
        <member name="F:Blockcore.P2P.PeerAddressManagerBehaviour.loggerFactory">
            <summary>Builds loggers.</summary>
        </member>
        <member name="P:Blockcore.P2P.PeerAddressManagerBehaviour.Mode">
            <summary>See <see cref="T:Blockcore.P2P.PeerAddressManagerBehaviourMode"/> for the different modes and their explanations.</summary>
        </member>
        <member name="F:Blockcore.P2P.PeerAddressManagerBehaviour.peerAddressManager">
            <summary>Peer address manager instance, see <see cref="T:Blockcore.P2P.IPeerAddressManager"/>.</summary>
        </member>
        <member name="F:Blockcore.P2P.PeerAddressManagerBehaviour.MaxAddressesPerAddrPayload">
            <summary>The maximum amount of addresses per addr payload. </summary>
            <remarks><see cref="!:https://en.bitcoin.it/wiki/Protocol_documentation#addr"/>.</remarks>
        </member>
        <member name="F:Blockcore.P2P.PeerAddressManagerBehaviour.addrPayloadSent">
            <summary>Flag to make sure <see cref="T:Blockcore.P2P.Protocol.Payloads.GetAddrPayload"/> is only sent once.</summary>
            TODO how does it help against peer reconnecting to reset the flag?
        </member>
        <member name="T:Blockcore.P2P.PeerAddressManagerBehaviourMode">
            <summary>
            Specifies how messages related to network peer discovery are handled.
            </summary>
        </member>
        <member name="F:Blockcore.P2P.PeerAddressManagerBehaviourMode.None">
            <summary>Do not advertise nor discover new peers.</summary>
        </member>
        <member name="F:Blockcore.P2P.PeerAddressManagerBehaviourMode.Advertise">
            <summary>Only advertise known peers.</summary>
        </member>
        <member name="F:Blockcore.P2P.PeerAddressManagerBehaviourMode.Discover">
            <summary>Only discover peers.</summary>
        </member>
        <member name="F:Blockcore.P2P.PeerAddressManagerBehaviourMode.AdvertiseDiscover">
            <summary>Advertise known peer and discover peer.</summary>
        </member>
        <member name="T:Blockcore.P2P.IPeerConnector">
            <summary>Contract for <see cref="T:Blockcore.P2P.PeerConnector"/>.</summary>
        </member>
        <member name="P:Blockcore.P2P.IPeerConnector.ConnectorPeers">
            <summary>The collection of peers the connector is currently connected to.</summary>
        </member>
        <member name="M:Blockcore.P2P.IPeerConnector.Initialize(Blockcore.Connection.IConnectionManager)">
            <summary>Peer connector initialization as called by the <see cref="T:Blockcore.Connection.ConnectionManager"/>.</summary>
        </member>
        <member name="P:Blockcore.P2P.IPeerConnector.MaxOutboundConnections">
            <summary>The maximum amount of peers the node can connect to (defaults to 8).</summary>
        </member>
        <member name="P:Blockcore.P2P.IPeerConnector.Requirements">
            <summary>Specification of requirements the <see cref="T:Blockcore.P2P.PeerConnector"/> has when connecting to other peers.</summary>
        </member>
        <member name="M:Blockcore.P2P.IPeerConnector.StartConnectAsync">
            <summary>
            Starts an asynchronous loop that connects to peers in one second intervals.
            <para>
            If the maximum amount of connections has been reached (<see cref="P:Blockcore.P2P.IPeerConnector.MaxOutboundConnections"/>), the action gets skipped.
            </para>
            </summary>
        </member>
        <member name="T:Blockcore.P2P.PeerConnector">
            <summary>
            Connects to peers asynchronously.
            </summary>
        </member>
        <member name="F:Blockcore.P2P.PeerConnector.asyncLoop">
            <summary>The async loop we need to wait upon before we can dispose of this connector.</summary>
        </member>
        <member name="F:Blockcore.P2P.PeerConnector.asyncProvider">
            <summary>Factory for creating background async loop tasks.</summary>
        </member>
        <member name="F:Blockcore.P2P.PeerConnector.dateTimeProvider">
            <summary>Provider of time functions.</summary>
        </member>
        <member name="P:Blockcore.P2P.PeerConnector.ConnectionManager">
            <summary>
            Collection of connected peers that is managed by the <see cref="T:Blockcore.Connection.ConnectionManager"/>.
            </summary>
        </member>
        <member name="P:Blockcore.P2P.PeerConnector.ConnectorPeers">
            <inheritdoc/>
        </member>
        <member name="P:Blockcore.P2P.PeerConnector.CurrentParameters">
            <summary>The parameters cloned from the connection manager.</summary>
        </member>
        <member name="F:Blockcore.P2P.PeerConnector.loggerFactory">
            <summary>Logger factory to create loggers.</summary>
        </member>
        <member name="F:Blockcore.P2P.PeerConnector.logger">
            <summary>Instance logger.</summary>
        </member>
        <member name="P:Blockcore.P2P.PeerConnector.MaxOutboundConnections">
            <inheritdoc/>
        </member>
        <member name="P:Blockcore.P2P.PeerConnector.NodeLifetime">
            <summary>Global application life cycle control - triggers when application shuts down.</summary>
        </member>
        <member name="P:Blockcore.P2P.PeerConnector.ConnectionSettings">
            <summary>User defined connection settings.</summary>
        </member>
        <member name="F:Blockcore.P2P.PeerConnector.network">
            <summary>The network the node is running on.</summary>
        </member>
        <member name="P:Blockcore.P2P.PeerConnector.PeerAddressManager">
            <summary>Peer address manager instance, see <see cref="T:Blockcore.P2P.IPeerAddressManager"/>.</summary>
        </member>
        <member name="F:Blockcore.P2P.PeerConnector.selfEndpointTracker">
            <summary>Tracker for endpoints known to be self.</summary>
        </member>
        <member name="F:Blockcore.P2P.PeerConnector.networkPeerFactory">
            <summary>Factory for creating P2P network peers.</summary>
        </member>
        <member name="P:Blockcore.P2P.PeerConnector.Requirements">
            <inheritdoc/>
        </member>
        <member name="F:Blockcore.P2P.PeerConnector.connectionInterval">
            <summary>Default time interval between making a connection attempt.</summary>
        </member>
        <member name="F:Blockcore.P2P.PeerConnector.networkPeerDisposer">
            <summary>Maintains a list of connected peers and ensures their proper disposal.</summary>
        </member>
        <member name="M:Blockcore.P2P.PeerConnector.#ctor(Blockcore.AsyncWork.IAsyncProvider,Blockcore.Utilities.IDateTimeProvider,Microsoft.Extensions.Logging.ILoggerFactory,Blockcore.Networks.Network,Blockcore.P2P.Peer.INetworkPeerFactory,Blockcore.Utilities.INodeLifetime,Blockcore.Configuration.NodeSettings,Blockcore.Configuration.Settings.ConnectionManagerSettings,Blockcore.P2P.IPeerAddressManager,Blockcore.P2P.ISelfEndpointTracker)">
            <summary>Constructor for dependency injection.</summary>
        </member>
        <member name="M:Blockcore.P2P.PeerConnector.Initialize(Blockcore.Connection.IConnectionManager)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.PeerConnector.AddPeer(Blockcore.P2P.Peer.INetworkPeer)">
            <summary>
            Adds a peer to the <see cref="P:Blockcore.P2P.PeerConnector.ConnectorPeers"/>.
            <para>
            This will only happen if the peer successfully handshaked with another.
            </para>
            </summary>
            <param name="peer">Peer to be added.</param>
        </member>
        <member name="M:Blockcore.P2P.PeerConnector.RemovePeer(Blockcore.P2P.Peer.INetworkPeer)">
            <summary>
            Removes a given peer from the <see cref="P:Blockcore.P2P.PeerConnector.ConnectorPeers"/>.
            <para>
            This will happen if the peer state changed to "disconnecting", "failed" or "offline".
            </para>
            </summary>
            <param name="peer">Peer to be removed.</param>
        </member>
        <member name="P:Blockcore.P2P.PeerConnector.CanStartConnect">
            <summary>Determines whether or not a connector can be started.</summary>
        </member>
        <member name="M:Blockcore.P2P.PeerConnector.OnInitialize">
            <summary>Initialization logic specific to each concrete implementation of this class.</summary>
        </member>
        <member name="M:Blockcore.P2P.PeerConnector.OnStartConnect">
            <summary>Start up logic specific to each concrete implementation of this class.</summary>
        </member>
        <member name="M:Blockcore.P2P.PeerConnector.OnConnectAsync">
            <summary>Connect logic specific to each concrete implementation of this class.</summary>
        </member>
        <member name="M:Blockcore.P2P.PeerConnector.IsPeerConnected(System.Net.IPEndPoint)">
            <summary>
            <c>true</c> if the peer is already connected.
            </summary>
            <param name="ipEndpoint">The endpoint to check.</param>
        </member>
        <member name="M:Blockcore.P2P.PeerConnector.StartConnectAsync">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.PeerConnector.ConnectAsync(Blockcore.P2P.PeerAddress)">
            <summary>Attempts to connect to a random peer.</summary>
        </member>
        <member name="M:Blockcore.P2P.PeerConnector.CalculateConnectionInterval">
            <summary>
            Determines how often the connector should try and connect to an address from it's list.
            </summary>
        </member>
        <member name="M:Blockcore.P2P.PeerConnector.OnPeerDisposed(Blockcore.P2P.Peer.INetworkPeer)">
            <summary>
            Callback that is called before the peer is disposed.
            </summary>
            <param name="peer">Peer that is being disposed.</param>
        </member>
        <member name="M:Blockcore.P2P.PeerConnector.Dispose">
            <inheritdoc/>
        </member>
        <member name="T:Blockcore.P2P.PeerConnectorAddNode">
            <summary>
            The connector used to connect to peers specified with the -addnode argument
            </summary>
        </member>
        <member name="M:Blockcore.P2P.PeerConnectorAddNode.OnInitialize">
            <inheritdoc/>
        </member>
        <member name="P:Blockcore.P2P.PeerConnectorAddNode.CanStartConnect">
            <summary>This connector is always started.</summary>
        </member>
        <member name="M:Blockcore.P2P.PeerConnectorAddNode.OnStartConnect">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.PeerConnectorAddNode.CalculateConnectionInterval">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.PeerConnectorAddNode.OnConnectAsync">
            <summary>
            Only connect to nodes as specified in the -addnode arg.
            </summary>
        </member>
        <member name="T:Blockcore.P2P.PeerConnectorConnectNode">
            <summary>
            The connector used to connect to peers specified with the -connect argument
            </summary>
        </member>
        <member name="M:Blockcore.P2P.PeerConnectorConnectNode.OnInitialize">
            <inheritdoc/>
        </member>
        <member name="P:Blockcore.P2P.PeerConnectorConnectNode.CanStartConnect">
            <summary>This connector is only started if there are peers in the -connect args.</summary>
        </member>
        <member name="M:Blockcore.P2P.PeerConnectorConnectNode.OnStartConnect">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.PeerConnectorConnectNode.CalculateConnectionInterval">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.PeerConnectorConnectNode.OnConnectAsync">
            <summary>
            Only connect to nodes as specified in the -connect node arg.
            </summary>
        </member>
        <member name="T:Blockcore.P2P.PeerConnectorDiscovery">
            <summary>
            The connector used to connect to peers added via peer discovery.
            </summary>
        </member>
        <member name="F:Blockcore.P2P.PeerConnectorDiscovery.MaximumPeerSelectionAttempts">
            <summary>Maximum peer selection attempts.</summary>
        </member>
        <member name="M:Blockcore.P2P.PeerConnectorDiscovery.OnInitialize">
            <inheritdoc/>
        </member>
        <member name="P:Blockcore.P2P.PeerConnectorDiscovery.CanStartConnect">
            <summary>This connector is only started if there are NO peers in the -connect args.</summary>
        </member>
        <member name="M:Blockcore.P2P.PeerConnectorDiscovery.OnStartConnect">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.PeerConnectorDiscovery.OnConnectAsync">
            <inheritdoc/>
        </member>
        <member name="T:Blockcore.P2P.IPeerDiscovery">
            <summary>
            Contract for <see cref="T:Blockcore.P2P.PeerDiscovery"/>.
            </summary>
        </member>
        <member name="M:Blockcore.P2P.IPeerDiscovery.DiscoverPeers(Blockcore.Connection.IConnectionManager)">
            <summary>
            Starts the peer discovery process.
            </summary>
        </member>
        <member name="T:Blockcore.P2P.PeerDiscovery">
            <summary>Async loop that discovers new peers to connect to.</summary>
        </member>
        <member name="F:Blockcore.P2P.PeerDiscovery.discoverFromPeersLoop">
            <summary>The async loop for performing discovery on actual peers. We need to wait upon it before we can shut down this connector.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Blockcore.P2P.PeerDiscovery.discoverFromDnsSeedsLoop" -->
        <member name="F:Blockcore.P2P.PeerDiscovery.asyncProvider">
            <summary>Factory for creating background async loop tasks.</summary>
        </member>
        <member name="F:Blockcore.P2P.PeerDiscovery.currentParameters">
            <summary>The parameters cloned from the connection manager.</summary>
        </member>
        <member name="F:Blockcore.P2P.PeerDiscovery.logger">
            <summary>Instance logger.</summary>
        </member>
        <member name="F:Blockcore.P2P.PeerDiscovery.loggerFactory">
            <summary>Logger factory to create loggers.</summary>
        </member>
        <member name="F:Blockcore.P2P.PeerDiscovery.nodeLifetime">
            <summary>Global application life cycle control - triggers when application shuts down.</summary>
        </member>
        <member name="F:Blockcore.P2P.PeerDiscovery.nodeSettings">
            <summary>User defined node settings.</summary>
        </member>
        <member name="F:Blockcore.P2P.PeerDiscovery.peerAddressManager">
            <summary>Peer address manager instance, see <see cref="T:Blockcore.P2P.IPeerAddressManager"/>.</summary>
        </member>
        <member name="F:Blockcore.P2P.PeerDiscovery.network">
            <summary>The network the node is running on.</summary>
        </member>
        <member name="F:Blockcore.P2P.PeerDiscovery.networkPeerFactory">
            <summary>Factory for creating P2P network peers.</summary>
        </member>
        <member name="M:Blockcore.P2P.PeerDiscovery.DiscoverPeers(Blockcore.Connection.IConnectionManager)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.PeerDiscovery.DiscoverFromDnsSeedsAsync">
            <summary>
            See <see cref="M:Blockcore.P2P.PeerDiscovery.DiscoverPeers(Blockcore.Connection.IConnectionManager)"/>. This loop deals with discovery from DNS seeds and seed nodes as opposed to peers.
            </summary>
        </member>
        <member name="M:Blockcore.P2P.PeerDiscovery.DiscoverPeersAsync">
            <summary>
            See <see cref="M:Blockcore.P2P.PeerDiscovery.DiscoverPeers(Blockcore.Connection.IConnectionManager)"/>. This loop deals with discovery from peers as opposed to DNS seeds and seed nodes.
            </summary>
        </member>
        <member name="M:Blockcore.P2P.PeerDiscovery.AddDNSSeedNodes(System.Collections.Generic.List{System.Net.IPEndPoint})">
            <summary>
            Add peers to the address manager from the network's DNS seed nodes.
            </summary>
        </member>
        <member name="M:Blockcore.P2P.PeerDiscovery.AddSeedNodes(System.Collections.Generic.List{System.Net.IPEndPoint})">
            <summary>
            Add peers to the address manager from the network's seed nodes.
            </summary>
        </member>
        <member name="M:Blockcore.P2P.PeerDiscovery.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.P2P.IPeerSelector">
            <summary>
            Contract for <see cref="T:Blockcore.P2P.PeerSelector"/>.
            </summary>
        </member>
        <member name="M:Blockcore.P2P.IPeerSelector.SelectPeer">
            <summary>
            Selects a random peer, via a selection algorithm, from the address
            manager to connect to.
            </summary>
        </member>
        <member name="M:Blockcore.P2P.IPeerSelector.SelectPeersForDiscovery(System.Int32)">
            <summary>
            Select a random set of peers from the address manager for peer discovery.
            </summary>
            <param name="peerCount">The amount of peers to return.</param>
        </member>
        <member name="M:Blockcore.P2P.IPeerSelector.SelectPeersForGetAddrPayload(System.Int32)">
            <summary>
            Select preferred peers from the address manager for sending
            via address payload.
            </summary>
            <param name="peerCount">The amount of peers to return.</param>
        </member>
        <member name="M:Blockcore.P2P.IPeerSelector.Attempted">
            <summary>
            Return peers which have had connection attempts, but none successful.
            <para>
            The result filters out peers which satisfies the above condition within the
            last 60 seconds and that has had more than 10 failed attempts.
            </para>
            </summary>
        </member>
        <member name="M:Blockcore.P2P.IPeerSelector.Connected(System.Int32)">
            <summary>
            Return peers which have had successful connection attempts.
            <para>
            The result filters out peers which satisfies the above condition within the
            last 60 seconds.
            </para>
            </summary>
            <param name="throttlePeriodSeconds">Filter results that connected within this time frame.</param>
        </member>
        <member name="M:Blockcore.P2P.IPeerSelector.NotBanned">
            <summary>Returns peers that are not banned.</summary>
        </member>
        <member name="M:Blockcore.P2P.IPeerSelector.Fresh">
            <summary>
            Return peers which have never had connection attempts.
            </summary>
        </member>
        <member name="M:Blockcore.P2P.IPeerSelector.Handshaked(System.Int32)">
            <summary>
            Return peers where a successful connection and handshake was achieved.
            <para>
            The result filters out peers which satisfies the above condition within the
            last 60 seconds.
            </para>
            </summary>
            <param name="throttlePeriodSeconds">Filter results that hand shaked within this time frame.</param>
        </member>
        <member name="M:Blockcore.P2P.IPeerSelector.FilterBadHandshakedPeers(System.Collections.Generic.IEnumerable{Blockcore.P2P.PeerAddress})">
            <summary>
            <para>
            Filter peers by handshake failures.
            </para>
            </summary>
        </member>
        <member name="M:Blockcore.P2P.IPeerSelector.HasAllPeersReachedConnectionThreshold">
            <summary>Determines whether all not banned peers reached connection attempts threshold.</summary>
        </member>
        <member name="M:Blockcore.P2P.IPeerSelector.ResetConnectionAttemptsOnNotBannedPeers">
            <summary>Resets connection attempts count for all not banned peers.</summary>
        </member>
        <member name="F:Blockcore.P2P.PeerSelector.dateTimeProvider">
            <summary>Provider of time functions.</summary>
        </member>
        <member name="F:Blockcore.P2P.PeerSelector.DiscoveryThresholdHours">
            <summary>The amount of hours we should wait before we try and discover from a peer again.</summary>
        </member>
        <member name="F:Blockcore.P2P.PeerSelector.loggerFactory">
            <summary>Logger factory to create loggers.</summary>
        </member>
        <member name="F:Blockcore.P2P.PeerSelector.logger">
            <summary>Instance logger.</summary>
        </member>
        <member name="F:Blockcore.P2P.PeerSelector.peerAddresses">
            <summary>
            The address manager instance that holds the peer list to be queried.
            </summary>
        </member>
        <member name="F:Blockcore.P2P.PeerSelector.random">
            <summary>Random number generator used when selecting and ordering peers.</summary>
        </member>
        <member name="F:Blockcore.P2P.PeerSelector.selfEndpointTracker">
            <summary>Keeps track of and allows querying whether an IPEndoint is itself.</summary>
        </member>
        <member name="M:Blockcore.P2P.PeerSelector.#ctor(Blockcore.Utilities.IDateTimeProvider,Microsoft.Extensions.Logging.ILoggerFactory,System.Collections.Concurrent.ConcurrentDictionary{System.Net.IPEndPoint,Blockcore.P2P.PeerAddress},Blockcore.P2P.ISelfEndpointTracker)">
            <summary>
            Constructor for the peer selector.
            </summary>
            <param name="dateTimeProvider">Provider of datetime.</param>
            <param name="loggerFactory">Logger factory.</param>
            <param name="peerAddresses">The collection of peer address as managed by the peer address manager.</param>
            <param name="selfEndpointTracker">Self endpoint tracker.</param>
        </member>
        <member name="M:Blockcore.P2P.PeerSelector.SelectPeer">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.PeerSelector.SelectPreferredPeers">
            <summary>
            Filtering logic for selecting peers to connect to via the <see cref="T:Blockcore.P2P.PeerConnector"/> classes.
            </summary>
        </member>
        <member name="M:Blockcore.P2P.PeerSelector.HasAllPeersReachedConnectionThreshold">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.PeerSelector.ResetConnectionAttemptsOnNotBannedPeers">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.PeerSelector.SelectPeersForDiscovery(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.PeerSelector.SelectPeersForGetAddrPayload(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.PeerSelector.Random(System.Collections.Generic.IEnumerable{Blockcore.P2P.PeerAddress})">
            <summary>Return a random peer from a given set of peers.</summary>
        </member>
        <member name="M:Blockcore.P2P.PeerSelector.Attempted">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.PeerSelector.FilterBadHandshakedPeers(System.Collections.Generic.IEnumerable{Blockcore.P2P.PeerAddress})">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.PeerSelector.Connected(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.PeerSelector.Fresh">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.PeerSelector.Handshaked(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.PeerSelector.IsBanned(Blockcore.P2P.PeerAddress)">
            <summary>
            <c>True</c> if <see cref="P:Blockcore.P2P.PeerAddress.BanUntil"/> is in the future.
            </summary>
        </member>
        <member name="T:Blockcore.P2P.Peer.INetworkPeer">
            <summary>
            Represents a counterparty of the node on the network. This is usually another node, but it can be
            a wallet, an analytical robot, or any other network client or server that understands the protocol.
            <para>The network peer is connected either inbound, if it was the counterparty that established
            the connection to our node's listener, or outbound, if our node was the one connecting to a remote server.
            </para>
            </summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.INetworkPeer.State">
            <summary>State of the network connection to the peer.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.INetworkPeer.RemoteSocketEndpoint">
            <summary>IP address and port of the connected peer.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.INetworkPeer.RemoteSocketAddress">
            <summary>IP address part of <see cref="P:Blockcore.P2P.Peer.INetworkPeer.RemoteSocketEndpoint"/>.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.INetworkPeer.RemoteSocketPort">
            <summary>Port part of <see cref="P:Blockcore.P2P.Peer.INetworkPeer.RemoteSocketEndpoint"/>.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.INetworkPeer.Inbound">
            <summary><c>true</c> if the peer connected to the node, <c>false</c> if the node connected to the peer.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.INetworkPeer.Behaviors">
            <summary>List of node's modules attached to the peer to receive notifications about various events related to the peer.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.INetworkPeer.PeerEndPoint">
            <summary>IP address and port on the side of the peer.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.INetworkPeer.TimeOffset">
            <summary>Difference between the local clock and the clock that peer claims, or <c>null</c> if this information has not been initialized yet.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.INetworkPeer.Connection">
            <summary>Component representing the network connection to the peer that is responsible for sending and receiving messages.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.INetworkPeer.Counter">
            <summary>Statistics about the number of bytes transferred from and to the peer.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.INetworkPeer.Version">
            <summary>
            The negotiated protocol version (minimum of supported version between <see cref="P:Blockcore.P2P.Peer.INetworkPeer.MyVersion"/> and the <see cref="P:Blockcore.P2P.Peer.INetworkPeer.PeerVersion"/>).
            </summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.INetworkPeer.IsConnected">
            <summary><c>true</c> if the connection to the peer is considered active, <c>false</c> otherwise, including any case of error.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.INetworkPeer.MyVersion">
            <summary>Node's version message payload that is sent to the peer.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.INetworkPeer.PeerVersion">
            <summary>Version message payload received from the peer.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.INetworkPeer.SupportedTransactionOptions">
            <summary>Transaction options supported by the peer.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.INetworkPeer.DisconnectReason">
            <summary>When a peer is disconnected this is set to human readable information about why it happened.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.INetworkPeer.Network">
            <summary>Specification of the network the node runs on - regtest/testnet/mainnet.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.INetworkPeer.StateChanged">
            <summary>Event that is triggered when the peer's network state is changed.</summary>
            <remarks>Do not dispose the peer from this callback.</remarks>
        </member>
        <member name="P:Blockcore.P2P.Peer.INetworkPeer.MessageReceived">
            <summary>Event that is triggered when a new message is received from a network peer.</summary>
            <remarks>Do not dispose the peer from this callback.</remarks>
        </member>
        <member name="P:Blockcore.P2P.Peer.INetworkPeer.ConnectionParameters">
            <summary>Various settings and requirements related to how the connections with peers are going to be established.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.INetworkPeer.MessageProducer">
            <summary>Queue of the connections' incoming messages distributed to message consumers.</summary>
        </member>
        <member name="M:Blockcore.P2P.Peer.INetworkPeer.ConnectAsync(System.Threading.CancellationToken)">
            <summary>
            Connects the node to an outbound peer using already initialized information about the peer and starts receiving messages in a separate task.
            </summary>
            <param name="cancellation">Cancellation that allows aborting establishing the connection with the peer.</param>
            <exception cref="T:System.OperationCanceledException">Thrown when the cancellation token has been cancelled.</exception>
        </member>
        <member name="M:Blockcore.P2P.Peer.INetworkPeer.SendMessage(Blockcore.P2P.Protocol.Payloads.Payload)">
            <summary>
            Send a message by putting it in a send queue.
            </summary>
            <param name="payload">The payload to send.</param>
            <exception cref="T:System.OperationCanceledException">Thrown when the peer has been disconnected or the cancellation token has been cancelled.</exception>
        </member>
        <member name="M:Blockcore.P2P.Peer.INetworkPeer.SendMessageAsync(Blockcore.P2P.Protocol.Payloads.Payload,System.Threading.CancellationToken)">
            <summary>
            Send a message to the peer asynchronously.
            </summary>
            <param name="payload">The payload to send.</param>
            <param name="cancellation">Cancellation token that allows aborting the sending operation.</param>
            <exception cref="T:System.OperationCanceledException">Thrown when the peer has been disconnected or the cancellation token has been cancelled.</exception>
        </member>
        <member name="M:Blockcore.P2P.Peer.INetworkPeer.VersionHandshakeAsync(System.Threading.CancellationToken)">
            <summary>
            Exchanges "version" and "verack" messages with the peer.
            <para>Both parties have to send their "version" messages to the other party
            as well as to acknowledge that they are happy with the other party's "version" information.</para>
            </summary>
            <param name="cancellationToken">Cancellation that allows aborting the operation at any stage.</param>
            <exception cref="T:Blockcore.NBitcoin.Protocol.ProtocolException">Thrown when the peer rejected our "version" message.</exception>
            <exception cref="T:System.OperationCanceledException">Thrown during the shutdown or when the peer disconnects.</exception>
        </member>
        <member name="M:Blockcore.P2P.Peer.INetworkPeer.VersionHandshakeAsync(Blockcore.P2P.Peer.NetworkPeerRequirement,System.Threading.CancellationToken)">
            <summary>
            Exchanges "version" and "verack" messages with the peer.
            <para>Both parties have to send their "version" messages to the other party
            as well as to acknowledge that they are happy with the other party's "version" information.</para>
            </summary>
            <param name="requirements">Protocol requirement for network peers the node wants to be connected to.</param>
            <param name="cancellationToken">Cancellation that allows aborting the operation at any stage.</param>
            <exception cref="T:Blockcore.NBitcoin.Protocol.ProtocolException">Thrown when the peer rejected our "version" message.</exception>
            <exception cref="T:System.OperationCanceledException">Thrown during the shutdown or when the peer disconnects.</exception>
        </member>
        <member name="M:Blockcore.P2P.Peer.INetworkPeer.RespondToHandShakeAsync(System.Threading.CancellationToken)">
            <summary>
            Sends "version" message to the peer and waits for the response in form of "verack" or "reject" message.
            </summary>
            <param name="cancellationToken">Cancellation that allows aborting the operation at any stage.</param>
            <exception cref="T:Blockcore.NBitcoin.Protocol.ProtocolException">Thrown when the peer rejected our "version" message.</exception>
            <exception cref="T:System.OperationCanceledException">Thrown during the shutdown or when the peer disconnects.</exception>
        </member>
        <member name="M:Blockcore.P2P.Peer.INetworkPeer.Disconnect(System.String,System.Exception)">
            <summary>
            Disconnects the peer and cleans up.
            </summary>
            <param name="reason">Human readable reason for disconnecting.</param>
            <param name="exception">Exception because of which the disconnection happened, or <c>null</c> if there were no exception.</param>
        </member>
        <member name="M:Blockcore.P2P.Peer.INetworkPeer.AddSupportedOptions(Blockcore.P2P.Protocol.InventoryType)">
            <summary>
            Add supported option to the inventory type.
            </summary>
            <param name="inventoryType">Inventory type to extend.</param>
            <returns>Inventory type possibly extended with new options.</returns>
        </member>
        <member name="M:Blockcore.P2P.Peer.INetworkPeer.Behavior``1">
            <summary>
            Finds all behaviors of a specific behavior type among the peer's behaviors.
            </summary>
            <typeparam name="T">Type of the behavior to find.</typeparam>
            <returns>Collection of behaviors of specific type.</returns>
        </member>
        <member name="M:Blockcore.P2P.Peer.INetworkPeer.MatchRemoteIPAddress(System.Net.IPAddress,System.Nullable{System.Int32})">
            <summary>
            Determines if this peer matches the ip and optional port.
            </summary>
            <param name="ip">The ip to match.</param>
            <param name="port">The port to match (optional).</param>
            <returns><c>True</c> if the endpoint matches and <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Blockcore.P2P.Peer.NetworkPeerState">
            <summary>
            State of the network connection to a peer.
            </summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerState.Created">
            <summary>Initial state of an outbound peer.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerState.Connected">
            <summary>Network connection with the peer has been established.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerState.HandShaked">
            <summary>The node and the peer exchanged version information.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerState.Disconnecting">
            <summary>Process of disconnecting the peer has been initiated.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerState.Offline">
            <summary>Shutdown has been initiated, the node went offline.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerState.Failed">
            <summary>An error occurred during a network operation.</summary>
        </member>
        <member name="T:Blockcore.P2P.Peer.NetworkPeerDisconnectReason">
            <summary>
            Explanation of why a peer was disconnected.
            </summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeerDisconnectReason.Reason">
            <summary>Human readable reason for disconnecting.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeerDisconnectReason.Exception">
            <summary>Exception because of which the disconnection happened, or <c>null</c> if there were no exceptions.</summary>
        </member>
        <member name="T:Blockcore.P2P.Peer.NetworkPeerRequirement">
            <summary>
            Protocol requirement for network peers the node wants to be connected to.
            </summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeerRequirement.MinVersion">
            <summary>Minimal protocol version that the peer must support or <c>null</c> if there is no requirement for minimal protocol version.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeerRequirement.RequiredServices">
            <summary>Specification of network services that the peer must provide.</summary>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeerRequirement.Check(Blockcore.P2P.Protocol.Payloads.VersionPayload,System.Boolean,System.String@)">
            <summary>
            Checks a version payload from a peer against the requirements.
            </summary>
            <param name="version">Version payload to check.</param>
            <param name="inbound">Set to <c>true</c> if this is an inbound connection and <c>false</c> otherwise.</param>
            <param name="reason">The reason the check failed.</param>
            <returns><c>true</c> if the version payload satisfies the protocol requirements, <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Blockcore.P2P.Peer.NetworkPeer">
            <inheritdoc/>
            <remarks>
            All instances of this object must be disposed or disconnected. <see cref="M:Blockcore.P2P.Peer.NetworkPeer.Disconnect(System.String,System.Exception)"/> and disposing methods
            have the same functionality and the disconnecting method is provided only for better readability of the code.
            <para>It is safe to try to disconnect or dispose this object multiple times, only the first call will be processed.</para>
            </remarks>
        </member>
        <member name="T:Blockcore.P2P.Peer.NetworkPeer.DisconnectedExecutionAsyncContext">
            <summary>
            Execution context holding information about the current status of the execution
            in order to recognize if <see cref="F:Blockcore.P2P.Peer.NetworkPeer.onDisconnected"/> callback was requested from the same async context.
            </summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeer.DisconnectedExecutionAsyncContext.DisconnectCallbackRequested">
            <summary>
            Set to <c>true</c> if <see cref="F:Blockcore.P2P.Peer.NetworkPeer.onDisconnected"/> was
            called from within the current async context, set to <c>false</c> otherwise.
            </summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeer.selfEndpointTracker">
            <summary>Tracker for endpoints known to be self. </summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeer.logger">
            <summary>Instance logger.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeer.dateTimeProvider">
            <summary>Provider of time functions.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeer.State">
            <inheritdoc/>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeer.StateTransitionTable">
            <summary>Table of valid transitions between peer states.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeer.RemoteSocketEndpoint">
            <inheritdoc/>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeer.RemoteSocketAddress">
            <inheritdoc/>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeer.RemoteSocketPort">
            <inheritdoc/>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeer.Inbound">
            <inheritdoc/>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeer.Behaviors">
            <inheritdoc/>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeer.PeerEndPoint">
            <inheritdoc/>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeer.TimeOffset">
            <inheritdoc/>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeer.Connection">
            <inheritdoc/>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeer.counter">
            <summary>Statistics about the number of bytes transferred from and to the peer.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeer.Counter">
            <inheritdoc/>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeer.Version">
            <inheritdoc/>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeer.IsConnected">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeer.MatchRemoteIPAddress(System.Net.IPAddress,System.Nullable{System.Int32})">
            <inheritdoc />
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeer.advertize">
            <summary><c>true</c> to advertise "addr" message with our external endpoint to the peer when passing to <see cref="F:Blockcore.P2P.Peer.NetworkPeerState.HandShaked"/> state.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeer.MyVersion">
            <inheritdoc/>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeer.PeerVersion">
            <inheritdoc/>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeer.disconnected">
            <summary>Set to <c>1</c> if the peer disconnection has been initiated, <c>0</c> otherwise.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeer.disposed">
            <summary>Set to <c>1</c> if the peer disposal has been initiated, <c>0</c> otherwise.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeer.onDisconnectedAsyncContext">
            <summary>
            Async context to allow to recognize whether <see cref="F:Blockcore.P2P.Peer.NetworkPeer.onDisconnected"/> callback execution is scheduled in this async context.
            <para>
            It is not <c>null</c> if one of the following callbacks is in progress: <see cref="P:Blockcore.P2P.Peer.NetworkPeer.StateChanged"/>, <see cref="P:Blockcore.P2P.Peer.NetworkPeer.MessageReceived"/>,
            set to <c>null</c> otherwise.
            </para>
            </summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeer.preferredTransactionOptions">
            <summary>Transaction options we would like.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeer.SupportedTransactionOptions">
            <inheritdoc/>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeer.DisconnectReason">
            <inheritdoc/>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeer.Network">
            <inheritdoc/>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeer.StateChanged">
            <inheritdoc/>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeer.MessageReceived">
            <inheritdoc/>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeer.ConnectionParameters">
            <inheritdoc/>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeer.MessageProducer">
            <inheritdoc/>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeer.onDisconnected">
            <summary>Callback that is invoked when peer has finished disconnecting, or <c>null</c> when no notification after the disconnection is required.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeer.onSendingMessage">
            <summary>Callback that is invoked just before a message is to be sent to a peer, or <c>null</c> when nothing needs to be called.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeer.asyncPayloadsQueue">
            <summary>A queue for sending payload messages to peers.</summary>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeer.#ctor(System.Boolean,System.Net.IPEndPoint,Blockcore.Networks.Network,Blockcore.P2P.Peer.NetworkPeerConnectionParameters,Blockcore.Utilities.IDateTimeProvider,Microsoft.Extensions.Logging.ILoggerFactory,Blockcore.P2P.ISelfEndpointTracker,Blockcore.AsyncWork.IAsyncProvider,System.Action{Blockcore.P2P.Peer.INetworkPeer},System.Action{System.Net.IPEndPoint,Blockcore.P2P.Protocol.Payloads.Payload})">
            <summary>
            Initializes parts of the object that are common for both inbound and outbound peers.
            </summary>
            <param name="inbound"><c>true</c> for inbound peers, <c>false</c> for outbound peers.</param>
            <param name="peerEndPoint">IP address and port on the side of the peer.</param>
            <param name="network">Specification of the network the node runs on - regtest/testnet/mainnet.</param>
            <param name="parameters">Various settings and requirements related to how the connections with peers are going to be established, or <c>null</c> to use default parameters.</param>
            <param name="dateTimeProvider">Provider of time functions.</param>
            <param name="loggerFactory">Factory for creating loggers.</param>
            <param name="selfEndpointTracker">Tracker for endpoints known to be self.</param>
            <param name="onDisconnected">Callback that is invoked when peer has finished disconnecting, or <c>null</c> when no notification after the disconnection is required.</param>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeer.#ctor(System.Net.IPEndPoint,Blockcore.Networks.Network,Blockcore.P2P.Peer.NetworkPeerConnectionParameters,Blockcore.P2P.Peer.INetworkPeerFactory,Blockcore.Utilities.IDateTimeProvider,Microsoft.Extensions.Logging.ILoggerFactory,Blockcore.P2P.ISelfEndpointTracker,Blockcore.AsyncWork.IAsyncProvider,System.Action{Blockcore.P2P.Peer.INetworkPeer},System.Action{System.Net.IPEndPoint,Blockcore.P2P.Protocol.Payloads.Payload})">
            <summary>
            Initializes an instance of the object for outbound network peers.
            </summary>
            <param name="peerEndPoint">IP address and port on the side of the peer.</param>
            <param name="network">Specification of the network the node runs on - regtest/testnet/mainnet.</param>
            <param name="parameters">Various settings and requirements related to how the connections with peers are going to be established, or <c>null</c> to use default parameters.</param>
            <param name="networkPeerFactory">Factory for creating P2P network peers.</param>
            <param name="dateTimeProvider">Provider of time functions.</param>
            <param name="loggerFactory">Factory for creating loggers.</param>
            <param name="selfEndpointTracker">Tracker for endpoints known to be self.</param>
            <param name="onDisconnected">Callback that is invoked when peer has finished disconnecting, or <c>null</c> when no notification after the disconnection is required.</param>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeer.#ctor(System.Net.IPEndPoint,Blockcore.Networks.Network,Blockcore.P2P.Peer.NetworkPeerConnectionParameters,System.Net.Sockets.TcpClient,Blockcore.Utilities.IDateTimeProvider,Blockcore.P2P.Peer.INetworkPeerFactory,Microsoft.Extensions.Logging.ILoggerFactory,Blockcore.P2P.ISelfEndpointTracker,Blockcore.AsyncWork.IAsyncProvider,System.Action{Blockcore.P2P.Peer.INetworkPeer},System.Action{System.Net.IPEndPoint,Blockcore.P2P.Protocol.Payloads.Payload})">
            <summary>
            Initializes an instance of the object for inbound network peers with already established connection.
            </summary>
            <param name="peerEndPoint">IP address and port on the side of the peer.</param>
            <param name="network">Specification of the network the node runs on - regtest/testnet/mainnet.</param>
            <param name="parameters">Various settings and requirements related to how the connections with peers are going to be established, or <c>null</c> to use default parameters.</param>
            <param name="client">Already connected network client.</param>
            <param name="dateTimeProvider">Provider of time functions.</param>
            <param name="networkPeerFactory">Factory for creating P2P network peers.</param>
            <param name="loggerFactory">Factory for creating loggers.</param>
            <param name="selfEndpointTracker">Tracker for endpoints known to be self.</param>
            <param name="onDisconnected">Callback that is invoked when peer has finished disconnecting, or <c>null</c> when no notification after the disconnection is required.</param>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeer.SetStateAsync(Blockcore.P2P.Peer.NetworkPeerState)">
            <summary>
            Sets a new network state of the peer.
            </summary>
            <param name="newState">New network state to be set.</param>
            <remarks>This method is not thread safe.</remarks>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeer.ConnectAsync(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeer.OnStateChangedAsync(Blockcore.P2P.Peer.NetworkPeerState)">
            <summary>
            Calls event handlers when the network state of the peer is changed.
            </summary>
            <param name="previous">Previous network state of the peer.</param>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeer.ProcessMessageAsync(Blockcore.P2P.Protocol.IncomingMessage,System.Threading.CancellationToken)">
            <summary>
            Processes an incoming message from the peer and calls subscribed event handlers.
            </summary>
            <param name="message">Message received from the peer.</param>
            <param name="cancellation">Cancellation token to abort message processing.</param>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeer.ProcessVersionMessageAsync(Blockcore.P2P.Protocol.Payloads.VersionPayload,System.Threading.CancellationToken)">
            <summary>
            Processes a "version" message received from a peer.
            </summary>
            <param name="version">Version message received from a peer.</param>
            <param name="cancellation">Cancellation token to abort message processing.</param>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeer.ProcessInitialVersionPayloadAsync(Blockcore.P2P.Protocol.Payloads.VersionPayload,System.Threading.CancellationToken)">
            <summary>
            Processes an initial "version" message received from a peer.
            </summary>
            <param name="version">Version message received from a peer.</param>
            <param name="cancellation">Cancellation token to abort message processing.</param>
            <exception cref="T:System.OperationCanceledException">Thrown if the response to our "version" message is not received on time.</exception>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeer.InitDefaultBehaviors(Blockcore.P2P.Peer.NetworkPeerConnectionParameters)">
            <summary>
            Initializes behaviors from the default template.
            </summary>
            <param name="parameters">Various settings and requirements related to how the connections with peers are going to be established, including the default behaviors template.</param>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeer.SendMessage(Blockcore.P2P.Protocol.Payloads.Payload)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeer.SendMessageHandledAsync(Blockcore.P2P.Protocol.Payloads.Payload,System.Threading.CancellationToken)">
            <summary>
            This is used by the <see cref="F:Blockcore.P2P.Peer.NetworkPeer.asyncPayloadsQueue"/> to send payloads messages to peers under a separate thread.
            If a message is sent inside the state change even and the send fails this could cause a deadlock,
            to avoid that if there is any danger of a deadlock it better to use the SendMessage method and go via the queue.
            </summary>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeer.SendMessageAsync(Blockcore.P2P.Protocol.Payloads.Payload,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeer.VersionHandshakeAsync(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeer.VersionHandshakeAsync(Blockcore.P2P.Peer.NetworkPeerRequirement,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeer.RespondToHandShakeAsync(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeer.Disconnect(System.String,System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeer.ExecuteDisconnectedCallbackWhenSafe">
            <summary>
            Executes <see cref="F:Blockcore.P2P.Peer.NetworkPeer.onDisconnected"/> callback if no callbacks are currently executing in the same async context,
            schedules <see cref="F:Blockcore.P2P.Peer.NetworkPeer.onDisconnected"/> execution after the callback otherwise.
            </summary>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeer.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeer.AddSupportedOptions(Blockcore.P2P.Protocol.InventoryType)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeer.Behavior``1">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.P2P.Peer.IReadOnlyNetworkPeerCollection.FindByIp(System.Net.IPAddress)">
            <summary>
            Returns all connected peers from a given IP address (the port is irrelevant).
            </summary>
            <param name="ip">The IP address to filter on.</param>
            <returns>The set of connected peers that matched the given IP address.</returns>
        </member>
        <member name="T:Blockcore.P2P.Peer.NetworkPeerCollection.NetworkPeerComparer">
            <summary>
            Provides a comparer to specify how peers are compared for equality.
            </summary>
        </member>
        <member name="T:Blockcore.P2P.Peer.NetworkPeerConnection">
            <summary>
            Represents a network connection to a peer. It is responsible for reading incoming messages
            from the peer and sending messages from the node to the peer.
            </summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerConnection.loggerFactory">
            <summary>Logger factory to create loggers.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerConnection.payloadProvider">
            <summary>A provider of network payload messages.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerConnection.asyncProvider">
            <summary>The provider used to create an async loop to listen incoming messages.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerConnection.logger">
            <summary>Instance logger.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerConnection.network">
            <summary>Specification of the network the node runs on - regtest/testnet/mainnet.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerConnection.dateTimeProvider">
            <summary>Provider of time functions.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerConnection.messageListener">
            <summary>Consumer of messages coming from connected clients.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerConnection.messageProducerRegistration">
            <summary>Registration to the message producer of the connected peer.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeerConnection.Id">
            <summary>Unique identifier of a client.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerConnection.tcpClient">
            <summary>Underlaying TCP client.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerConnection.writeLock">
            <summary>Prevents parallel execution of multiple write operations on <see cref="F:Blockcore.P2P.Peer.NetworkPeerConnection.stream"/>.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerConnection.stream">
            <summary>Stream to send and receive messages through established TCP connection.</summary>
            <remarks>Write operations on the stream have to be protected by <see cref="F:Blockcore.P2P.Peer.NetworkPeerConnection.writeLock"/>.</remarks>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeerConnection.RemoteEndPoint">
            <summary>Address of the end point the client is connected to, or <c>null</c> if the client has not connected yet.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerConnection.peer">
            <summary>Network peer this connection connects to.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeerConnection.CancellationSource">
            <summary>Cancellation to be triggered at shutdown to abort all pending operations on the connection.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerConnection.receiveMessageTask">
            <summary>Task responsible for reading incoming messages from the stream.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeerConnection.MessageProducer">
            <summary>Queue of incoming messages distributed to message consumers.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerConnection.disposed">
            <summary>Set to <c>1</c> if the peer disposal has been initiated, <c>0</c> otherwise.</summary>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeerConnection.#ctor(Blockcore.Networks.Network,Blockcore.P2P.Peer.INetworkPeer,System.Net.Sockets.TcpClient,System.Int32,Blockcore.P2P.Protocol.ProcessMessageAsync{Blockcore.P2P.Protocol.IncomingMessage},Blockcore.Utilities.IDateTimeProvider,Microsoft.Extensions.Logging.ILoggerFactory,Blockcore.P2P.Protocol.Payloads.PayloadProvider,Blockcore.AsyncWork.IAsyncProvider)">
            <summary>
            Initializes an instance of the object.
            </summary>
            <param name="network">Specification of the network the node runs on - regtest/testnet/mainnet.</param>
            <param name="peer">Network peer the node is connected to, or will connect to.</param>
            <param name="client">Initialized TCP client, which may or may not be already connected.</param>
            <param name="clientId">Unique identifier of the connection.</param>
            <param name="processMessageAsync">Callback to be called when a new message arrives from the peer.</param>
            <param name="dateTimeProvider">Provider of time functions.</param>
            <param name="loggerFactory">Factory for creating loggers.</param>
            <param name="payloadProvider">A provider of network payload messages.</param>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeerConnection.StartReceiveMessages">
            <summary>
            Starts waiting for incoming messages.
            </summary>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeerConnection.ReceiveMessagesAsync">
            <summary>
            Reads messages from the connection stream.
            </summary>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeerConnection.ConnectAsync(System.Net.IPEndPoint,System.Threading.CancellationToken)">
            <summary>
            Connects the network client to the target server.
            </summary>
            <param name="endPoint">IP address and port to connect to.</param>
            <param name="cancellation">Cancellation token that allows aborting the operation.</param>
            <exception cref="T:System.OperationCanceledException">Thrown when the connection attempt was aborted.</exception>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeerConnection.SendAsync(Blockcore.P2P.Protocol.Payloads.Payload,System.Threading.CancellationToken)">
            <summary>
            Sends message to the connected counterparty.
            </summary>
            <param name="payload">Payload of the message to send.</param>
            <param name="cancellation">Cancellation token that allows aborting the sending operation.</param>
            <exception cref="T:System.OperationCanceledException">Thrown when the peer has been disconnected
            or the cancellation token has been cancelled or another error occurred.</exception>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeerConnection.SendAsync(System.Byte[],System.Threading.CancellationToken)">
            <summary>
            Sends data over the established connection.
            </summary>
            <param name="data">Data to send.</param>
            <param name="cancellation">Cancellation token that allows aborting the operation.</param>
            <exception cref="T:System.OperationCanceledException">Thrown when the connection was terminated or the cancellation token was cancelled.</exception>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeerConnection.ReadMessageAsync(System.UInt32,System.Threading.CancellationToken)">
            <summary>
            Reads raw message in binary form from the connection stream.
            </summary>
            <param name="protocolVersion">Version of the protocol that defines the message format.</param>
            <param name="cancellation">Cancellation token that allows aborting the read operation.</param>
            <returns>Binary message received from the connected counterparty.</returns>
            <exception cref="T:System.OperationCanceledException">Thrown if the operation was cancelled or the end of the stream was reached.</exception>
            <exception cref="T:System.Net.ProtocolViolationException">Thrown if the incoming message is too big.</exception>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeerConnection.ReadMagicAsync(System.Byte[],System.Threading.CancellationToken)">
            <summary>
            Seeks and reads the magic value from the connection stream.
            </summary>
            <param name="magic">Magic value that starts the message.</param>
            <param name="cancellation">Cancellation token that allows aborting the read operation.</param>
            <exception cref="T:System.OperationCanceledException">Thrown if the operation was cancelled or the end of the stream was reached.</exception>
            <remarks>
            Each networkm message starts with the magic value. If the connection stream is in unknown state,
            the next bytes to read might not be the magic. Therefore we read from the stream until we find the magic value.
            </remarks>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeerConnection.ReadBytesAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Reads a specific number of bytes from the connection stream into a buffer.
            </summary>
            <param name="buffer">Buffer to read incoming data to.</param>
            <param name="offset">Position in the buffer where to write the data.</param>
            <param name="bytesToRead">Number of bytes to read.</param>
            <param name="cancellation">Cancellation token that allows aborting the read operation.</param>
            <returns>Binary data received from the connected counterparty.</returns>
            <exception cref="T:System.OperationCanceledException">Thrown if the operation was cancelled or the end of the stream was reached.</exception>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeerConnection.ReadAndParseMessageAsync(System.UInt32,System.Threading.CancellationToken)">
            <summary>
            Reads a raw binary message from the connection stream and formats it to a structured message.
            </summary>
            <param name="protocolVersion">Version of the protocol that defines the message format.</param>
            <param name="cancellation">Cancellation token that allows aborting the read operation.</param>
            <returns>Binary message received from the connected counterparty and the size of the raw message in bytes.</returns>
            <exception cref="T:System.OperationCanceledException">Thrown if the operation was cancelled or the end of the stream was reached.</exception>
            <exception cref="T:System.FormatException">Thrown if the incoming message is too big.</exception>
            <exception cref="T:System.ObjectDisposedException">Thrown if the connection has been disposed.</exception>
            <exception cref="T:System.IO.IOException">Thrown if the I/O operation has been aborted because of either a thread exit or an application request.</exception>
            <remarks>
            TODO: Currently we rely on <see cref="!:Message.ReadNext(System.IO.Stream, Network, ProtocolVersion, CancellationToken, byte[], out PerformanceCounter)"/>
            for parsing the message from binary data. That method need stream to read from, so to achieve that we create a memory stream from our data,
            which is not efficient. This should be improved.
            </remarks>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeerConnection.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeerConnection.Disconnect">
            <summary>
            Closes TCP connection and disposes it's stream.
            </summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeerConnectionParameters.Advertize">
            <summary>Send addr unsollicited message of the AddressFrom peer when passing to Handshaked state.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeerConnectionParameters.IsRelay">
            <summary>If true, the node will receive all incoming transactions if no bloomfilter are set.</summary>
        </member>
        <member name="T:Blockcore.P2P.Peer.NetworkPeerDisposer">
            <summary>Maintains a list of connected peers and ensures their proper disposal.</summary>
            <remarks>
            Each component that creates instances of <see cref="T:Blockcore.P2P.Peer.NetworkPeer"/> should be responsible for disposing it.
            <para>
            Implementing this functionality in such components will lead to having similar code in these components.
            Instead, this class could be used in order to provide such functionality.
            This means that the responsibility for destroying the peer can delegated to this class, which simplifies the
            code of the owning component.
            </para>
            <para>
            When a new peer is created (and the <see cref="M:Blockcore.P2P.Peer.NetworkPeerDisposer.OnPeerDisconnectedHandler(Blockcore.P2P.Peer.INetworkPeer)"/> callback is used as an <see cref="F:Blockcore.P2P.Peer.NetworkPeer.onDisconnected"/> in the constructor)
            by a component that utilizes this class, <see cref="M:Blockcore.P2P.Peer.NetworkPeerDisposer.AddPeer(Blockcore.P2P.Peer.INetworkPeer)"/> should be used to inform  this class about it. Once the peer is added, the owning component no
            longer needs to care about this peer's disposal.
            When a peer disconnects, this class will invoke peer's disposal in a separated task.
            Also when <see cref="M:Blockcore.P2P.Peer.NetworkPeerDisposer.Dispose"/> is called, all connected peers added to this component will be disposed.
            </para>
            </remarks>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerDisposer.logger">
            <summary>Instance logger.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerDisposer.onPeerDisposed">
            <summary>Callback that is called before the peer is disposed.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerDisposer.peersToDispose">
            <summary>Queue of disconnected peers to be disposed.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerDisposer.connectedPeers">
            <summary>Mapping of connected peers by their connection ID.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeerDisposer.ConnectedPeersCount">
            <summary>Gets the connected peers count.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeerDisposer.ConnectedInboundPeersCount">
            <summary>Gets the connected inbound peers count.</summary>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeerDisposer.#ctor(Microsoft.Extensions.Logging.ILoggerFactory,Blockcore.AsyncWork.IAsyncProvider,System.Action{Blockcore.P2P.Peer.INetworkPeer})">
            <summary>
            Initializes a new instance of the <see cref="T:Blockcore.P2P.Peer.NetworkPeerDisposer" /> class.
            </summary>
            <param name="loggerFactory">Factory for creating loggers.</param>
            <param name="onPeerDisposed">Callback that is called before the peer is disposed.</param>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeerDisposer.OnEnqueueAsync(Blockcore.P2P.Peer.INetworkPeer,System.Threading.CancellationToken)">
            <summary>
            Callback that is invoked whenever a new peer is added to the <see cref="F:Blockcore.P2P.Peer.NetworkPeerDisposer.peersToDispose" />.
            </summary>
            <param name="peer">The peer.</param>
            <param name="cancellationToken">Cancellation token.</param>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeerDisposer.OnPeerDisconnectedHandler(Blockcore.P2P.Peer.INetworkPeer)">
            <summary>Handles peer's disconnection.</summary>
            <param name="peer">Peer which disposal should be safely handled.</param>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeerDisposer.AddPeer(Blockcore.P2P.Peer.INetworkPeer)">
            <summary>
            Adds the peer to the collection of connected peers.
            </summary>
            <param name="peer">The peer to add.</param>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeerDisposer.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.P2P.Peer.INetworkPeerFactory">
            <summary>
            Contract for factory for creating P2P network peers.
            </summary>
        </member>
        <member name="M:Blockcore.P2P.Peer.INetworkPeerFactory.CreateNetworkPeer(System.Net.Sockets.TcpClient,Blockcore.P2P.Peer.NetworkPeerConnectionParameters,Blockcore.P2P.Peer.NetworkPeerDisposer)">
            <summary>
            Creates a network peer using already established network connection.
            </summary>
            <param name="client">Already connected network client.</param>
            <param name="parameters">Parameters of the established connection, or <c>null</c> to use default parameters.</param>
            <param name="networkPeerDisposer">Maintains a list of connected peers and ensures their proper disposal. Or <c>null</c> if case disposal should be handled from user code.</param>
            <returns>New network peer that is connected via the established connection.</returns>
        </member>
        <member name="M:Blockcore.P2P.Peer.INetworkPeerFactory.CreateConnectedNetworkPeerAsync(System.String,System.UInt32,System.Boolean,System.Threading.CancellationToken,Blockcore.P2P.Peer.NetworkPeerDisposer)">
            <summary>
            Creates a new network peer which is connected to a specified counterparty.
            </summary>
            <param name="endPoint">Address and port of the counterparty to connect to.</param>
            <param name="myVersion">Version of the protocol that the node supports.</param>
            <param name="isRelay">Whether the remote peer should announce relayed transactions or not. See <see cref="P:Blockcore.P2P.Protocol.Payloads.VersionPayload.Relay"/> for more information.</param>
            <param name="cancellation">Cancallation token that allows to interrupt establishing of the connection.</param>
            <param name="networkPeerDisposer">Maintains a list of connected peers and ensures their proper disposal. Or <c>null</c> if case disposal should be handled from user code.</param>
            <returns>Network peer connected to the specified counterparty.</returns>
        </member>
        <member name="M:Blockcore.P2P.Peer.INetworkPeerFactory.CreateConnectedNetworkPeerAsync(System.Net.IPEndPoint,Blockcore.P2P.Peer.NetworkPeerConnectionParameters,Blockcore.P2P.Peer.NetworkPeerDisposer)">
            <summary>
            Creates a new network peer which is connected to a specified counterparty.
            </summary>
            <param name="peerEndPoint">Address and port of the counterparty to connect to.</param>
            <param name="parameters">Parameters specifying how the connection with the counterparty should be established, or <c>null</c> to use default parameters.</param>
            <param name="networkPeerDisposer">Maintains a list of connected peers and ensures their proper disposal. Or <c>null</c> if case disposal should be handled from user code.</param>
            <returns>Network peer connected to the specified counterparty.</returns>
        </member>
        <member name="M:Blockcore.P2P.Peer.INetworkPeerFactory.CreateNetworkPeerServer(System.Net.IPEndPoint,System.Net.IPEndPoint,System.UInt32)">
            <summary>
            Creates a new network peer server.
            <para>When created, the server is ready to be started, but this method does not start listening.</para>
            </summary>
            <param name="localEndPoint">IP address and port to listen on.</param>
            <param name="externalEndPoint">IP address and port that the server is reachable from the Internet on.</param>
            <param name="version">Version of the network protocol that the server should run.</param>
            <returns>Newly created network peer server, which is ready to be started.</returns>
        </member>
        <member name="M:Blockcore.P2P.Peer.INetworkPeerFactory.CreateNetworkPeerConnection(Blockcore.P2P.Peer.INetworkPeer,System.Net.Sockets.TcpClient,Blockcore.P2P.Protocol.ProcessMessageAsync{Blockcore.P2P.Protocol.IncomingMessage})">
            <summary>
            Creates a new representation of the network connection using TCP client object.
            </summary>
            <param name="peer">Network peer the node is connected to, or will connect to.</param>
            <param name="client">Initialized and possibly connected TCP client to the peer.</param>
            <param name="processMessageAsync">Callback to be called when a new message arrives from the peer.</param>
        </member>
        <member name="M:Blockcore.P2P.Peer.INetworkPeerFactory.RegisterOnSendingMessageCallback(System.Action{System.Net.IPEndPoint,Blockcore.P2P.Protocol.Payloads.Payload})">
            <summary>
            Registers a callback that will be passed to all created peers. It gets called prior to sending messages to the peer.
            </summary>
            <param name="callback">The callback to be used by each peer.</param>
        </member>
        <member name="T:Blockcore.P2P.Peer.NetworkPeerFactory">
            <summary>
            Factory for creating P2P network peers.
            </summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerFactory.loggerFactory">
            <summary>Factory for creating loggers.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerFactory.payloadProvider">
            <summary>A provider of network payload messages.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerFactory.dateTimeProvider">
            <summary>Provider of time functions.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerFactory.network">
            <summary>Specification of the network the node runs on - regtest/testnet/mainnet.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerFactory.lastClientId">
            <summary>Identifier of the last network peer client this factory produced.</summary>
            <remarks>When a new client is created, the ID is incremented so that each client has its own unique ID.</remarks>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerFactory.initialBlockDownloadState">
            <summary>Provider of IBD state.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerFactory.connectionManagerSettings">
            <summary>Configuration related to incoming and outgoing connections.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerFactory.onSendingMessage">
            <summary>Callback that is invoked just before a message is to be sent to a peer, or <c>null</c> when nothing needs to be called.</summary>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeerFactory.#ctor(Blockcore.Networks.Network,Blockcore.Utilities.IDateTimeProvider,Microsoft.Extensions.Logging.ILoggerFactory,Blockcore.P2P.Protocol.Payloads.PayloadProvider,Blockcore.P2P.ISelfEndpointTracker,Blockcore.Interfaces.IInitialBlockDownloadState,Blockcore.Configuration.Settings.ConnectionManagerSettings,Blockcore.AsyncWork.IAsyncProvider,Blockcore.P2P.IPeerAddressManager)">
            <summary>
            Initializes a new instance of the factory.
            </summary>
            <param name="network">Specification of the network the node runs on - regtest/testnet/mainnet.</param>
            <param name="dateTimeProvider">Provider of time functions.</param>
            <param name="loggerFactory">Factory for creating loggers.</param>
            <param name="payloadProvider">A provider of network payload messages.</param>
            <param name="selfEndpointTracker">Tracker for endpoints known to be self.</param>
            <param name="initialBlockDownloadState">Provider of IBD state.</param>
            <param name="connectionManagerSettings">Configuration related to incoming and outgoing connections.</param>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeerFactory.CreateNetworkPeer(System.Net.Sockets.TcpClient,Blockcore.P2P.Peer.NetworkPeerConnectionParameters,Blockcore.P2P.Peer.NetworkPeerDisposer)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeerFactory.CreateConnectedNetworkPeerAsync(System.String,System.UInt32,System.Boolean,System.Threading.CancellationToken,Blockcore.P2P.Peer.NetworkPeerDisposer)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeerFactory.CreateConnectedNetworkPeerAsync(System.Net.IPEndPoint,Blockcore.P2P.Peer.NetworkPeerConnectionParameters,Blockcore.P2P.Peer.NetworkPeerDisposer)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeerFactory.CreateNetworkPeerServer(System.Net.IPEndPoint,System.Net.IPEndPoint,System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeerFactory.CreateNetworkPeerConnection(Blockcore.P2P.Peer.INetworkPeer,System.Net.Sockets.TcpClient,Blockcore.P2P.Protocol.ProcessMessageAsync{Blockcore.P2P.Protocol.IncomingMessage})">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeerFactory.RegisterOnSendingMessageCallback(System.Action{System.Net.IPEndPoint,Blockcore.P2P.Protocol.Payloads.Payload})">
            <inheritdoc/>
        </member>
        <member name="T:Blockcore.P2P.Peer.NetworkPeerListener">
            <summary>
            Message listener that waits until a specific payload is received and returns it to the caller.
            </summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerListener.asyncIncomingMessagesQueue">
            <summary>Queue of unprocessed messages.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerListener.peer">
            <summary>Connected network peer that we receive messages from.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerListener.messageProducerRegistration">
            <summary>Registration to the message producer of the connected peer.</summary>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeerListener.#ctor(Blockcore.P2P.Peer.INetworkPeer,Blockcore.AsyncWork.IAsyncProvider)">
            <summary>
            Initializes the instance of the object and subscribes to the peer's message producer.
            </summary>
            <param name="peer">Connected network peer that we receive messages from.</param>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeerListener.PushMessage(Blockcore.P2P.Protocol.IncomingMessage)">
            <inheritdoc/>
            <remarks>Adds the newly received message to the queue.</remarks>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeerListener.ReceivePayloadAsync``1(System.Threading.CancellationToken)">
            <summary>
            Waits until a message with a specific payload arrives from the peer.
            </summary>
            <typeparam name="TPayload">Type of payload to wait for.</typeparam>
            <param name="cancellationToken">Cancellation token to abort the waiting operation.</param>
            <returns>Payload of the specific type received from the peer.</returns>
            <exception cref="T:System.OperationCanceledException">Thrown if the peer is not connected when the method is called, or when <see cref="M:Blockcore.P2P.Peer.NetworkPeerListener.Dispose"/>
            has been called while we are waiting for the message.</exception>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeerListener.Dispose">
            <inheritdoc />
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerServer.logger">
            <summary>Instance logger.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerServer.networkPeerFactory">
            <summary>Factory for creating P2P network peers.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeerServer.Network">
            <summary>Specification of the network the node runs on - regtest/testnet/mainnet.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeerServer.Version">
            <summary>Version of the protocol that the server is running.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeerServer.InboundNetworkPeerConnectionParameters">
            <summary>The parameters that will be cloned and applied for each peer connecting to <see cref="T:Blockcore.P2P.Peer.NetworkPeerServer"/>.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeerServer.LocalEndpoint">
            <summary>IP address and port, on which the server listens to incoming connections.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeerServer.ExternalEndpoint">
            <summary>IP address and port of the external network interface that is accessible from the Internet.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerServer.tcpListener">
            <summary>TCP server listener accepting inbound connections.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerServer.serverCancel">
            <summary>Cancellation that is triggered on shutdown to stop all pending operations.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerServer.networkPeerDisposer">
            <summary>Maintains a list of connected peers and ensures their proper disposal.</summary>
        </member>
        <member name="P:Blockcore.P2P.Peer.NetworkPeerServer.ConnectedInboundPeersCount">
            <summary> The number connected inbound peers that the disposer has to dispose of.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerServer.acceptTask">
            <summary>Task accepting new clients in a loop.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerServer.initialBlockDownloadState">
            <summary>Provider of IBD state.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerServer.connectionManagerSettings">
            <summary>Configuration related to incoming and outgoing connections.</summary>
        </member>
        <member name="F:Blockcore.P2P.Peer.NetworkPeerServer.signals">
            <summary>Used to publish application events.</summary>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeerServer.#ctor(Blockcore.Networks.Network,System.Net.IPEndPoint,System.Net.IPEndPoint,System.UInt32,Microsoft.Extensions.Logging.ILoggerFactory,Blockcore.P2P.Peer.INetworkPeerFactory,Blockcore.Interfaces.IInitialBlockDownloadState,Blockcore.Configuration.Settings.ConnectionManagerSettings,Blockcore.AsyncWork.IAsyncProvider,Blockcore.P2P.IPeerAddressManager,Blockcore.Utilities.IDateTimeProvider)">
            <summary>
            Initializes instance of a network peer server.
            </summary>
            <param name="network">Specification of the network the node runs on - regtest/testnet/mainnet.</param>
            <param name="localEndPoint">IP address and port to listen on.</param>
            <param name="externalEndPoint">IP address and port that the server is reachable from the Internet on.</param>
            <param name="version">Version of the network protocol that the server should run.</param>
            <param name="loggerFactory">Factory for creating loggers.</param>
            <param name="networkPeerFactory">Factory for creating P2P network peers.</param>
            <param name="initialBlockDownloadState">Provider of IBD state.</param>
            <param name="connectionManagerSettings">Configuration related to incoming and outgoing connections.</param>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeerServer.Listen">
            <summary>
            Starts listening on the server's initialized endpoint.
            </summary>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeerServer.AcceptClientsAsync">
            <summary>
            Implements loop accepting connections from newly connected clients.
            </summary>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeerServer.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeerServer.CreateNetworkPeerConnectionParameters">
            <summary>
            Initializes connection parameters using the server's initialized values.
            </summary>
            <returns>Initialized connection parameters.</returns>
        </member>
        <member name="M:Blockcore.P2P.Peer.NetworkPeerServer.AllowClientConnection(System.Net.Sockets.TcpClient)">
            <summary>
            Check if the client is allowed to connect based on certain criteria.
            </summary>
            <returns>When criteria is met returns <c>true</c>, to allow connection.</returns>
        </member>
        <member name="T:Blockcore.P2P.Protocol.Behaviors.EnforcePeerVersionCheckBehavior">
            <summary>
            Sets the minimum supported client version <see cref="!:this.NodeSettings.MinProtocolVersion"/> to <see cref="!:this.Network.Consensus.Options.EnforcedMinProtocolVersion"/>
            based on the predefined block height <see cref="!:this.Network.Consensus.Options.EnforceMinProtocolVersionAtBlockHeight"/>.
            Once the new minimum supported client version is changed all existing peer connections will be dropped upon the first received message from outdated client.
            </summary>
        </member>
        <member name="F:Blockcore.P2P.Protocol.Behaviors.EnforcePeerVersionCheckBehavior.ChainIndexer">
            <summary>An indexer that provides methods to query the best chain (the chain that is validated by the full consensus rules)</summary>
        </member>
        <member name="F:Blockcore.P2P.Protocol.Behaviors.EnforcePeerVersionCheckBehavior.NodeSettings">
            <summary>User defined node settings.</summary>
        </member>
        <member name="F:Blockcore.P2P.Protocol.Behaviors.EnforcePeerVersionCheckBehavior.Network">
            <summary>Specification of the network the node runs on - regtest/testnet/mainnet.</summary>
        </member>
        <member name="F:Blockcore.P2P.Protocol.Behaviors.EnforcePeerVersionCheckBehavior.LoggerFactory">
            <summary>Logger factory used while cloning the object.</summary>
        </member>
        <member name="F:Blockcore.P2P.Protocol.Behaviors.EnforcePeerVersionCheckBehavior.Logger">
            <summary>Instance logger.</summary>
        </member>
        <member name="F:Blockcore.P2P.Protocol.Behaviors.EnforcePeerVersionCheckBehavior.callbacksRegistered">
            <summary>
            Set to <c>true</c> if the attached peer callbacks have been registered and they should be unregistered,
            <c>false</c> if the callbacks are not registered.
            </summary>
        </member>
        <member name="M:Blockcore.P2P.Protocol.Behaviors.EnforcePeerVersionCheckBehavior.#ctor(Blockcore.Consensus.Chain.ChainIndexer,Blockcore.Configuration.NodeSettings,Blockcore.Networks.Network,Microsoft.Extensions.Logging.ILoggerFactory)">
            <summary>
            Initializes an instance of the object for outbound network peers.
            </summary>
            <param name="chainIndexer">The chain of blocks.</param>
            <param name="nodeSettings">User defined node settings.</param>
            <param name="network">Specification of the network the node runs on - regtest/testnet/mainnet.</param>
            <param name="loggerFactory">Factory for creating loggers.</param>
        </member>
        <member name="M:Blockcore.P2P.Protocol.Behaviors.NetworkPeerBehavior.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.P2P.Protocol.Behaviors.PingPongBehavior">
            <summary>
            The PingPongBehavior is responsible for firing ping message every PingInterval and responding with pong message, and close the connection if the Ping has not been completed after TimeoutInterval.
            </summary>
        </member>
        <member name="P:Blockcore.P2P.Protocol.Behaviors.PingPongBehavior.Mode">
            <summary>
            Whether the behavior send Ping and respond with Pong (Default : Both)
            </summary>
        </member>
        <member name="P:Blockcore.P2P.Protocol.Behaviors.PingPongBehavior.TimeoutInterval">
            <summary>
            Interval after which an unresponded Ping will result in a disconnection. (Default : 20 minutes)
            </summary>
        </member>
        <member name="P:Blockcore.P2P.Protocol.Behaviors.PingPongBehavior.PingInterval">
            <summary>
            Interval after which a Ping message is fired after the last received Pong (Default : 2 minutes)
            </summary>
        </member>
        <member name="F:Blockcore.P2P.Protocol.Behaviors.PingPongBehavior.callbacksRegistered">
            <summary>
            Set to <c>true</c> if the attached peer callbacks have been registered and they should be unregistered,
            <c>false</c> if the callbacks are not registered.
            </summary>
        </member>
        <member name="M:Blockcore.P2P.Protocol.Behaviors.PingPongBehavior.Probe">
            <summary>
            Send a ping asynchronously.
            </summary>
        </member>
        <member name="M:Blockcore.P2P.Protocol.Behaviors.PingPongBehavior.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.P2P.Protocol.ProcessMessageAsync`1">
            <summary>
            Represents a callback routine to be called when a new message arrives to the listener.
            <para>
            It is guaranteed that only execution of the callback routine is executed at the time.
            </para>
            </summary>
            <param name="message">New message to be processed.</param>
            <param name="cancellationToken">Cancellation token that the callback method should use for its async operations to avoid blocking the listener during shutdown.</param>
            <typeparam name="T">Type of the messages that are being handled.</typeparam>
        </member>
        <member name="T:Blockcore.P2P.Protocol.CallbackMessageListener`1">
            <summary>
            Message listener that processes the incoming message using a user defined callback routine.
            </summary>
            <typeparam name="T">Type of the messages that are being handled.</typeparam>
        </member>
        <member name="F:Blockcore.P2P.Protocol.CallbackMessageListener`1.asyncQueue">
            <summary>Queue of the unprocessed incoming messages.</summary>
        </member>
        <member name="M:Blockcore.P2P.Protocol.CallbackMessageListener`1.#ctor(Blockcore.AsyncWork.IAsyncProvider,Blockcore.P2P.Protocol.ProcessMessageAsync{`0},Blockcore.P2P.Peer.INetworkPeer)">
            <summary>
            Initializes the instance of the object.
            </summary>
            <param name="processMessageAsync">User defined callback routine to be executed when a new message arrives to the listener.</param>
        </member>
        <member name="M:Blockcore.P2P.Protocol.CallbackMessageListener`1.PushMessage(`0)">
            <inheritdoc/>
            <remarks>Adds the newly received message to the queue.</remarks>
        </member>
        <member name="M:Blockcore.P2P.Protocol.CallbackMessageListener`1.Dispose">
            <inheritdoc/>
        </member>
        <member name="T:Blockcore.P2P.Protocol.Filters.INetworkPeerFilter">
            <summary>
            Contract to intercept sent and received messages.
            </summary>
        </member>
        <member name="M:Blockcore.P2P.Protocol.Filters.INetworkPeerFilter.OnReceivingMessage(Blockcore.P2P.Protocol.IncomingMessage,System.Action)">
            <summary>
            Intercept a message before it can be processed by listeners
            </summary>
            <param name="message">The message</param>
            <param name="next">The rest of the pipeline</param>
        </member>
        <member name="M:Blockcore.P2P.Protocol.Filters.INetworkPeerFilter.OnSendingMessage(Blockcore.P2P.Peer.INetworkPeer,Blockcore.P2P.Protocol.Payloads.Payload,System.Action)">
            <summary>
            Intercept a message before it is sent to the peer
            </summary>
            <param name="peer"></param>
            <param name="payload"></param>
            <param name="next">The rest of the pipeline</param>
        </member>
        <member name="T:Blockcore.P2P.Protocol.IMessageListener`1">
            <summary>
            Contract for a recipient part of a consumer logic that handles incoming messages.
            </summary>
            <typeparam name="T">Type of the messages that are being handled.</typeparam>
            <seealso cref="T:Blockcore.P2P.Protocol.MessageProducer`1"/>
        </member>
        <member name="M:Blockcore.P2P.Protocol.IMessageListener`1.PushMessage(`0)">
            <summary>
            Handles a newly received message.
            </summary>
            <param name="message">Message to handle.</param>
        </member>
        <member name="T:Blockcore.P2P.Protocol.IncomingMessage">
            <summary>
            A type takes context information about a <see cref="P:Blockcore.P2P.Protocol.IncomingMessage.Message"/>.
            </summary>
        </member>
        <member name="P:Blockcore.P2P.Protocol.IncomingMessage.Message">
            <summary>A network payload message.</summary>
        </member>
        <member name="P:Blockcore.P2P.Protocol.IncomingMessage.Length">
            <summary>The total length of the payload.</summary>
        </member>
        <member name="F:Blockcore.P2P.Protocol.Message.payloadProvider">
            <summary>A provider of network payload messages.</summary>
        </member>
        <member name="F:Blockcore.P2P.Protocol.Message.CommandSize">
            <summary>Size of the "command" part of the message in bytes.</summary>
        </member>
        <member name="F:Blockcore.P2P.Protocol.Message.LengthSize">
            <summary>Size of the "length" part of the message in bytes.</summary>
        </member>
        <member name="F:Blockcore.P2P.Protocol.Message.ChecksumSize">
            <summary>Size of the "checksum" part of the message in bytes, if it is present.</summary>
        </member>
        <member name="F:Blockcore.P2P.Protocol.Message.skipMagic">
            <summary>When parsing, maybe Magic is already parsed.</summary>
        </member>
        <member name="M:Blockcore.P2P.Protocol.Message.GetPayloadBytes(Blockcore.Consensus.ConsensusFactory,System.Int32@)">
            <summary>
            Read the payload in to byte array.
            </summary>
            <param name="consensusFactory">The network consensus factory.</param>
            <param name="length">The length of the payload.</param>
            <returns>The payload in bytes.</returns>
        </member>
        <member name="T:Blockcore.P2P.Protocol.MessageProducerRegistration`1">
            <summary>
            Binding between <see cref="T:Blockcore.P2P.Protocol.MessageProducer`1"/> and <see cref="T:Blockcore.P2P.Protocol.IMessageListener`1"/>.
            </summary>
            <typeparam name="T">Type of the messages that are being handled.</typeparam>
        </member>
        <member name="F:Blockcore.P2P.Protocol.MessageProducerRegistration`1.producer">
            <summary>Producer of messages.</summary>
        </member>
        <member name="F:Blockcore.P2P.Protocol.MessageProducerRegistration`1.listener">
            <summary>Consumer of messages.</summary>
        </member>
        <member name="M:Blockcore.P2P.Protocol.MessageProducerRegistration`1.#ctor(Blockcore.P2P.Protocol.IMessageListener{`0},Blockcore.P2P.Protocol.MessageProducer{`0})">
            <summary>
            Initializes an instance of the object.
            </summary>
            <param name="listener">Consumer of messages.</param>
            <param name="producer">Producer of messages.</param>
        </member>
        <member name="M:Blockcore.P2P.Protocol.MessageProducerRegistration`1.Dispose">
            <inheritdoc/>
        </member>
        <member name="T:Blockcore.P2P.Protocol.MessageProducer`1">
            <summary>
            Distributor of messages to attached consumers.
            </summary>
            <typeparam name="T">Type of the messages that are being handled.</typeparam>
        </member>
        <member name="F:Blockcore.P2P.Protocol.MessageProducer`1.listeners">
            <summary>List of attached consumers of this producer's messages.</summary>
        </member>
        <member name="M:Blockcore.P2P.Protocol.MessageProducer`1.#ctor">
            <summary>
            Initializes an instance of the object.
            </summary>
        </member>
        <member name="M:Blockcore.P2P.Protocol.MessageProducer`1.AddMessageListener(Blockcore.P2P.Protocol.IMessageListener{`0})">
            <summary>
            Add a new consumer to distribute messages to.
            </summary>
            <param name="listener">New consumer to distribute messages to.</param>
            <returns>Disposable binding between the producer and the consumer.</returns>
        </member>
        <member name="M:Blockcore.P2P.Protocol.MessageProducer`1.RemoveMessageListener(Blockcore.P2P.Protocol.IMessageListener{`0})">
            <summary>
            Stops distribution of message to a registered consumer.
            </summary>
            <param name="listener">Registered consumer to stop distributing messages to.</param>
        </member>
        <member name="M:Blockcore.P2P.Protocol.MessageProducer`1.PushMessage(`0)">
            <summary>
            Distributes a message among all attached consumers.
            </summary>
            <param name="message">Message to distribute.</param>
        </member>
        <member name="T:Blockcore.P2P.Protocol.Payloads.AddrPayload">
            <summary>
            An available peer address in the bitcoin network is announce (unsollicited or after a getaddr).
            </summary>
        </member>
        <member name="T:Blockcore.P2P.Protocol.Payloads.BlockPayload">
            <summary>
            A block received after being asked with a getdata message.
            </summary>
        </member>
        <member name="T:Blockcore.P2P.Protocol.Payloads.GetAddrPayload">
            <summary>
            Ask for known peer addresses in the network.
            </summary>
        </member>
        <member name="T:Blockcore.P2P.Protocol.Payloads.GetBlocksPayload">
            <summary>
            Ask for the block hashes (inv) that happened since BlockLocator.
            </summary>
        </member>
        <member name="T:Blockcore.P2P.Protocol.Payloads.GetDataPayload">
            <summary>
            Ask for transaction, block or merkle block.
            </summary>
        </member>
        <member name="T:Blockcore.P2P.Protocol.Payloads.GetHeadersPayload">
            <summary>
            Ask block headers that happened since BlockLocator.
            </summary>
        </member>
        <member name="P:Blockcore.P2P.Protocol.Payloads.GetHeadersPayload.BlockLocator">
            <summary>
            Gets a block locator which represents a compact structure of one's chain position which can be used to find
            forks with another chain.
            </summary>
        </member>
        <member name="P:Blockcore.P2P.Protocol.Payloads.GetHeadersPayload.HashStop">
            <summary>
            Gets a hash after which no new headers should be sent withing the same message.
            </summary>
            <remarks>
            As an example, in case we are asked to send headers from block 1000 but hashStop is at block
            1200 the answer should contain 200 headers.
            </remarks>
        </member>
        <member name="T:Blockcore.P2P.Protocol.Payloads.GetProvenHeadersPayload">
            <inheritdoc />
            <summary>
            Get proven headers payload which requests proven headers using a similar mechanism as
            the getheaders protocol message.
            </summary>
            <seealso cref="T:Blockcore.P2P.Protocol.Payloads.Payload" />
        </member>
        <member name="M:Blockcore.P2P.Protocol.Payloads.GetProvenHeadersPayload.ReadWriteCore(Blockcore.NBitcoin.BitcoinStream)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.P2P.Protocol.Payloads.HeadersPayload">
            <summary>
            Block headers received after a getheaders messages.
            </summary>
        </member>
        <member name="T:Blockcore.P2P.Protocol.Payloads.InvPayload">
            <summary>
            Announce the hash of a transaction or block.
            </summary>
        </member>
        <member name="F:Blockcore.P2P.Protocol.Payloads.InvPayload.MaxGetBlocksInventorySize">
            <summary>Maximal number of inventory items in response to "getblocks" message.</summary>
        </member>
        <member name="T:Blockcore.P2P.Protocol.Payloads.MempoolPayload">
            <summary>
            Ask for the mempool, followed by inv messages.
            </summary>
        </member>
        <member name="T:Blockcore.P2P.Protocol.Payloads.NotFoundPayload">
            <summary>
            A getdata message for an asked hash is not found by the remote peer.
            </summary>
        </member>
        <member name="T:Blockcore.P2P.Protocol.Payloads.PayloadAttribute">
            <summary>
            An attribute that enables mapping between command names and P2P netowrk types.
            </summary>
        </member>
        <member name="P:Blockcore.P2P.Protocol.Payloads.PayloadAttribute.Name">
            <summary>
            The command name.
            </summary>
        </member>
        <member name="M:Blockcore.P2P.Protocol.Payloads.PayloadAttribute.#ctor(System.String)">
            <summary>
            Initialize a new instance of the object.
            </summary>
            <param name="commandName"></param>
        </member>
        <member name="T:Blockcore.P2P.Protocol.Payloads.PayloadProvider">
            <summary>
            A provider that maps <see cref="T:Blockcore.P2P.Protocol.Payloads.PayloadAttribute"/> types with <see cref="P:Blockcore.P2P.Protocol.Message.Command"/>.
            This is used by the P2P code to map and deserialize messages that are received from the tcp network to a concrete type.
            </summary>
        </member>
        <member name="F:Blockcore.P2P.Protocol.Payloads.PayloadProvider.nameToType">
            <summary>
            A mapping between the command name and the payload type.
            </summary>
        </member>
        <member name="F:Blockcore.P2P.Protocol.Payloads.PayloadProvider.typeToName">
            <summary>
            A mapping between the payload type and the command name.
            </summary>
        </member>
        <member name="M:Blockcore.P2P.Protocol.Payloads.PayloadProvider.#ctor">
            <summary>
            Initialize a new instance of the object.
            </summary>
        </member>
        <member name="M:Blockcore.P2P.Protocol.Payloads.PayloadProvider.DiscoverPayloads(System.Reflection.Assembly)">
            <summary>
            Discover all payloads from the provided assembly, if no assembly is provided defaults to <see cref="T:Blockcore.P2P.Protocol.Payloads.PayloadAttribute"/>.
            </summary>
            <param name="assembly">The assembly to discover from or <see cref="T:Blockcore.P2P.Protocol.Payloads.PayloadAttribute"/> if <c>null</c>.</param>
        </member>
        <member name="M:Blockcore.P2P.Protocol.Payloads.PayloadProvider.AddPayload(System.Type)">
            <summary>
            Add a payload to the Provider by specifying its type.
            </summary>
            <param name="type">The type to payload to add.  Must derive from <see cref="T:Blockcore.P2P.Protocol.Payloads.Payload"/>.</param>
        </member>
        <member name="M:Blockcore.P2P.Protocol.Payloads.PayloadProvider.GetCommandType(System.String)">
            <summary>
            Get the <see cref="T:Blockcore.P2P.Protocol.Payloads.Payload"/> type associated with the command name.
            </summary>
            <param name="commandName">The command name.</param>
            <returns>The type of payload the command is associated with.</returns>
        </member>
        <member name="M:Blockcore.P2P.Protocol.Payloads.PayloadProvider.IsPayloadRegistered(System.Type)">
            <summary>
            Check that a <see cref="T:Blockcore.P2P.Protocol.Payloads.Payload"/> type is allowed to be used in the P2P code.
            </summary>
            <param name="type">A type that represents a <see cref="T:Blockcore.P2P.Protocol.Payloads.Payload"/></param>
            <returns>True if the type is registered as a usable payload.</returns>
        </member>
        <member name="T:Blockcore.P2P.Protocol.Payloads.ProvenHeadersPayload">
            <summary>
            Proven headers payload which contains list of up to 2000 proven headers.
            </summary>
            <seealso cref="T:Blockcore.P2P.Protocol.Payloads.Payload" />
        </member>
        <member name="F:Blockcore.P2P.Protocol.Payloads.ProvenHeadersPayload.headers">
            <summary>
            <see cref="P:Blockcore.P2P.Protocol.Payloads.ProvenHeadersPayload.Headers"/>
            </summary>
        </member>
        <member name="P:Blockcore.P2P.Protocol.Payloads.ProvenHeadersPayload.Headers">
            <summary>
            Gets a list of up to 2,000 proven headers.
            </summary>
        </member>
        <member name="M:Blockcore.P2P.Protocol.Payloads.ProvenHeadersPayload.ReadWriteCore(Blockcore.NBitcoin.BitcoinStream)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.P2P.Protocol.Payloads.RejectPayload">
            <summary>
            A transaction or block are rejected being transmitted through tx or block messages.
            </summary>
        </member>
        <member name="F:Blockcore.P2P.Protocol.Payloads.RejectPayload.message">
            <summary>"tx" or "block".</summary>
        </member>
        <member name="P:Blockcore.P2P.Protocol.Payloads.RejectPayload.Message">
            <summary>"tx" or "block".</summary>
        </member>
        <member name="F:Blockcore.P2P.Protocol.Payloads.RejectPayload.reason">
            <summary>Details of the error.</summary>
        </member>
        <member name="P:Blockcore.P2P.Protocol.Payloads.RejectPayload.Reason">
            <summary>Details of the error.</summary>
        </member>
        <member name="F:Blockcore.P2P.Protocol.Payloads.RejectPayload.hash">
            <summary>The hash being rejected.</summary>
        </member>
        <member name="P:Blockcore.P2P.Protocol.Payloads.RejectPayload.Hash">
            <summary>The hash being rejected.</summary>
        </member>
        <member name="T:Blockcore.P2P.Protocol.Payloads.TxPayload">
            <summary>
            Represents a transaction being sent on the network, is sent after being requested by a getdata (of Transaction or MerkleBlock) message.
            </summary>
        </member>
        <member name="F:Blockcore.P2P.Protocol.Payloads.NetworkPeerServices.Network">
            <summary>
            NODE_NETWORK means that the node is capable of serving the block chain. It is currently
            set by all Bitcoin Core nodes, and is unset by SPV clients or other peers that just want
            network services but don't provide them.
            </summary>
        </member>
        <member name="F:Blockcore.P2P.Protocol.Payloads.NetworkPeerServices.GetUTXO">
            <summary>
             NODE_GETUTXO means the node is capable of responding to the getutxo protocol request.
            Bitcoin Core does not support this but a patch set called Bitcoin XT does.
            See BIP 64 for details on how this is implemented.
            </summary>
        </member>
        <member name="F:Blockcore.P2P.Protocol.Payloads.NetworkPeerServices.NODE_BLOOM">
            <summary> NODE_BLOOM means the node is capable and willing to handle bloom-filtered connections.
            Bitcoin Core nodes used to support this by default, without advertising this bit,
            but no longer do as of protocol version 70011 (= NO_BLOOM_VERSION)
            </summary>
        </member>
        <member name="F:Blockcore.P2P.Protocol.Payloads.NetworkPeerServices.NODE_WITNESS">
            <summary> Indicates that a node can be asked for blocks and transactions including
            witness data.
            </summary>
        </member>
        <member name="T:Blockcore.P2P.SelfEndpointTracker">
            <summary>
            Tracker for endpoints known to be self.
            </summary>
        </member>
        <member name="F:Blockcore.P2P.SelfEndpointTracker.knownSelfEndpoints">
            <summary>Hashset to hold the endpoints currently known to be itself.</summary>
        </member>
        <member name="F:Blockcore.P2P.SelfEndpointTracker.logger">
            <summary>Instance logger.</summary>
        </member>
        <member name="P:Blockcore.P2P.SelfEndpointTracker.MyExternalAddressPeerScore">
            <summary>Peer score of external IP address of the node.</summary>
        </member>
        <member name="P:Blockcore.P2P.SelfEndpointTracker.IsMyExternalAddressFinal">
            <summary>Whether IP address of the node is final or can be updated.</summary>
        </member>
        <member name="F:Blockcore.P2P.SelfEndpointTracker.lockObject">
            <summary>Protects access to <see cref="P:Blockcore.P2P.SelfEndpointTracker.MyExternalAddress"/>, <see cref="P:Blockcore.P2P.SelfEndpointTracker.MyExternalAddressPeerScore"/> and <see cref="P:Blockcore.P2P.SelfEndpointTracker.IsMyExternalAddressFinal"/>.</summary>
        </member>
        <member name="P:Blockcore.P2P.SelfEndpointTracker.MyExternalAddress">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.SelfEndpointTracker.#ctor(Microsoft.Extensions.Logging.ILoggerFactory,Blockcore.Configuration.Settings.ConnectionManagerSettings)">
            <summary>
            Initializes an instance of the self endpoint tracker.
            </summary>
            <param name="loggerFactory">Factory for creating loggers.</param>
        </member>
        <member name="M:Blockcore.P2P.SelfEndpointTracker.Add(System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.SelfEndpointTracker.IsSelf(System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.P2P.SelfEndpointTracker.UpdateAndAssignMyExternalAddress(System.Net.IPEndPoint,System.Boolean,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Blockcore.Persistence.IPersistenceProvider">
            <summary>
            Allow features to request a persistence implementation.
            </summary>
        </member>
        <member name="P:Blockcore.Persistence.IPersistenceProvider.Tag">
            <summary>
            Gets the tag of the persistence implementation (usually is the name of the db engine used, e.g. "litedb" or "rocksdb").
            </summary>
        </member>
        <member name="P:Blockcore.Persistence.IPersistenceProvider.FeatureType">
            <summary>
            Gets the type of the feature for which services will be registered.
            </summary>
        </member>
        <member name="M:Blockcore.Persistence.IPersistenceProvider.AddRequiredServices(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
            <summary>
            Add required services for a specific use case.
            </summary>
        </member>
        <member name="T:Blockcore.Persistence.IPersistenceProviderManager">
            <summary>
            Used by features to require a persistence implementation.
            </summary>
        </member>
        <member name="M:Blockcore.Persistence.IPersistenceProviderManager.RequirePersistence``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.String)">
            <summary>
            Requires the persistence implementation for the <typeparamref name="TFeature"/> feature type.
            </summary>
            <typeparam name="TFeature">The type of the feature.</typeparam>
            <param name="services">The services collection IPersistenceProvider will use to register persistence component needed by the specified feature.</param>
            <param name="persistenceProviderImplementation">The explicit persistence provider implementation. If null, the one specified by dbtype argument will be used.</param>
        </member>
        <member name="M:Blockcore.Persistence.IPersistenceProviderManager.Initialize">
            <summary>
            Initializes the persistence provider manager, loading known persistence implementations based on the implementer strategy.
            </summary>
        </member>
        <member name="M:Blockcore.Persistence.IPersistenceProviderManager.GetAvailableProviders">
            <summary>
            Gets the available providers.
            </summary>
        </member>
        <member name="M:Blockcore.Persistence.IPersistenceProviderManager.GetDefaultProvider">
            <summary>
            Gets the default provider.
            </summary>
        </member>
        <member name="T:Blockcore.Persistence.PersistenceAttribute">
            <summary>
            Used to require a persistence implementation.
            This attribute has to be placed on top of implementation of services interface that manage persistence (e.g. IBlockStoreRepository
            </summary>
        </member>
        <member name="P:Blockcore.Persistence.PersistenceAttribute.PersistenceImplementation">
            <summary>
            Gets the name of the persistence implementation.
            This is the value that will be checked against <see cref="P:Blockcore.Configuration.NodeSettings.DbType"/>.
            </summary>
            <remarks>Case Insensitive.</remarks>
        </member>
        <member name="M:Blockcore.Persistence.PersistenceAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Blockcore.Persistence.PersistenceAttribute" /> class.
            </summary>
            <param name="persistenceImplementation">The persistence implementation. By convention it's the name of the underlying product that manage persistence (e.g. "LevelDb", "Rocksdb", etc...)</param>
        </member>
        <member name="T:Blockcore.Persistence.PersistenceProviderBase`1">
            <inheritdoc/>
        </member>
        <member name="P:Blockcore.Persistence.PersistenceProviderBase`1.Tag">
            <inheritdoc/>
        </member>
        <member name="P:Blockcore.Persistence.PersistenceProviderBase`1.FeatureType">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.Persistence.PersistenceProviderBase`1.AddRequiredServices(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
            <inheritdoc/>
        </member>
        <member name="T:Blockcore.Persistence.PersistenceProviderManager">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.Persistence.PersistenceProviderManager.#ctor(Blockcore.Configuration.NodeSettings)">
            <summary>
            Initializes a new instance of the <see cref="T:Blockcore.Persistence.PersistenceProviderManager"/> class.
            This class handles the initialization of persistence implementors for specific features on behalf of other features.
            For example if BlockStore feature requires a persistence, it can call
            </summary>
            <param name="nodeSettings">The settings from which obtain the default db type.</param>
        </member>
        <member name="M:Blockcore.Persistence.PersistenceProviderManager.GetAvailableProviders">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.Persistence.PersistenceProviderManager.GetDefaultProvider">
            <inheritdoc/>
        </member>
        <member name="M:Blockcore.Persistence.PersistenceProviderManager.Initialize">
            <inheritdoc/>
            <remarks>
            Search for all assemblies that implement the interface IPersistenceProvider in all referenced libraries.
            Create one instance for each of them and register the instance in the <see cref="F:Blockcore.Persistence.PersistenceProviderManager.persistenceProviders"/> dictionary in order to be found when <see cref="M:Blockcore.Persistence.PersistenceProviderManager.RequirePersistence``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.String)"/> will be called by any feature
            </remarks>
        </member>
        <member name="M:Blockcore.Persistence.PersistenceProviderManager.FindPersistenceAssembly(System.Reflection.Assembly)">
            <summary>
            Finds the persistence implementation in an assembly.
            </summary>
            <param name="assembly">The assembly to search persistence implementation from.</param>
        </member>
        <member name="M:Blockcore.Persistence.PersistenceProviderManager.RequirePersistence``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Blockcore.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Blockcore.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Blockcore.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Blockcore.Properties.Resources.Logo">
            <summary>
              Looks up a localized string similar to 
                   --                    
               ./yNMs                    
              -MMMMMs                    
              -MMMMMs                    
              -MMMMMs                    
              -MMMMMs    ``              
              -MMMMMs    /my/.`          
              -MMMMMs    /MMMNds:.       
              -MMMMMs    /MMMMMMMmh+-    
              -MMMMMs    `:sdNMMMMMMM.    _      _   _     _  _   _   _ 
              -MMMMMs       `-/mMMMMM.   |_) |  / \ /  |/ /  / \ |_) |_ 
              -MMMMMs          yMMMMM.   |_) |_ \_/ \_ |\ \_ \_/ | \ |_ 
              -MMMMMs          yMMMMM.                ww [rest of string was truncated]&quot;;.
            </summary>
        </member>
        <member name="T:Blockcore.Utilities.ActionDisposable">
            <summary>
            Helper class that is used for implementation of custom lock primitives.
            There are two actions - one is executed when an instance of the object is created
            and the other one is executed when the instance is disposed.
            </summary>
        </member>
        <member name="F:Blockcore.Utilities.ActionDisposable.onEnter">
            <summary>Method to call when an instance of the object is created.</summary>
        </member>
        <member name="F:Blockcore.Utilities.ActionDisposable.onLeave">
            <summary>Method to call when an instance of the object is disposed.</summary>
        </member>
        <member name="M:Blockcore.Utilities.ActionDisposable.#ctor(System.Action,System.Action)">
            <summary>
            Initializes an instance of the object and executes the <paramref name="onEnter"/> method.
            </summary>
            <param name="onEnter">Method to call when an instance of the object is created.</param>
            <param name="onLeave">Method to call when an instance of the object is disposed.</param>
        </member>
        <member name="M:Blockcore.Utilities.ActionDisposable.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Utilities.AsyncExecutionEventCallback`2">
            <summary>
            Asynchronous event handler that can be registered with <see cref="T:Blockcore.Utilities.AsyncExecutionEvent`2"/>.
            </summary>
            <typeparam name="TSender">Type of the sender object that is the source of the event.</typeparam>
            <typeparam name="TArg">Type of the argument that is passed to the callback.</typeparam>
            <param name="sender">Source of the event.</param>
            <param name="arg">Callback argument.</param>
        </member>
        <member name="T:Blockcore.Utilities.AsyncExecutionEvent`2">
            <summary>
            Execution event is a specific moment in the execution flow of that a component
            that other components are allowed to be subscribed to and get notified about
            when it occurs.
            <para>
            This implementation allows components to register asynchronous event handlers.
            </para>
            </summary>
            <typeparam name="TSender">Type of event source sender objects.</typeparam>
            <typeparam name="TArg">Type of arguments that are passed to callbacks.</typeparam>
        </member>
        <member name="F:Blockcore.Utilities.AsyncExecutionEvent`2.asyncLock">
            <summary>
            Protects access to <see cref="F:Blockcore.Utilities.AsyncExecutionEvent`2.callbackList"/> and <see cref="F:Blockcore.Utilities.AsyncExecutionEvent`2.callbackToListNodeMapping"/>,
            and also provides guarantees of <see cref="M:Blockcore.Utilities.AsyncExecutionEvent`2.Unregister(Blockcore.Utilities.AsyncExecutionEventCallback{`0,`1})"/> method.
            </summary>
        </member>
        <member name="F:Blockcore.Utilities.AsyncExecutionEvent`2.callbackList">
            <summary>List of registered callbacks.</summary>
            <remarks>All access to this object has to be protected with <see cref="F:Blockcore.Utilities.AsyncExecutionEvent`2.asyncLock"/>.</remarks>
        </member>
        <member name="F:Blockcore.Utilities.AsyncExecutionEvent`2.callbackToListNodeMapping">
            <summary>Mapping of registered callbacks to nodes of <see cref="F:Blockcore.Utilities.AsyncExecutionEvent`2.callbackList"/> to allow fast lookup during removals.</summary>
            <remarks>All access to this object has to be protected with <see cref="F:Blockcore.Utilities.AsyncExecutionEvent`2.asyncLock"/>.</remarks>
        </member>
        <member name="F:Blockcore.Utilities.AsyncExecutionEvent`2.callbackExecutionInProgress">
            <summary>
            Set to <c>true</c> if the current async execution context is the one that executes the callbacks,
            set to <c>false</c> otherwise.
            </summary>
            <remarks>
            This allows <see cref="M:Blockcore.Utilities.AsyncExecutionEvent`2.Register(Blockcore.Utilities.AsyncExecutionEventCallback{`0,`1},System.Boolean)"/> and <see cref="M:Blockcore.Utilities.AsyncExecutionEvent`2.Unregister(Blockcore.Utilities.AsyncExecutionEventCallback{`0,`1})"/>
            to recognize whether they are executing from a callback or not.
            </remarks>
        </member>
        <member name="F:Blockcore.Utilities.AsyncExecutionEvent`2.cancellationSource">
            <summary>Cancellation source to abort waiting for <see cref="F:Blockcore.Utilities.AsyncExecutionEvent`2.asyncLock"/> after <see cref="M:Blockcore.Utilities.AsyncExecutionEvent`2.Dispose"/> has been executed.</summary>
        </member>
        <member name="F:Blockcore.Utilities.AsyncExecutionEvent`2.disposed">
            <summary>Set to <c>1</c> if <see cref="M:Blockcore.Utilities.AsyncExecutionEvent`2.Dispose"/> was called, <c>0</c> otherwise.</summary>
        </member>
        <member name="M:Blockcore.Utilities.AsyncExecutionEvent`2.#ctor">
            <summary>
            Initializes an instance of the object.
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.AsyncExecutionEvent`2.Register(Blockcore.Utilities.AsyncExecutionEventCallback{`0,`1},System.Boolean)">
            <summary>
            Registers a new callback to be called when an event occurs.
            </summary>
            <param name="callbackAsync">Callback method to register.</param>
            <param name="addFirst"><c>true</c> to insert the new callback as the first callback to be called,
            <c>false</c> to add it as the last one.</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="callbackAsync"/> has already been registered.</exception>
            <remarks>
            It is allowed that a callback method registers another callback.
            </remarks>
        </member>
        <member name="M:Blockcore.Utilities.AsyncExecutionEvent`2.Unregister(Blockcore.Utilities.AsyncExecutionEventCallback{`0,`1})">
            <summary>
            Unregisters an existing callback.
            </summary>
            <param name="callbackAsync">Callback method to unregister.</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="callbackAsync"/> was not found among registered callbacks.</exception>
            <remarks>
            The caller is guaranteed that once this method completes, <paramref name="callbackAsync"/> will not be called by this executor.
            <para>It is allowed that a callback method unregisters itself (or another callback).</para>
            </remarks>
        </member>
        <member name="M:Blockcore.Utilities.AsyncExecutionEvent`2.ExecuteCallbacksAsync(`0,`1)">
            <summary>
            Calls all registered callbacks with the given arguments.
            </summary>
            <param name="sender">Source of the event.</param>
            <param name="arg">Argument to pass to the callbacks.</param>
            <remarks>
            It is necessary to hold the lock while calling the callbacks to provide guarantees described in <see cref="M:Blockcore.Utilities.AsyncExecutionEvent`2.Unregister(Blockcore.Utilities.AsyncExecutionEventCallback{`0,`1})"/>.
            However, we do support new callbacks to be registered or unregistered while callbacks are being executed,
            but this is only possible from the same execution context - i.e. another task or thread is unable to register or unregister callbacks
            while callbacks execution is in progress.
            </remarks>
        </member>
        <member name="M:Blockcore.Utilities.AsyncExecutionEvent`2.Dispose">
            <inheritdoc />
            <remarks>
            It is allowed that the callback in execution calls this method to dispose the execution event,
            in which case, the disposing is deferred after the execution of callbacks is complete.
            </remarks>
        </member>
        <member name="M:Blockcore.Utilities.AsyncExecutionEvent`2.DisposeInternal">
            <summary>
            Acquires <see cref="F:Blockcore.Utilities.AsyncExecutionEvent`2.asyncLock"/> and disposes resources including the lock.
            This lock will never be released, but that is not a problem since it is destroyed.
            </summary>
        </member>
        <member name="T:Blockcore.Utilities.AsyncLock">
            <summary>
            An async synchronization primitive that allows the caller to await inside the critical section.
            <para>
            The lock is disposable, which allows the caller to use the convenient <c>using</c> statement
            and avoid caring about releasing the lock.
            </para>
            </summary>
            <example>
            The lock can be used in async environment:
            <code>
            private AsyncLock asyncLock = new AsyncLock();
            ...
            using (await asyncLock.LockAsync(cancellationToken))
            {
                // Body of critical section.
                ...
                // Unlocking is automatic in Dispose method invoked by using statement.
            }
            </code>
            <para>
            or it can be used in non-async environment:
            </para>
            <code>
            using (asyncLock.Lock(cancellationToken))
            {
                // Body of critical section.
                ...
                // Unlocking is again automatic in Dispose method invoked by using statement.
            }
            </code>
            </example>
            <remarks>Based on https://www.hanselman.com/blog/ComparingTwoTechniquesInNETAsynchronousCoordinationPrimitives.aspx .</remarks>
        </member>
        <member name="T:Blockcore.Utilities.AsyncLock.Releaser">
            <summary>
            Disposable mechanism that is attached to the parent lock and releases it when it is disposed.
            This allows the user of the lock to use the convenient <c>using</c> statement and avoid
            caring about manual releasing of the lock.
            </summary>
        </member>
        <member name="F:Blockcore.Utilities.AsyncLock.Releaser.toRelease">
            <summary>Parent lock to be released when this releaser is disposed, or <c>null</c> if no action should be taken on disposing it.</summary>
        </member>
        <member name="M:Blockcore.Utilities.AsyncLock.Releaser.#ctor(Blockcore.Utilities.AsyncLock)">
            <summary>
            Connects the releaser with its parent lock.
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.AsyncLock.Releaser.Dispose">
            <inheritdoc />
        </member>
        <member name="F:Blockcore.Utilities.AsyncLock.semaphore">
            <summary>Internal synchronization primitive used as a mutex to only allow one thread to occupy the critical section.</summary>
        </member>
        <member name="F:Blockcore.Utilities.AsyncLock.releaser">
            <summary>
            Helper object that allows implementation of disposable lock for convenient use with <c>using</c> statement.
            <para>This releaser is used when the lock has been acquired and disposing it will release the lock.</para>
            </summary>
            <remarks>We use the disposable interfaced in a task here to avoid allocations on acquiring the lock when it is free.</remarks>
        </member>
        <member name="M:Blockcore.Utilities.AsyncLock.#ctor">
            <summary>
            Initializes an instance of the object.
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.AsyncLock.LockAsync(System.Threading.CancellationToken)">
            <summary>
            Acquires the lock.
            </summary>
            <param name="cancel">Cancellation token that can be used to abort waiting for the lock.</param>
            <returns>Disposable interface to enable using construct. Disposing it releases the lock.</returns>
            <exception cref="T:System.OperationCanceledException">Thrown when the <paramref name="cancel"/> is triggered and the lock is not acquired.</exception>
        </member>
        <member name="M:Blockcore.Utilities.AsyncLock.Lock(System.Threading.CancellationToken)">
            <summary>
            Acquires the lock.
            </summary>
            <param name="cancel">Cancellation token that can be used to abort waiting for the lock.</param>
            <returns>Disposable interface to enable using construct. Disposing it releases the lock.</returns>
            <exception cref="T:System.OperationCanceledException">Thrown when the <paramref name="cancel"/> is triggered and the lock is not acquired.</exception>
        </member>
        <member name="M:Blockcore.Utilities.AsyncLock.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Utilities.AsyncManualResetEvent">
            <summary>
            An async-compatible manual-reset event.
            </summary>
        </member>
        <member name="F:Blockcore.Utilities.AsyncManualResetEvent.mutex">
            <summary>
            Lock to protect access to <see cref="F:Blockcore.Utilities.AsyncManualResetEvent.tcs"/>.
            </summary>
        </member>
        <member name="F:Blockcore.Utilities.AsyncManualResetEvent.tcs">
            <summary>
            The current state of the event.
            </summary>
            <remarks>All access to this object has to be protected by <see cref="F:Blockcore.Utilities.AsyncManualResetEvent.mutex"/>.</remarks>
        </member>
        <member name="M:Blockcore.Utilities.AsyncManualResetEvent.#ctor(System.Boolean)">
            <summary>
            Creates an async-compatible manual-reset event.
            </summary>
            <param name="set">Whether the manual-reset event is initially set or unset.</param>
        </member>
        <member name="M:Blockcore.Utilities.AsyncManualResetEvent.#ctor">
            <summary>
            Creates an async-compatible manual-reset event that is initially unset.
            </summary>
        </member>
        <member name="P:Blockcore.Utilities.AsyncManualResetEvent.IsSet">
            <summary>
            Whether this event is currently set. This member is seldom used; code using this member has a high possibility of race conditions.
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.AsyncManualResetEvent.WaitAsync">
            <summary>
            Asynchronously waits for this event to be set.
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.AsyncManualResetEvent.WaitAsync(System.Threading.CancellationToken)">
            <summary>
            Asynchronously waits for this event to be set or for the wait to be canceled.
            </summary>
            <param name="cancellationToken">The cancellation token used to cancel the wait. If this token is already canceled, this method will first check whether the event is set.</param>
        </member>
        <member name="M:Blockcore.Utilities.AsyncManualResetEvent.Set">
            <summary>
            Sets the event, atomically completing every task returned by <see cref="M:Blockcore.Utilities.AsyncManualResetEvent.WaitAsync"/>. If the event is already set, this method does nothing.
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.AsyncManualResetEvent.Reset">
            <summary>
            Resets the event. If the event is already reset, this method does nothing.
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.AsyncManualResetEvent.CreateAsyncTaskSource``1">
            <summary>
            Creates a new TCS for use with async code, and which forces its continuations to execute asynchronously.
            </summary>
            <typeparam name="TResult">The type of the result of the TCS.</typeparam>
        </member>
        <member name="T:Blockcore.Utilities.AverageCalculator">
            <summary>Calculates average value of last N added samples every time new sample is added.</summary>
            <remarks>
            Implementation doesn't iterate through the whole collection of samples when average value is being calculated which makes this component more optimal
            in terms of performance when frequent calculation of an average value on a set of items is required.
            </remarks>
        </member>
        <member name="P:Blockcore.Utilities.AverageCalculator.Average">
            <summary>Average value of supplied samples.</summary>
        </member>
        <member name="F:Blockcore.Utilities.AverageCalculator.samples">
            <summary>Samples used in calculation of the average value.</summary>
        </member>
        <member name="M:Blockcore.Utilities.AverageCalculator.#ctor(System.Int32)">
            <summary>Initializes a new instance of the <see cref="T:Blockcore.Utilities.AverageCalculator"/> class.</summary>
            <param name="maxSamples">Maximum amount of samples that can be used in the calculation of the average value.</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="maxSamples"/> is less than 2.</exception>
        </member>
        <member name="M:Blockcore.Utilities.AverageCalculator.GetMaxSamples">
            <summary>Gets the maximum amount of samples that can be used in the calculation of the average value.</summary>
        </member>
        <member name="M:Blockcore.Utilities.AverageCalculator.SetMaxSamples(System.Int32)">
            <summary>Sets the maximum amount of samples that can be used in the calculation of the average value.</summary>
            <remarks>This is an expensive operation since it will require recreating an array of samples.</remarks>
        </member>
        <member name="M:Blockcore.Utilities.AverageCalculator.AddSample(System.Double)">
            <summary>Adds a new sample and recalculates <see cref="P:Blockcore.Utilities.AverageCalculator.Average"/> value.</summary>
            <param name="sample">New sample.</param>
        </member>
        <member name="T:Blockcore.Utilities.CircularArray`1">
            <summary>
            Generic circular array is a fixed length array which stores collection
            of items. Once the array is full, adding a new item removes the oldest entry.
            </summary>
            <typeparam name="T">Type of the items stored in the array.</typeparam>
            <remarks>
            Complexity of supported operations:
            <list type="bullet">
            <item><see cref="M:Blockcore.Utilities.CircularArray`1.Add(`0,`0@)"/> - O(1),</item>
            <item><see cref="P:Blockcore.Utilities.CircularArray`1.Item(System.Int32)"/> - O(1).</item>
            </list>
            </remarks>
        </member>
        <member name="P:Blockcore.Utilities.CircularArray`1.Capacity">
            <summary>Maximal number of items that can be stored in <see cref="F:Blockcore.Utilities.CircularArray`1.items"/> array.</summary>
        </member>
        <member name="P:Blockcore.Utilities.CircularArray`1.Count">
            <summary>Number of valid (slots in array occupied by added items) items in <see cref="F:Blockcore.Utilities.CircularArray`1.items"/> array.</summary>
        </member>
        <member name="P:Blockcore.Utilities.CircularArray`1.Index">
            <summary>Index in <see cref="F:Blockcore.Utilities.CircularArray`1.items"/> array where the next item will be stored.</summary>
        </member>
        <member name="F:Blockcore.Utilities.CircularArray`1.items">
            <summary>Circular array of items, which holds <see cref="P:Blockcore.Utilities.CircularArray`1.Count"/> valid items, and can store up to <see cref="P:Blockcore.Utilities.CircularArray`1.Capacity"/> items.</summary>
        </member>
        <member name="M:Blockcore.Utilities.CircularArray`1.#ctor(System.Int32,System.Boolean)">
            <summary>
            Initializes a new instance of the object.
            </summary>
            <param name="capacity">Maximal number of items that can be stored in the circular array.</param>
            <param name="preinitializeItems">If set to <c>true</c>, all items in the array will be initialized using their default constructor.
            This can be used to prevent further allocations when the structure is used.</param>
        </member>
        <member name="M:Blockcore.Utilities.CircularArray`1.Add(`0,`0@)">
            <summary>
            Add a new item to the circular array.
            </summary>
            <param name="item">Item to add.</param>
            <param name="oldItem">If the function returns <c>true</c>, this is filled with the oldest item that was replaced.</param>
            <returns><c>true</c> if the oldest item was replaced, <c>false</c> otherwise.</returns>
            <remarks>If the array already reached its capacity, this method will replace the oldest item with the new item.</remarks>
        </member>
        <member name="M:Blockcore.Utilities.CircularArray`1.RemoveFirst(`0@)">
            <summary>
            Removes the first item from the circular array, which is the oldest entry in the array.
            </summary>
            <param name="firstItem">If the function returns <c>true</c>, this is filled with the oldest item that was removed.</param>
            <returns><c>true</c> if the oldest item was removed, <c>false</c> if there were no items.</returns>
        </member>
        <member name="P:Blockcore.Utilities.CircularArray`1.Item(System.Int32)">
            <summary>
            Access to an item at specific index.
            </summary>
            <param name="i">Zero-based index of the item to access. Index must be an integer between 0 and <see cref="P:Blockcore.Utilities.CircularArray`1.Capacity"/> - 1.</param>
            <returns>Item of the circular array at index <paramref name="i"/>.</returns>
        </member>
        <member name="M:Blockcore.Utilities.CircularArray`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.CircularArray`1.GetEnumerator">
            <inheritdoc />
            <remarks>Items are enumerated in order of their addition starting with the oldest item.</remarks>
        </member>
        <member name="T:Blockcore.Utilities.DataStoreSerializer">
            <summary>
            Implementation of serialization and deserialization of objects that go into the DBreeze database.
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.DataStoreSerializer.Serialize(System.Object)">
            <summary>
            Serializes object to a binary data format.
            </summary>
            <param name="obj">Object to be serialized.</param>
            <returns>Binary data representing the serialized object.</returns>
        </member>
        <member name="M:Blockcore.Utilities.DataStoreSerializer.ConcatArrays(System.Byte[][])">
            <summary>
            Concatenates multiple byte arrays into a single byte array.
            </summary>
            <param name="arrays">Arrays to concatenate.</param>
            <returns>Concatenation of input arrays.</returns>
            <remarks>Based on https://stackoverflow.com/a/415396/3835864 .</remarks>
        </member>
        <member name="M:Blockcore.Utilities.DataStoreSerializer.Deserialize(System.Byte[],System.Type)">
            <summary>
            Deserializes binary data to an object of specific type.
            </summary>
            <param name="bytes">Binary data representing a serialized object.</param>
            <param name="type">Type of the serialized object.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="T:Blockcore.Utilities.IDateTimeProvider">
            <summary>
            Providing date time functionality.
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.IDateTimeProvider.GetTime">
            <summary>
            Get the current time in Linux format.
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.IDateTimeProvider.GetTimeOffset">
            <summary>
            Get the current time offset in UTC.
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.IDateTimeProvider.GetUtcNow">
            <summary>
            Get the current time in UTC.
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.IDateTimeProvider.GetAdjustedTime">
            <summary>
            Obtains adjusted time, which is time synced with network peers.
            </summary>
            <returns>Adjusted UTC timestamp.</returns>
        </member>
        <member name="M:Blockcore.Utilities.IDateTimeProvider.GetAdjustedTimeAsUnixTimestamp">
            <summary>
            Obtains adjusted time, which is time synced with network peers, as Unix timestamp with seconds precision.
            </summary>
            <returns>Adjusted UTC timestamp as Unix timestamp with seconds precision.</returns>
        </member>
        <member name="M:Blockcore.Utilities.IDateTimeProvider.SetAdjustedTimeOffset(System.TimeSpan)">
            <summary>
            Sets adjusted time offset, which is time difference from network peers.
            </summary>
            <param name="adjustedTimeOffset">Offset to adjust time with.</param>
        </member>
        <member name="T:Blockcore.Utilities.DateTimeProvider">
            <inheritdoc />
        </member>
        <member name="P:Blockcore.Utilities.DateTimeProvider.Default">
            <summary>Static instance of the object to prevent the need of creating new instance.</summary>
        </member>
        <member name="P:Blockcore.Utilities.DateTimeProvider.adjustedTimeOffset">
            <summary>UTC adjusted timestamp, or null if no adjusted time is set.</summary>
        </member>
        <member name="M:Blockcore.Utilities.DateTimeProvider.#cctor">
            <summary>
            Initializes a default instance of the object.
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.DateTimeProvider.#ctor">
            <summary>
            Initializes instance of the object.
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.DateTimeProvider.GetTime">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.DateTimeProvider.GetUtcNow">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.DateTimeProvider.GetTimeOffset">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.DateTimeProvider.GetAdjustedTime">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.DateTimeProvider.GetAdjustedTimeAsUnixTimestamp">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.DateTimeProvider.SetAdjustedTimeOffset(System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.Extensions.AssemblyExtensions.GetLoadableTypes(System.Reflection.Assembly)">
            <summary>
            Gets the loadable types, ignoring assembly that can't be loaded for any reason.
            </summary>
        </member>
        <member name="T:Blockcore.Utilities.Extensions.BlockExtensions">
            <summary>
            TODO: These will move back to BlockSizeRule once has the rules has been migrated.
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.Extensions.BlockExtensions.GetBlockWeight(Blockcore.Consensus.BlockInfo.Block,Blockcore.Consensus.IConsensus)">
            <summary>
            Gets the block weight.
            </summary>
            <remarks>
            This implements the <c>weight = (stripped_size * 4) + witness_size</c> formula, using only serialization with and without witness data.
            As witness_size is equal to total_size - stripped_size, this formula is identical to: <c>weight = (stripped_size * 3) + total_size</c>.
            </remarks>
            <param name="block">Block that we get weight of.</param>
            <returns>Block weight.</returns>
        </member>
        <member name="M:Blockcore.Utilities.Extensions.BlockExtensions.GetSize(Blockcore.NBitcoin.IBitcoinSerializable,Blockcore.Consensus.TransactionInfo.TransactionOptions,Blockcore.Consensus.ConsensusFactory)">
            <summary>
            Gets serialized size of <paramref name="data"/> in bytes.
            </summary>
            <param name="data">Data that we calculate serialized size of.</param>
            <param name="options">Serialization options.</param>
            <returns>Serialized size of <paramref name="data"/> in bytes.</returns>
        </member>
        <member name="T:Blockcore.Utilities.Extensions.CollectionExtensions">
            <summary>
            Extension methods for collections.
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.Extensions.CollectionExtensions.IsEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            An extension that will check if an <see cref="T:System.Collections.Generic.IEnumerable`1"/> is empty.
            </summary>
            <typeparam name="TSource">The type of enumerable.</typeparam>
            <param name="source">The enumerable to check.</param>
            <returns><c>true</c> if empty otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Blockcore.Utilities.Extensions.CollectionExtensions.IsEmpty``1(System.Collections.Generic.IList{``0})">
            <summary>
            An extension that will check if an <see cref="T:System.Collections.Generic.IList`1"/> is empty.
            </summary>
            <typeparam name="TSource">The type of enumerable.</typeparam>
            <param name="source">The enumerable to check.</param>
            <returns><c>true</c> if empty otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Blockcore.Utilities.Extensions.CollectionExtensions.IsEmpty(System.Array)">
            <summary>
            An extension that will check if an <see cref="T:System.Array"/> is empty.
            </summary>
            <param name="source">The enumerable to check.</param>
            <returns><c>true</c> if empty otherwise <c>false</c>.</returns>
        </member>
        <member name="T:Blockcore.Utilities.Extensions.CommandLineArgsExtensions">
            <summary>
            Extension methods for command line arguments.
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.Extensions.CommandLineArgsExtensions.GetValueOf(System.String[],System.String)">
            <summary>
            Obtains a value of command line argument.
            <para>
            It is expected that arguments are written on command line as <c>argName=argValue</c>,
            where argName usually (but does not need to) starts with "-".
            </para>
            <para>
            The argValue can be wrapped with '"' quotes from both sides, in which case the quotes are removed,
            but it is not allowed for argValue to contain '"' inside the actual value.
            </para>
            </summary>
            <param name="args">Application command line arguments.</param>
            <param name="arg">Name of the command line argument which value should be obtained.</param>
            <returns>Value of the specified argument or null if no such argument is found among the given list of arguments.</returns>
        </member>
        <member name="T:Blockcore.Utilities.Extensions.DateTimeExtensions">
            <summary>
            Provides a set of extension methods for the <see cref="T:System.DateTime"/> class.
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.Extensions.DateTimeExtensions.ToUnixTimestamp(System.DateTime)">
            <summary>
            Converts a given DateTime into a Unix timestamp.
            </summary>
            <param name="value">Any DateTime</param>
            <returns>The given DateTime in Unix timestamp format</returns>
            <remarks>This represents the number of seconds that have elapsed since 1970-01-01T00:00:00Z.</remarks>
        </member>
        <member name="M:Blockcore.Utilities.Extensions.IPExtensions.MapToIpv6(System.Net.IPEndPoint)">
            <summary>Maps an end point to IPv6 if is not already mapped.</summary>
        </member>
        <member name="M:Blockcore.Utilities.Extensions.IPExtensions.Match(System.Net.IPEndPoint,System.Net.IPEndPoint)">
            <summary>Match the end point with another by IP and port.</summary>
        </member>
        <member name="M:Blockcore.Utilities.Extensions.IPExtensions.MatchIpOnly(System.Net.IPEndPoint,System.Net.IPEndPoint)">
            <summary>Match the IP address only (the port is ignored).</summary>
        </member>
        <member name="M:Blockcore.Utilities.Extensions.IPExtensions.ToIPEndPoint(System.String,System.Int32)">
            <summary>
            Converts a string to an IP endpoint.
            </summary>
            <param name="ipAddress">String to convert.</param>
            <param name="port">Port to use if <paramref name="ipAddress"/> does not specify it.</param>
            <returns>IP end point representation of the string.</returns>
            <remarks>
            IP addresses can have a port specified such that the format of <paramref name="ipAddress"/> is as such: address:port.
            IPv4 and IPv6 addresses are supported.
            In the case where the default port is passed and the IP address has a port specified in it, the IP address's port will take precedence.
            Examples of addresses that are supported are:
            - 15.61.23.23
            - 15.61.23.23:1500
            - [1233:3432:2434:2343:3234:2345:6546:4534]
            - [1233:3432:2434:2343:3234:2345:6546:4534]:8333
            - ::ffff:192.168.4.1
            - ::ffff:192.168.4.1:80
            - google.com (Resolves domain name to IP Address)
            - google.com:80 ('')
            - 1233:3432:2434:2343:3234:2345:6546:4534
            </remarks>
            <exception cref="!:ArgumentOutOfRangeException">Thrown in case of the port number is out of range.</exception>
            <exception cref="!:FormatException">Thrown in case of ipAddress or port number is invalid.</exception>
            <exception cref="!:SocketException">Thrown if the ipAddress is not a valid host name.</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Blockcore.Utilities.Extensions.IPExtensions.Contains(System.Net.IPEndPoint,System.Net.IPEndPoint)" -->
        <member name="M:Blockcore.Utilities.Extensions.IPExtensions.CanBeMappedTo(System.Net.IPEndPoint,System.Collections.Generic.List{System.Net.IPEndPoint},System.Net.IPEndPoint@)">
            <summary>
            This method determines if any of a list of network end points can be mapped to this whitebind endpoint.
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.Extensions.ServiceCollectionExtensions.RemoveSingleton``1(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
            <summary>
            Converts a long that represents a number of bytes to be represented in MB.
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.Extensions.StringExtensions.ToSecureString(System.String)">
            <summary>
            Converts a string to a SecureString object.
            </summary>
            <param name="input">The string to convert.</param>
            <returns>The SecureString result.</returns>
        </member>
        <member name="M:Blockcore.Utilities.Extensions.StringExtensions.FromSecureString(System.Security.SecureString)">
            <summary>
            Retrieves the underlying string from a SecureString object.
            </summary>
            <param name="secstrPassword">The SecureString object.</param>
            <returns>The underlying string contained in this object.</returns>
        </member>
        <member name="M:Blockcore.Utilities.Extensions.TaskExtensions.WithCancellationAsync``1(System.Threading.Tasks.Task{``0},System.Threading.CancellationToken)">
            <summary>
            Allows to cancel awaitable operations with a cancellationToken.
            https://devblogs.microsoft.com/pfxteam/how-do-i-cancel-non-cancelable-async-operations/
            </summary>
            <typeparam name="T">Task return type</typeparam>
            <param name="task">The task.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
            <exception cref="T:System.OperationCanceledException">Task has been cancelled.</exception>
        </member>
        <member name="M:Blockcore.Utilities.Extensions.TaskExtensions.WithCancellationAsync(System.Threading.Tasks.Task,System.Threading.CancellationToken)">
            <summary>
            Allows to cancel awaitable operations with a cancellationToken.
            https://devblogs.microsoft.com/pfxteam/how-do-i-cancel-non-cancelable-async-operations/
            </summary>
            <param name="task">The task.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
            <exception cref="T:System.OperationCanceledException">Task has been cancelled.</exception>
        </member>
        <member name="M:Blockcore.Utilities.Extensions.ThreadingExtensions.SafeRelease(System.Threading.SemaphoreSlim)">
            <summary>
            Don't throw SemaphoreFullException
            https://stackoverflow.com/questions/4706734/semaphore-what-is-the-use-of-initial-count
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.Extensions.ThreadingExtensions.SafeRelease(System.Threading.SemaphoreSlim,System.Int32)">
            <summary>
            Don't throw SemaphoreFullException
            https://stackoverflow.com/questions/4706734/semaphore-what-is-the-use-of-initial-count
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.Extensions.TypeExtensions.BytesToMegaBytes(System.Int64,System.Int32)">
            <summary>
            Converts a long that represents a number of bytes to be represented in MB.
            </summary>
        </member>
        <member name="T:Blockcore.Utilities.Extensions.VersionExtensions">
            <summary>
            Extension methods for Version class.
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.Extensions.VersionExtensions.ToUint(System.Version)">
            <summary>
            Converts a version information to integer.
            </summary>
            <param name="version">Version information to convert.</param>
            <returns>Integer representation of the <param name="version"/> information.</returns>
        </member>
        <member name="P:Blockcore.Utilities.FileStorageOption.Indent">
            <summary>
            Gets or sets a value indicating whether the output file content should be indented. Default value is false.
            </summary>
            <value>
              <c>true</c> if output file content is indented; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Blockcore.Utilities.FileStorageOption.SaveBackupFile">
            <summary>
            A value indicating whether to save a backup of the file. Default value is false.
            </summary>
            <value>
              <c>true</c> to save a backup file; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Blockcore.Utilities.FileStorageOption.SerializeNullValues">
            <summary>
            Gets or sets a value indicating whether a null value should be serialized in the output file. Default value is true.
            </summary>
            <value>
              <c>true</c> if null values are serialized; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:Blockcore.Utilities.FileStorageOption.GetSerializationSettings">
            <summary>
            Gets the serialization settings based on current options.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Blockcore.Utilities.FileStorage`1">
            <summary>
            Class providing methods to save objects as files on the file system.
            </summary>
            <typeparam name="T">The type of object to be stored in the file system.</typeparam>
        </member>
        <member name="P:Blockcore.Utilities.FileStorage`1.FolderPath">
            <summary> Gets the folder path. </summary>
        </member>
        <member name="M:Blockcore.Utilities.FileStorage`1.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Blockcore.Utilities.FileStorage`1"/> class.
            </summary>
            <param name="folderPath">The path of the folder in which the files are to be stored.</param>
        </member>
        <member name="M:Blockcore.Utilities.FileStorage`1.SaveToFile(`0,System.String,Blockcore.Utilities.FileStorageOption)">
            <summary>
            Saves an object to a file, optionally keeping a backup of it.
            </summary>
            <param name="toSave">Object to save as a file.</param>
            <param name="fileName">Name of the file to be saved.</param>
            <param name="options">The serialization options.</param>
        </member>
        <member name="M:Blockcore.Utilities.FileStorage`1.Exists(System.String)">
            <summary>
            Checks whether a file with the specified name exists in the folder.
            </summary>
            <param name="fileName">The name of the file to look for.</param>
            <returns>A value indicating whether the file exists in the file system.</returns>
        </member>
        <member name="M:Blockcore.Utilities.FileStorage`1.GetFilesPaths(System.String)">
            <summary>
            Gets the paths of the files with the specified extension.
            </summary>
            <param name="fileExtension">The file extension.</param>
            <returns>A list of paths for files with the specified extension.</returns>
        </member>
        <member name="M:Blockcore.Utilities.FileStorage`1.GetFilesNames(System.String)">
            <summary>
            Gets the names of files with the specified extension.
            </summary>
            <param name="fileExtension">The file extension.</param>
            <returns>A list of filenames with the specified extension.</returns>
        </member>
        <member name="M:Blockcore.Utilities.FileStorage`1.LoadByFileName(System.String)">
            <summary>
            Loads an object from the file in which it is persisted.
            </summary>
            <param name="fileName">The name of the file to load.</param>
            <returns>An object of type <see cref="!:T"/>.</returns>
            <exception cref="T:System.IO.FileNotFoundException">Indicates that no file with this name was found.</exception>
        </member>
        <member name="M:Blockcore.Utilities.FileStorage`1.CloneLegacyWallet(System.String)">
            <summary>
            Creates a copy of legacy wallets in to v2 wallets.
            </summary>
            <param name="fileExtension">The extension.</param>
            <returns>A list of objects of type <see cref="!:T"/> whose persisted files have the specified extension. </returns>
        </member>
        <member name="M:Blockcore.Utilities.FileStorage`1.LoadByFileExtension(System.String)">
            <summary>
            Loads all the objects that have file with the specified extension.
            </summary>
            <param name="fileExtension">The file extension.</param>
            <returns>A list of objects of type <see cref="!:T"/> whose persisted files have the specified extension. </returns>
        </member>
        <member name="T:Blockcore.Utilities.FullNodeExtensions">
            <summary>
            Extension methods for IFullNode interface.
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.FullNodeExtensions.RunAsync(Blockcore.IFullNode)">
            <summary>
            Installs handlers for graceful shutdown in the console, starts a full node and waits until it terminates.
            </summary>
            <param name="node">Full node to run.</param>
        </member>
        <member name="M:Blockcore.Utilities.FullNodeExtensions.RunAsync(Blockcore.IFullNode,System.Threading.CancellationToken)">
            <summary>
            Starts a full node, sets up cancellation tokens for its shutdown, and waits until it terminates.
            </summary>
            <param name="node">Full node to run.</param>
            <param name="cancellationToken">Cancellation token that triggers when the node should be shut down.</param>
        </member>
        <member name="T:Blockcore.Utilities.Guard">
            <summary>
            Collection of guard methods.
            <para>
            Guards are typically used at the beginning of a method to protect the body of
            the method being called with invalid set of parameters or object states.
            </para>
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.Guard.Assert(System.Boolean)">
            <summary>
            Asserts that a condition is true.
            </summary>
            <param name="condition">The condition to assert.</param>
        </member>
        <member name="M:Blockcore.Utilities.Guard.NotNull``1(``0,System.String)">
            <summary>
            Checks an object is not null.
            </summary>
            <typeparam name="T">The type of the object.</typeparam>
            <param name="value">The object.</param>
            <param name="parameterName">The name of the object.</param>
            <returns>The object if it is not null.</returns>
            <exception cref="T:System.ArgumentNullException">An exception if the object passed is null.</exception>
        </member>
        <member name="M:Blockcore.Utilities.Guard.NotEmpty(System.String,System.String)">
            <summary>
            Checks a <see cref="T:System.String"/> is not null or empty.
            </summary>
            <param name="value">The string to check.</param>
            <param name="parameterName">The name of the string.</param>
            <returns>The string if it is not null or empty.</returns>
        </member>
        <member name="T:Blockcore.Utilities.HashHeightPair">
            <summary>Pair of block hash and block height.</summary>
        </member>
        <member name="M:Blockcore.Utilities.HashHeightPair.ReadWrite(Blockcore.NBitcoin.BitcoinStream)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.HashHeightPair.ToString">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.HashHeightPair.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.HashHeightPair.Load(System.Byte[],Blockcore.Consensus.ConsensusFactory)">
            <summary>Constructs <see cref="T:Blockcore.Utilities.HashHeightPair"/> from a set bytes and the given network.</summary>
        </member>
        <member name="M:Blockcore.Utilities.IpHelper.FindPorts(System.Int32[])">
            <summary>
            Find ports that are free to use.
            </summary>
            <param name="ports">A list of ports to checked or fill/replace as necessary.</param>
        </member>
        <member name="T:Blockcore.Utilities.JsonConverters.AssetIdJsonConverter">
            <summary>
            Converter used to convert an <see cref="T:Blockcore.NBitcoin.OpenAsset.AssetId"/> to and from JSON.
            </summary>
            <seealso cref="T:Newtonsoft.Json.JsonConverter" />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.AssetIdJsonConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.AssetIdJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.AssetIdJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Utilities.JsonConverters.BitcoinSerializableJsonConverter">
            <summary>
            Converter used to convert an object implementing <see cref="T:Blockcore.NBitcoin.IBitcoinSerializable"/> to and from JSON.
            </summary>
            <seealso cref="T:Newtonsoft.Json.JsonConverter" />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.BitcoinSerializableJsonConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.BitcoinSerializableJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.BitcoinSerializableJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Utilities.JsonConverters.BitcoinStringJsonConverter">
            <summary>
            Converter used to convert an object implementing <see cref="T:Blockcore.NBitcoin.IBitcoinString"/> to and from JSON.
            </summary>
            <seealso cref="T:Newtonsoft.Json.JsonConverter" />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.BitcoinStringJsonConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.BitcoinStringJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.BitcoinStringJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Utilities.JsonConverters.ByteArrayConverter">
            <summary>
            Converter used to convert <see cref="T:System.Byte"/> arrays to and from JSON.
            </summary>
            <seealso cref="T:Newtonsoft.Json.JsonConverter" />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.ByteArrayConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.ByteArrayConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.ByteArrayConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Utilities.JsonConverters.CoinJsonConverter">
            <summary>
            Converter used to convert an object implementing <see cref="T:Blockcore.NBitcoin.ICoin"/> to and from JSON.
            </summary>
            <seealso cref="T:Newtonsoft.Json.JsonConverter" />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.CoinJsonConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.CoinJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.CoinJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Utilities.JsonConverters.DateTimeOffsetConverter">
            <summary>
            Converter used to convert <see cref="T:System.DateTimeOffset"/> to and from Unix time represented in JSON.
            </summary>
            <seealso cref="T:Newtonsoft.Json.JsonConverter" />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.DateTimeOffsetConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.DateTimeOffsetConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.DateTimeOffsetConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Utilities.JsonConverters.DateTimeToUnixTimeConverter">
            <summary>
            Converter used to convert a <see cref="T:System.DateTime"/> to and from JSON.
            </summary>
            <seealso cref="T:Newtonsoft.Json.JsonConverter" />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.DateTimeToUnixTimeConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.DateTimeToUnixTimeConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.DateTimeToUnixTimeConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Utilities.JsonConverters.HexJsonConverter">
            <summary>
            Converter used to convert a <see cref="!:byte[]"/> to and from hex-encoded JSON.
            </summary>
            <seealso cref="T:Newtonsoft.Json.JsonConverter" />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.HexJsonConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.HexJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.HexJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Utilities.JsonConverters.IPEndPointConverter">
            <summary>
            Converter used to convert <see cref="T:System.Net.IPEndPoint"/> to and from JSON.
            </summary>
            <seealso cref="T:Newtonsoft.Json.JsonConverter" />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.IPEndPointConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.IPEndPointConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.IPEndPointConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Utilities.JsonConverters.KeyJsonConverter">
            <summary>
            Converter used to convert a <see cref="T:Blockcore.NBitcoin.Key"/> or a <see cref="T:Blockcore.NBitcoin.PubKey"/> to and from JSON.
            </summary>
            <seealso cref="T:Newtonsoft.Json.JsonConverter" />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.KeyJsonConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.KeyJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.KeyJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Utilities.JsonConverters.KeyPathJsonConverter">
            <summary>
            Converter used to convert a <see cref="T:Blockcore.NBitcoin.BIP32.KeyPath"/> to and from JSON.
            </summary>
            <seealso cref="T:Newtonsoft.Json.JsonConverter" />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.KeyPathJsonConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.KeyPathJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.KeyPathJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Utilities.JsonConverters.LockTimeJsonConverter">
            <summary>
            Converter used to convert a <see cref="T:Blockcore.NBitcoin.LockTime"/> to and from JSON.
            </summary>
            <seealso cref="T:Newtonsoft.Json.JsonConverter" />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.LockTimeJsonConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.LockTimeJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.LockTimeJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Utilities.JsonConverters.MoneyJsonConverter">
            <summary>
            Converter used to convert a <see cref="T:Blockcore.NBitcoin.Money"/> object to and from JSON.
            Uses satoshis as unit for serialization.
            </summary>
            <seealso cref="T:Newtonsoft.Json.JsonConverter" />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.MoneyJsonConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.MoneyJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.MoneyJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Utilities.JsonConverters.MoneyInCoinsJsonConverter">
            <summary>
            Converter used to convert a <see cref="T:Blockcore.NBitcoin.Money"/> object to and from JSON.
            Uses coins (BTC) as the unit for serialization.
            </summary>
            <seealso cref="T:Newtonsoft.Json.JsonConverter" />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.MoneyInCoinsJsonConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.MoneyInCoinsJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.MoneyInCoinsJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Utilities.JsonConverters.NetworkConverter">
            <summary>
            Converter used to convert <see cref="T:Blockcore.Networks.Network"/> to and from JSON.
            </summary>
            <seealso cref="T:Newtonsoft.Json.JsonConverter" />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.NetworkConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.NetworkConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.NetworkConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Utilities.JsonConverters.NetworkJsonConverter">
            <summary>
            Converter used to convert the name of a network in JSON to the corresponding <see cref="T:Blockcore.Networks.Network"/>.
            </summary>
            <seealso cref="T:Newtonsoft.Json.JsonConverter" />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.NetworkJsonConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.NetworkJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.NetworkJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Utilities.JsonConverters.OutPointJsonConverter">
            <summary>
            Converter used to convert a <see cref="T:Blockcore.Consensus.TransactionInfo.OutPoint"/> to and from JSON.
            </summary>
            <seealso cref="T:Newtonsoft.Json.JsonConverter" />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.OutPointJsonConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.OutPointJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.OutPointJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Utilities.JsonConverters.ScriptCollectionJsonConverter">
            <summary>
            Converter used to convert a <see cref="T:Blockcore.Consensus.ScriptInfo.Script"/> or a <see cref="T:Blockcore.Consensus.TransactionInfo.WitScript"/> to and from JSON.
            </summary>
            <seealso cref="T:Newtonsoft.Json.JsonConverter" />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.ScriptCollectionJsonConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.ScriptCollectionJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.ScriptCollectionJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Utilities.JsonConverters.ScriptJsonConverter">
            <summary>
            Converter used to convert a <see cref="T:Blockcore.Consensus.ScriptInfo.Script"/> or a <see cref="T:Blockcore.Consensus.TransactionInfo.WitScript"/> to and from JSON.
            </summary>
            <seealso cref="T:Newtonsoft.Json.JsonConverter" />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.ScriptJsonConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.ScriptJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.ScriptJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Utilities.JsonConverters.Serializer">
            <summary>
            Class providing method used to serialize/deserialize domain objects to and from JSON.
            </summary>
        </member>
        <member name="T:Blockcore.Utilities.JsonConverters.SignatureJsonConverter">
            <summary>
            Converter used to convert a <see cref="T:Blockcore.Consensus.ScriptInfo.Script"/> or a <see cref="T:Blockcore.Consensus.TransactionInfo.WitScript"/> to and from JSON.
            </summary>
            <seealso cref="T:Newtonsoft.Json.JsonConverter" />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.SignatureJsonConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.SignatureJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.SignatureJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Utilities.JsonConverters.TxDestinationJsonConverter">
            <summary>
            Converter used to convert a <see cref="T:Blockcore.NBitcoin.KeyId"/>, a <see cref="T:Blockcore.NBitcoin.ScriptId"/>, a <see cref="T:Blockcore.NBitcoin.WitKeyId"/> or a <see cref="T:Blockcore.NBitcoin.WitScriptId"/> to and from JSON.
            </summary>
            <seealso cref="T:Newtonsoft.Json.JsonConverter" />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.TxDestinationJsonConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.TxDestinationJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.TxDestinationJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Utilities.JsonConverters.UInt160JsonConverter">
            <summary>
            Converter used to convert a <see cref="T:Blockcore.NBitcoin.uint160"/> to and from JSON.
            </summary>
            <seealso cref="T:Newtonsoft.Json.JsonConverter" />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.UInt160JsonConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.UInt160JsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.UInt160JsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Utilities.JsonConverters.UInt256JsonConverter">
            <summary>
            Converter used to convert a <see cref="T:Blockcore.NBitcoin.uint256"/> to and from JSON.
            </summary>
            <seealso cref="T:Newtonsoft.Json.JsonConverter" />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.UInt256JsonConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.UInt256JsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.JsonConverters.UInt256JsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Utilities.LinqExtensions">
            <summary>
            Extension methods for IEnumerable interface.
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.LinqExtensions.Median(System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            Calculates a median value of a collection of long integers.
            </summary>
            <param name="source">Collection of numbers to count median of.</param>
            <returns>Median value, or 0 if the collection is empty.</returns>
        </member>
        <member name="M:Blockcore.Utilities.LinqExtensions.Median(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Calculates a median value of a collection of integers.
            </summary>
            <param name="source">Collection of numbers to count median of.</param>
            <returns>Median value, or 0 if the collection is empty.</returns>
        </member>
        <member name="M:Blockcore.Utilities.LinqExtensions.Median(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Calculates a median value of a collection of doubles.
            </summary>
            <param name="source">Collection of numbers to count median of.</param>
            <returns>Median value, or 0 if the collection is empty.</returns>
        </member>
        <member name="T:Blockcore.Utilities.ILockProtected">
            <summary>
            Supports object-level locking and allows external work in the context of the locks.
            Requires "lock (this.lockObject) { ...}" inside all of the object's public methods.
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.ILockProtected.Synchronous``1(System.Func{``0})">
            <summary>Allows external work within lock context.</summary>
        </member>
        <member name="M:Blockcore.Utilities.ILockProtected.Synchronous(System.Action)">
            <summary>Allows external work within lock context.</summary>
        </member>
        <member name="M:Blockcore.Utilities.LockProtected.Synchronous(System.Action)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.LockProtected.Synchronous``1(System.Func{``0})">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Utilities.LoggingExtensions">
            <summary>
            Extension methods for classes and interfaces related to logging.
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.LoggingExtensions.ToNLogLevel(Microsoft.Extensions.Logging.LogLevel)">
            <summary>
            Converts <see cref="T:Microsoft.Extensions.Logging.LogLevel"/> to <see cref="T:NLog.LogLevel"/>.
            </summary>
            <param name="logLevel">Log level value to convert.</param>
            <returns>NLog value of the log level.</returns>
        </member>
        <member name="M:Blockcore.Utilities.LoggingExtensions.ToNLogLevel(System.String)">
            <summary>
            Converts a string to a <see cref="T:NLog.LogLevel"/>.
            </summary>
            <param name="logLevel">Log level value to convert.</param>
            <returns>NLog value of the log level.</returns>
        </member>
        <member name="T:Blockcore.Utilities.MemoryCache`2">
            <summary>
            Memory cache that implements the Least Recently Used (LRU) policy.
            </summary>
        </member>
        <member name="T:Blockcore.Utilities.MemoryCache`2.CacheItem">
            <summary>Cache item for the inner usage of the <see cref="T:Blockcore.Utilities.MemoryCountCache`2"/> class.</summary>
        </member>
        <member name="P:Blockcore.Utilities.MemoryCache`2.CacheItem.Dirty">
            <summary>Indicates whether the item has been modified.</summary>
        </member>
        <member name="P:Blockcore.Utilities.MemoryCache`2.CacheItem.Size">
            <summary>Size of value in bytes.</summary>
        </member>
        <member name="M:Blockcore.Utilities.MemoryCache`2.CacheItem.#ctor(`0,`1)">
            <summary>Initializes a new instance of the <see cref="T:Blockcore.Utilities.MemoryCache`2.CacheItem"/> class.</summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:Blockcore.Utilities.MemoryCache`2.CacheItem.#ctor(`0,`1,System.Int64)">
            <summary>Initializes a new instance of the <see cref="T:Blockcore.Utilities.MemoryCache`2.CacheItem"/> class.</summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
        </member>
        <member name="P:Blockcore.Utilities.MemoryCache`2.Cache">
            <summary>Dictionary that contains cached items.</summary>
            <remarks>Should be accessed inside a lock using <see cref="P:Blockcore.Utilities.MemoryCache`2.LockObject"/>.</remarks>
        </member>
        <member name="P:Blockcore.Utilities.MemoryCache`2.Keys">
            <summary>Keys sorted by their last access time with most recent ones at the end.</summary>
            <remarks>Should be accessed inside a lock using <see cref="P:Blockcore.Utilities.MemoryCache`2.LockObject"/>.</remarks>
        </member>
        <member name="P:Blockcore.Utilities.MemoryCache`2.LockObject">
            <summary>Lock to protect access to <see cref="P:Blockcore.Utilities.MemoryCache`2.Keys"/> and <see cref="P:Blockcore.Utilities.MemoryCache`2.Cache"/>.</summary>
        </member>
        <member name="P:Blockcore.Utilities.MemoryCache`2.totalSize">
            <summary>Total size in bytes stored in the cache.</summary>
        </member>
        <member name="M:Blockcore.Utilities.MemoryCache`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Blockcore.Utilities.MemoryCache`2"/> class.
            </summary>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation to use when comparing keys, or <c>null</c> to use the default comparer for the type of the key.</param>
        </member>
        <member name="M:Blockcore.Utilities.MemoryCache`2.IsCacheFullLocked(Blockcore.Utilities.MemoryCache{`0,`1}.CacheItem)">
            <summary>Determine whether the cache has reached its limit.</summary>
            <returns><c>true</c> if cache contains the item, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Blockcore.Utilities.MemoryCache`2.ItemAddedLocked(Blockcore.Utilities.MemoryCache{`0,`1}.CacheItem)">
            <summary>An item was added to the cache.</summary>
        </member>
        <member name="M:Blockcore.Utilities.MemoryCache`2.ItemRemovedLocked(Blockcore.Utilities.MemoryCache{`0,`1}.CacheItem)">
            <summary>An item was removed from the cache.</summary>
        </member>
        <member name="P:Blockcore.Utilities.MemoryCache`2.Count">
            <summary>Gets the count of the current items for diagnostic purposes.</summary>
        </member>
        <member name="M:Blockcore.Utilities.MemoryCache`2.AddOrUpdate(Blockcore.Utilities.MemoryCache{`0,`1}.CacheItem)">
            <summary>Create or overwrite an item in the cache.</summary>
            <param name="item"><see cref="T:Blockcore.Utilities.MemoryCache`2.CacheItem"/> to add or update the cache.</param>
        </member>
        <member name="M:Blockcore.Utilities.MemoryCache`2.Remove(`0)">
            <summary>Removes the object associated with the given key.</summary>
            <param name="key">Key of that item that will be removed from the cache.</param>
        </member>
        <member name="M:Blockcore.Utilities.MemoryCache`2.TryGetValue(`0,`1@)">
            <summary>Gets an item associated with specific key if present.</summary>
            <param name="key">Item's key.</param>
            <param name="value">Item associated with specified <paramref name="key"/>.</param>
            <returns><c>true</c> if cache contains the item, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Blockcore.Utilities.MemoryCache`2.ClearCache">
            <summary>
            Flush the entire cache.
            </summary>
        </member>
        <member name="T:Blockcore.Utilities.MemoryCountCache`2">
            <summary>
            Memory count cache that implements the Least Recently Used (LRU) policy.
            </summary>
        </member>
        <member name="F:Blockcore.Utilities.MemoryCountCache`2.maxItemsCount">
            <summary>Maximum items count that can be stored in the cache.</summary>
        </member>
        <member name="M:Blockcore.Utilities.MemoryCountCache`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Blockcore.Utilities.MemoryCountCache`2"/> class.
            </summary>
            <param name="maxItemsCount">Maximum items count that can be stored in the cache.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation to use when comparing keys, or <c>null</c> to use the default comparer for the type of the key.</param>
        </member>
        <member name="M:Blockcore.Utilities.MemoryCountCache`2.AddOrUpdate(`0,`1)">
            <summary>Create or overwrite an item in the cache.</summary>
            <param name="key">The key.</param>
            <param name="value">The value to add to the cache.</param>
        </member>
        <member name="M:Blockcore.Utilities.MemoryCountCache`2.IsCacheFullLocked(Blockcore.Utilities.MemoryCache{`0,`1}.CacheItem)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Utilities.MemorySizeCache`2">
            <summary>
            Memory size cache that implements the Least Recently Used (LRU) policy.
            </summary>
        </member>
        <member name="F:Blockcore.Utilities.MemorySizeCache`2.maxSize">
            <summary>Maximum size in bytes that can be stored in the cache.</summary>
        </member>
        <member name="P:Blockcore.Utilities.MemorySizeCache`2.TotalSize">
            <summary>Gets the size of all items in the cache, in bytes.</summary>
        </member>
        <member name="P:Blockcore.Utilities.MemorySizeCache`2.MaxSize">
            <summary>Gets max size in bytes that can be stored in the cache.</summary>
        </member>
        <member name="M:Blockcore.Utilities.MemorySizeCache`2.#ctor(System.Int64,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Blockcore.Utilities.MemoryCountCache`2"/> class.
            </summary>
            <param name="maxSize">Maximum size in bytes count that can be stored in the cache.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation to use when comparing keys, or <c>null</c> to use the default comparer for the type of the key.</param>
        </member>
        <member name="M:Blockcore.Utilities.MemorySizeCache`2.AddOrUpdate(`0,`1,System.Int64)">
            <summary>Create or overwrite an item in the cache.</summary>
            <param name="key">The key.</param>
            <param name="value">The value to add to the cache.</param>
            <param name="size">Value size in bytes.</param>
        </member>
        <member name="T:Blockcore.Utilities.NetworkExtensions">
            <summary>
            Extension methods for NBitcoin's Network class.
            </summary>
        </member>
        <member name="F:Blockcore.Utilities.NetworkExtensions.MempoolHeight">
            <summary>Fake height value used in Coins to signify they are only in the memory pool (since 0.8).</summary>
        </member>
        <member name="M:Blockcore.Utilities.NetworkExtensions.IsTest(Blockcore.Networks.Network)">
            <summary>
            Determines whether this network is a test network.
            </summary>
            <param name="network">The network.</param>
            <returns><c>true</c> if the specified network is a test network, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Blockcore.Utilities.NetworkExtensions.IsRegTest(Blockcore.Networks.Network)">
            <summary>
            Determines whether this network is a regtest network.
            </summary>
            <param name="network">The network.</param>
            <returns><c>true</c> if the specified network is a regtest network, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Blockcore.Utilities.NetworkExtensions.IsBitcoin(Blockcore.Networks.Network)">
            <summary>
            Determines whether this network is a bitcoin network.
            </summary>
            <param name="network">The network.</param>
            <returns><c>true</c> if the specified network is bitcoin, <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Blockcore.Utilities.NetworkHelpers">
            <summary>
            Contains a collection of helpers methods.
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.NetworkHelpers.GetNetwork(System.String)">
            <summary>
            Get the network on which to operate.
            </summary>
            <param name="network">The network</param>
            <returns>A <see cref="T:Blockcore.Networks.Network"/> object.</returns>
        </member>
        <member name="T:Blockcore.Utilities.INodeLifetime">
            <summary>
            Allows consumers to perform cleanup during a graceful shutdown.
            </summary>
        </member>
        <member name="P:Blockcore.Utilities.INodeLifetime.ApplicationStarted">
            <summary>
            Triggered when the application host has fully started and is about to wait
            for a graceful shutdown.
            </summary>
        </member>
        <member name="P:Blockcore.Utilities.INodeLifetime.ApplicationStopping">
            <summary>
            Triggered when the application host is performing a graceful shutdown.
            Requests may still be in flight. Shutdown will block until this event completes.
            </summary>
        </member>
        <member name="P:Blockcore.Utilities.INodeLifetime.ApplicationStopped">
            <summary>
            Triggered when the application host is performing a graceful shutdown.
            All requests should be complete at this point. Shutdown will block
            until this event completes.
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.INodeLifetime.StopApplication">
            <summary>Requests termination the current application.</summary>
        </member>
        <member name="T:Blockcore.Utilities.NodeLifetime">
            <summary>
            Allows consumers to perform cleanup during a graceful shutdown.
            Borrowed from asp.net core
            </summary>
        </member>
        <member name="P:Blockcore.Utilities.NodeLifetime.ApplicationStarted">
            <summary>
            Triggered when the application host has fully started and is about to wait
            for a graceful shutdown.
            </summary>
        </member>
        <member name="P:Blockcore.Utilities.NodeLifetime.ApplicationStopping">
            <summary>
            Triggered when the application host is performing a graceful shutdown.
            Request may still be in flight. Shutdown will block until this event completes.
            </summary>
        </member>
        <member name="P:Blockcore.Utilities.NodeLifetime.ApplicationStopped">
            <summary>
            Triggered when the application host is performing a graceful shutdown.
            All requests should be complete at this point. Shutdown will block
            until this event completes.
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.NodeLifetime.StopApplication">
            <summary>
            Signals the ApplicationStopping event and blocks until it completes.
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.NodeLifetime.NotifyStarted">
            <summary>
            Signals the ApplicationStarted event and blocks until it completes.
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.NodeLifetime.NotifyStopped">
            <summary>
            Signals the ApplicationStopped event and blocks until it completes.
            </summary>
        </member>
        <member name="T:Blockcore.Utilities.NodeRunningLock">
            <summary>
            Class that prevents another instance of the node to run in the same data folder
            and allows external applications to see if the node is running.
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.INodeStats.RegisterStats(System.Action{System.Text.StringBuilder},Blockcore.Utilities.StatsType,System.String,System.Int32)">
            <summary>Registers action that will be used to append node stats when they are being collected.</summary>
            <param name="appendStatsAction">Action that will be invoked during stats collection.</param>
            <param name="statsType">Type of stats.</param>
            <param name="componentName">The component name.</param>
            <param name="priority">Stats priority that will be used to determine invocation priority of stats collection.</param>
        </member>
        <member name="M:Blockcore.Utilities.INodeStats.RemoveStats(Blockcore.Utilities.StatsType,System.String)">
            <summary>
            Removes stats previously registered.
            </summary>
            <param name="statsType">Type of stats.</param>
            <param name="componentName">The component name.</param>
        </member>
        <member name="M:Blockcore.Utilities.INodeStats.GetStats">
            <summary>Collects inline stats and then feature stats.</summary>
        </member>
        <member name="M:Blockcore.Utilities.INodeStats.GetBenchmark">
            <summary>Collects benchmark stats.</summary>
        </member>
        <member name="F:Blockcore.Utilities.NodeStats.locker">
            <summary>Protects access to <see cref="F:Blockcore.Utilities.NodeStats.stats"/>.</summary>
        </member>
        <member name="M:Blockcore.Utilities.NodeStats.RegisterStats(System.Action{System.Text.StringBuilder},Blockcore.Utilities.StatsType,System.String,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.NodeStats.RemoveStats(Blockcore.Utilities.StatsType,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.NodeStats.GetStats">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.NodeStats.GetBenchmark">
            <inheritdoc />
        </member>
        <member name="F:Blockcore.Utilities.StatsType.Inline">
            <summary>
            Inline stats are usually single line stats that should
            display most important information about the node.
            </summary>
        </member>
        <member name="F:Blockcore.Utilities.StatsType.Component">
            <summary>
            Component-related stats are usually blocks of component specific stats.
            </summary>
        </member>
        <member name="F:Blockcore.Utilities.StatsType.Benchmark">
            <summary>
            Benchmarking stats that display performance related information.
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.ParallelAsync.ForEachAsync``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Threading.CancellationToken,System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task})">
            <summary>
            Executes a foreach operation on an IEnumerable in which iterations run asynchronously.
            </summary>
            <typeparam name="TSource">Item type.</typeparam>
            <param name="collection">Enumerated collection.</param>
            <param name="maxDegreeOfParallelism">The maximum amount of items that can be processed simultaneously.</param>
            <param name="cancellationToken">Cancellation token.</param>
            <param name="action">Action that is used for processing each item in the collection.</param>
        </member>
        <member name="T:Blockcore.Utilities.ProtocolExtensions">
            <summary>
            Extension methods related to the network protocol.
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.ProtocolExtensions.GetMedianTimeOffset(System.Collections.Generic.IEnumerable{Blockcore.P2P.Peer.INetworkPeer})">
            <summary>
            Calculates a median of time offsets of the node's connected peers.
            <para>
            The peers' time offsets are differences in seconds between the node's clock and the peer's clock.
            </para>
            </summary>
            <param name="source">Collection of connected peer nodes.</param>
            <returns>Median time offset among the given nodes.</returns>
        </member>
        <member name="T:Blockcore.Utilities.ReaderWriterLock">
            <summary>
            Wraps ReaderWriterLockSlim with disposable interface so that
            it is possible to use using construct to avoid forgotten lock releases.
            </summary>
        </member>
        <member name="F:Blockcore.Utilities.ReaderWriterLock.rwLock">
            <summary>Internal lock object that the class wraps around.</summary>
        </member>
        <member name="M:Blockcore.Utilities.ReaderWriterLock.LockRead">
            <summary>
            Enters the reader's lock.
            </summary>
            <returns>Disposable interface to enable using construct. Disposing it releases the lock.</returns>
            <seealso cref="M:System.Threading.ReaderWriterLockSlim.EnterReadLock"/>
            <seealso cref="M:System.Threading.ReaderWriterLockSlim.ExitReadLock"/>
        </member>
        <member name="M:Blockcore.Utilities.ReaderWriterLock.LockWrite">
            <summary>
            Enters the writer's lock.
            </summary>
            <returns>Disposable interface to enable using construct. Disposing it releases the lock.</returns>
            <seealso cref="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock"/>
            <seealso cref="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock"/>
        </member>
        <member name="M:Blockcore.Utilities.ReaderWriterLock.TryLockWrite(System.IDisposable@)">
            <summary>
            Enters the writer's lock.
            </summary>
            <returns>Disposable interface to enable using construct.</returns>
            <seealso cref="M:System.Threading.ReaderWriterLockSlim.EnterReadLock"/>
        </member>
        <member name="M:Blockcore.Utilities.RetryStrategy.Run(Blockcore.Utilities.RetryOptions,System.Action,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Execute logic that should be retried if failure defined by <c>TException</c> occurs.
            </summary>
            <param name="retryOptions">Retry options, including number of retries and delay between them.</param>
            <param name="actionToExecute">Logic to be executed.</param>
            <param name="logger">Optional logger.</param>
        </member>
        <member name="T:Blockcore.Utilities.RewindData">
            <summary>
            Information about a previous state of the coinview that contains all information
            needed to rewind the coinview from the current state to the previous state.
            </summary>
        </member>
        <member name="F:Blockcore.Utilities.RewindData.previousBlockHash">
            <summary>Hash of the block header of the tip of the previous state of the coinview.</summary>
        </member>
        <member name="F:Blockcore.Utilities.RewindData.outputsToRemove">
            <summary>List of transaction IDs that needs to be removed when rewinding to the previous state as they haven't existed in the previous state.</summary>
        </member>
        <member name="F:Blockcore.Utilities.RewindData.outputsToRestore">
            <summary>List of unspent output transaction information that needs to be restored when rewinding to the previous state as they were fully spent in the current view.</summary>
        </member>
        <member name="P:Blockcore.Utilities.RewindData.PreviousBlockHash">
            <summary>Hash of the block header of the tip of the previous state of the coinview.</summary>
        </member>
        <member name="P:Blockcore.Utilities.RewindData.OutputsToRemove">
            <summary>List of transaction IDs that needs to be removed when rewinding to the previous state as they haven't existed in the previous state.</summary>
        </member>
        <member name="P:Blockcore.Utilities.RewindData.OutputsToRestore">
            <summary>List of unspent output transaction information that needs to be restored when rewinding to the previous state as they were fully spent in the current view.</summary>
        </member>
        <member name="M:Blockcore.Utilities.RewindData.ReadWrite(Blockcore.NBitcoin.BitcoinStream)">
            <inheritdoc />
        </member>
        <member name="T:Blockcore.Utilities.ISchedulerLock">
            <summary>
            An async reader writer lock for concurrent and exclusive work.
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.ISchedulerLock.ReadAsync(System.Action)">
            <summary>
            Queues concurrent work to the concurrent scheduler.
            Delegates calling this method will be done in parallel on the default scheduler.
            </summary>
            <param name="func">Method to be called with locked reader lock.</param>
        </member>
        <member name="M:Blockcore.Utilities.ISchedulerLock.ReadAsync``1(System.Func{``0})">
            <summary>
            Queues concurrent work to the concurrent scheduler.
            Delegates calling this method will be done in parallel on the default scheduler.
            </summary>
            <typeparam name="T">Return type of the delegated method.</typeparam>
            <param name="func">Method to be called with locked reader lock.</param>
            <returns>Return value of the delegated method.</returns>
        </member>
        <member name="M:Blockcore.Utilities.ISchedulerLock.WriteAsync(System.Action)">
            <summary>
            Queues sequential work to the exclusive scheduler.
            Delegates calling this method will be done in sequentially,
            The first task will be queued on the default scheduler subsequent exclusive tasks will run in that same thread.
            </summary>
            <param name="func">Method to be called with locked writer lock.</param>
        </member>
        <member name="M:Blockcore.Utilities.ISchedulerLock.WriteAsync``1(System.Func{``0})">
            <summary>
            Queues sequential work to the exclusive scheduler.
            Delegates calling this method will be done in sequentially,
            The first task will be queued on the default scheduler subsequent exclusive tasks will run in that same thread.
            </summary>
            <typeparam name="T">Return type of the delegated method.</typeparam>
            <param name="func">Method to be called with locked writer lock.</param>
            <returns>Return value of the delegated method.</returns>
        </member>
        <member name="T:Blockcore.Utilities.SchedulerLock">
            <summary>
            An async reader writer lock for concurrent and exclusive work.
            <para>
            The class uses ConcurrentExclusiveSchedulerPair to access two task schedulers - concurrent
            scheduler and exclusive scheduler. The exclusive scheduler guarantees only one task to be run
            at the same, which is what is used as a writer lock. The concurrent scheduler allows multiple
            tasks to run simultaneously, but the exclusivity of exclusive scheduler is respected, so it is
            used as a reader lock.
            </para>
            </summary>
            <remarks>
            From the TaskFactory.StartNew() remarks:
            Calling StartNew is functionally equivalent to creating a Task using one of its constructors
            and then calling <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution. However,
            unless creation and scheduling must be separated, StartNew is the recommended approach for both
            simplicity and performance.
            <para>
            WARNING: One has to be very careful using this class as the exclusivity of the exclusive scheduler
            only guarantees to actually run one task at the time, but if the task awaits, it is not considered
            as running and another task can be scheduled and run instead within the context of the exclusive
            scheduler. This means that the tasks run within both exclusive and concurrent schedulers
            must not await, otherwise there is a risk of a race condition. Thus in order to use this locking
            mechanism, one needs to first break up the asynchronous code to synchronous pieces and only then
            schedule the synchronous parts.
            </para>
            </remarks>
        </member>
        <member name="F:Blockcore.Utilities.SchedulerLock.concurrentFactory">
            <summary>Task factory that runs tasks using the concurrent scheduler. Serves as a reader lock.</summary>
        </member>
        <member name="F:Blockcore.Utilities.SchedulerLock.exclusiveFactory">
            <summary>Task factory that runs tasks using the exclusive scheduler. Serves as a writer lock.</summary>
        </member>
        <member name="M:Blockcore.Utilities.SchedulerLock.#ctor(System.Threading.CancellationTokenSource,System.Int32)">
            <summary>
            Initializes a new instance of the object with ability to cancel locked tasks.
            </summary>
            <param name="cancellation">Cancellation source to allow cancel the tasks run by the schedulers.</param>
            <param name="maxItemsPerTask">Number of exclusive tasks to process before checking concurrent tasks.</param>
        </member>
        <member name="M:Blockcore.Utilities.SchedulerLock.ReadAsync(System.Action)">
            <inheritdoc />
        </member>
        <member name="M:Blockcore.Utilities.SchedulerLock.ReadAsync``1(System.Func{``0})">
            <inheritdoc />
            <remarks>See warning in <see cref="T:Blockcore.Utilities.SchedulerLock"/> remarks section.</remarks>
        </member>
        <member name="M:Blockcore.Utilities.SchedulerLock.WriteAsync(System.Action)">
            <inheritdoc />
            <remarks>See warning in <see cref="T:Blockcore.Utilities.SchedulerLock"/> remarks section.</remarks>
        </member>
        <member name="M:Blockcore.Utilities.SchedulerLock.WriteAsync``1(System.Func{``0})">
            <inheritdoc />
            <remarks>See warning in <see cref="T:Blockcore.Utilities.SchedulerLock"/> remarks section.</remarks>
        </member>
        <member name="T:Blockcore.Utilities.SerializableResult`1">
            <summary>
            A generic result type that can be serialized.
            </summary>
            <typeparam name="T">The type of the value to return if the result was successful.</typeparam>
        </member>
        <member name="T:Blockcore.Utilities.StopwatchDisposable">
            <summary>
            Replacement for the <see cref="T:System.Diagnostics.Stopwatch"/> class that allows the caller
            to use a convenient way of calling the watch with the <c>using</c> statement due to
            the implementation of <see cref="T:System.IDisposable"/> interface.
            </summary>
            <remarks>
            Note that we are using <see cref="P:System.DateTime.Ticks"/> as a basic unit of measurement,
            not <see cref="P:System.Diagnostics.Stopwatch.ElapsedTicks"/>.
            Issue that cover this subject is <see href="https://github.com/stratisproject/StratisBitcoinFullNode/issues/2391"/>.
            </remarks>
            <example>
            <code>
            using (new StopwatchDisposable(o => this.Validator.PerformanceCounter.AddBlockFetchingTime(o)))
            {
                // Time of anything executed here will be added to the used performance counter.
            }
            </code>
            </example>
        </member>
        <member name="F:Blockcore.Utilities.StopwatchDisposable.watch">
            <summary>Stopwatch to measure elapsed ticks of the code block.</summary>
        </member>
        <member name="F:Blockcore.Utilities.StopwatchDisposable.action">
            <summary>
            Action to execute when the measurement is done.
            <para>
            This is usually a performance counter.
            The argument of the action is the number of elapsed ticks of the code block.
            </para>
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.StopwatchDisposable.#ctor(System.Action{System.Int64})">
            <summary>
            Creates a new disposable object and starts the time measurement.
            </summary>
            <param name="action">Action to execute when the measurement is done.</param>
        </member>
        <member name="M:Blockcore.Utilities.StopwatchDisposable.Dispose">
            <summary>
            Stops the time measurement and calls the action with the measured elapsed ticks.
            </summary>
        </member>
        <member name="T:Blockcore.Utilities.Store.IKeyValueRepository">
            <summary>Allows saving and loading single values to and from key-value storage.</summary>
        </member>
        <member name="M:Blockcore.Utilities.Store.IKeyValueRepository.SaveBytes(System.String,System.Byte[])">
            <summary>Persists byte array to the database.</summary>
        </member>
        <member name="M:Blockcore.Utilities.Store.IKeyValueRepository.SaveValue``1(System.String,``0)">
            <summary>Persists any object that <see cref="T:Blockcore.Utilities.DataStoreSerializer"/> can serialize to the database.</summary>
        </member>
        <member name="M:Blockcore.Utilities.Store.IKeyValueRepository.SaveValueJson``1(System.String,``0)">
            <summary>Persists any object to the database. Object is stored as JSON.</summary>
        </member>
        <member name="M:Blockcore.Utilities.Store.IKeyValueRepository.LoadBytes(System.String)">
            <summary>Loads byte array from the database.</summary>
        </member>
        <member name="M:Blockcore.Utilities.Store.IKeyValueRepository.LoadValue``1(System.String)">
            <summary>Loads an object that <see cref="T:Blockcore.Utilities.DataStoreSerializer"/> can deserialize from the database.</summary>
        </member>
        <member name="M:Blockcore.Utilities.Store.IKeyValueRepository.LoadValueJson``1(System.String)">
            <summary>Loads JSON from the database and deserializes it.</summary>
        </member>
        <member name="T:Blockcore.Utilities.TimerExtensions">
            <summary>
            Extension methods for the <see cref="T:System.Timers.Timer"/> class.
            </summary>
        </member>
        <member name="M:Blockcore.Utilities.TimerExtensions.Reset(System.Timers.Timer)">
            <summary>
            Reset a timer from the start.
            </summary>
            <param name="timer">The timer to reset.</param>
        </member>
        <member name="T:Blockcore.Utilities.TimeSpans">
            <summary>
            Commonly used time spans.
            </summary>
        </member>
        <member name="P:Blockcore.Utilities.TimeSpans.Ms100">
            <summary>Time span of 100 milliseconds.</summary>
        </member>
        <member name="P:Blockcore.Utilities.TimeSpans.Second">
            <summary>Time span of 1 second.</summary>
        </member>
        <member name="P:Blockcore.Utilities.TimeSpans.FiveSeconds">
            <summary>Time span of 5 seconds.</summary>
        </member>
        <member name="P:Blockcore.Utilities.TimeSpans.TenSeconds">
            <summary>Time span of 10 seconds.</summary>
        </member>
        <member name="P:Blockcore.Utilities.TimeSpans.Minute">
            <summary>Time span of 1 minute.</summary>
        </member>
        <member name="P:Blockcore.Utilities.TimeSpans.RunOnce">
            <summary>
            Special time span value used for repeat frequency values, for which it means that
            the event should be only run once and not repeated.
            </summary>
        </member>
        <member name="T:Blockcore.Utilities.Coins">
            <summary>
            Represents an immutable instance of a transaction outout.
            To be used by coindb to serialize utxo to storage.
            </summary>
        </member>
        <member name="P:Blockcore.Utilities.UnspentOutput.CreatedFromBlock">
            <summary>
            A flag to mark that the output is new and was created
            form the block (and not fetched from disk or from cache).
            This is only to be used by the coindb internal logic to indicate
            and output is new and there is no need to try to fetch it form cache.
            </summary>
        </member>
        <member name="T:Blockcore.Utilities.ValidationAttributes.MoneyFormatAttribute">
            <summary>
            Validation attribute to check whether the data is in the right format to represent <see cref="T:Blockcore.NBitcoin.Money"/>.
            </summary>
        </member>
        <member name="F:Blockcore.Utilities.ValidationAttributes.MoneyFormatAttribute.isRequired">
            <summary> A value indicating whether the data field is required. </summary>
        </member>
        <member name="M:Blockcore.Utilities.ValidationAttributes.MoneyFormatAttribute.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Blockcore.Utilities.ValidationAttributes.MoneyFormatAttribute"/> class.
            </summary>
            <param name="isRequired">A value indicating whether the data field is required.</param>
        </member>
        <member name="M:Blockcore.Utilities.ValidationAttributes.MoneyFormatAttribute.IsValid(System.Object)">
            <inheritdoc/>
        </member>
    </members>
</doc>
